/* soapC.cpp
   Generated by gSOAP 2.8.45 for generated/prototypes.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.45 2025-04-21 08:43:55 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap);
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap);
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = soap_new_SOAP_ENV__Detail(soap);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_ns1__LuaType:
		return soap_in_ns1__LuaType(soap, NULL, NULL, "ns1:LuaType");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__LuaValue:
		return soap_in_ns1__LuaValue(soap, NULL, NULL, "ns1:LuaValue");
	case SOAP_TYPE_ns1__ArrayOfJob:
		return soap_in_ns1__ArrayOfJob(soap, NULL, NULL, "ns1:ArrayOfJob");
	case SOAP_TYPE_ns1__ArrayOfLuaValue:
		return soap_in_ns1__ArrayOfLuaValue(soap, NULL, NULL, "ns1:ArrayOfLuaValue");
	case SOAP_TYPE_ns1__ScriptExecution:
		return soap_in_ns1__ScriptExecution(soap, NULL, NULL, "ns1:ScriptExecution");
	case SOAP_TYPE_ns1__Job:
		return soap_in_ns1__Job(soap, NULL, NULL, "ns1:Job");
	case SOAP_TYPE_ns1__Status:
		return soap_in_ns1__Status(soap, NULL, NULL, "ns1:Status");
	case SOAP_TYPE_PointerTo_ns1__DiagEx:
		return soap_in_PointerTo_ns1__DiagEx(soap, NULL, NULL, "ns1:DiagEx");
	case SOAP_TYPE_PointerTo_ns1__Diag:
		return soap_in_PointerTo_ns1__Diag(soap, NULL, NULL, "ns1:Diag");
	case SOAP_TYPE_PointerTo_ns1__CloseAllJobs:
		return soap_in_PointerTo_ns1__CloseAllJobs(soap, NULL, NULL, "ns1:CloseAllJobs");
	case SOAP_TYPE_PointerTo_ns1__CloseExpiredJobs:
		return soap_in_PointerTo_ns1__CloseExpiredJobs(soap, NULL, NULL, "ns1:CloseExpiredJobs");
	case SOAP_TYPE_PointerTo_ns1__GetAllJobsEx:
		return soap_in_PointerTo_ns1__GetAllJobsEx(soap, NULL, NULL, "ns1:GetAllJobsEx");
	case SOAP_TYPE_PointerTo_ns1__GetAllJobs:
		return soap_in_PointerTo_ns1__GetAllJobs(soap, NULL, NULL, "ns1:GetAllJobs");
	case SOAP_TYPE_PointerTo_ns1__GetExpiration:
		return soap_in_PointerTo_ns1__GetExpiration(soap, NULL, NULL, "ns1:GetExpiration");
	case SOAP_TYPE_PointerTo_ns1__BatchJobEx:
		return soap_in_PointerTo_ns1__BatchJobEx(soap, NULL, NULL, "ns1:BatchJobEx");
	case SOAP_TYPE_PointerTo_ns1__BatchJob:
		return soap_in_PointerTo_ns1__BatchJob(soap, NULL, NULL, "ns1:BatchJob");
	case SOAP_TYPE_PointerTo_ns1__CloseJob:
		return soap_in_PointerTo_ns1__CloseJob(soap, NULL, NULL, "ns1:CloseJob");
	case SOAP_TYPE_PointerTo_ns1__ExecuteEx:
		return soap_in_PointerTo_ns1__ExecuteEx(soap, NULL, NULL, "ns1:ExecuteEx");
	case SOAP_TYPE_PointerTo_ns1__Execute:
		return soap_in_PointerTo_ns1__Execute(soap, NULL, NULL, "ns1:Execute");
	case SOAP_TYPE_PointerTo_ns1__RenewLease:
		return soap_in_PointerTo_ns1__RenewLease(soap, NULL, NULL, "ns1:RenewLease");
	case SOAP_TYPE_PointerTo_ns1__OpenJobEx:
		return soap_in_PointerTo_ns1__OpenJobEx(soap, NULL, NULL, "ns1:OpenJobEx");
	case SOAP_TYPE_PointerTo_ns1__OpenJob:
		return soap_in_PointerTo_ns1__OpenJob(soap, NULL, NULL, "ns1:OpenJob");
	case SOAP_TYPE_PointerTo_ns1__GetStatus:
		return soap_in_PointerTo_ns1__GetStatus(soap, NULL, NULL, "ns1:GetStatus");
	case SOAP_TYPE_PointerTo_ns1__GetVersion:
		return soap_in_PointerTo_ns1__GetVersion(soap, NULL, NULL, "ns1:GetVersion");
	case SOAP_TYPE_PointerTo_ns1__HelloWorld:
		return soap_in_PointerTo_ns1__HelloWorld(soap, NULL, NULL, "ns1:HelloWorld");
	case SOAP_TYPE_PointerTons1__ArrayOfJob:
		return soap_in_PointerTons1__ArrayOfJob(soap, NULL, NULL, "ns1:ArrayOfJob");
	case SOAP_TYPE_PointerTons1__ScriptExecution:
		return soap_in_PointerTons1__ScriptExecution(soap, NULL, NULL, "ns1:ScriptExecution");
	case SOAP_TYPE_PointerTons1__Status:
		return soap_in_PointerTons1__Status(soap, NULL, NULL, "ns1:Status");
	case SOAP_TYPE_PointerTons1__Job:
		return soap_in_PointerTons1__Job(soap, NULL, NULL, "ns1:Job");
	case SOAP_TYPE_PointerTons1__LuaValue:
		return soap_in_PointerTons1__LuaValue(soap, NULL, NULL, "ns1:LuaValue");
	case SOAP_TYPE_PointerTons1__ArrayOfLuaValue:
		return soap_in_PointerTons1__ArrayOfLuaValue(soap, NULL, NULL, "ns1:ArrayOfLuaValue");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LuaValue"))
		{	*type = SOAP_TYPE_ns1__LuaValue;
			return soap_in_ns1__LuaValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfJob"))
		{	*type = SOAP_TYPE_ns1__ArrayOfJob;
			return soap_in_ns1__ArrayOfJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ArrayOfLuaValue"))
		{	*type = SOAP_TYPE_ns1__ArrayOfLuaValue;
			return soap_in_ns1__ArrayOfLuaValue(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScriptExecution"))
		{	*type = SOAP_TYPE_ns1__ScriptExecution;
			return soap_in_ns1__ScriptExecution(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Job"))
		{	*type = SOAP_TYPE_ns1__Job;
			return soap_in_ns1__Job(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Status"))
		{	*type = SOAP_TYPE_ns1__Status;
			return soap_in_ns1__Status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LuaType"))
		{	*type = SOAP_TYPE_ns1__LuaType;
			return soap_in_ns1__LuaType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "ns1:DiagExResponse"))
		{	*type = SOAP_TYPE__ns1__DiagExResponse;
			return soap_in__ns1__DiagExResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DiagEx"))
		{	*type = SOAP_TYPE__ns1__DiagEx;
			return soap_in__ns1__DiagEx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DiagResponse"))
		{	*type = SOAP_TYPE__ns1__DiagResponse;
			return soap_in__ns1__DiagResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Diag"))
		{	*type = SOAP_TYPE__ns1__Diag;
			return soap_in__ns1__Diag(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CloseAllJobsResponse"))
		{	*type = SOAP_TYPE__ns1__CloseAllJobsResponse;
			return soap_in__ns1__CloseAllJobsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CloseAllJobs"))
		{	*type = SOAP_TYPE__ns1__CloseAllJobs;
			return soap_in__ns1__CloseAllJobs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CloseExpiredJobsResponse"))
		{	*type = SOAP_TYPE__ns1__CloseExpiredJobsResponse;
			return soap_in__ns1__CloseExpiredJobsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CloseExpiredJobs"))
		{	*type = SOAP_TYPE__ns1__CloseExpiredJobs;
			return soap_in__ns1__CloseExpiredJobs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAllJobsExResponse"))
		{	*type = SOAP_TYPE__ns1__GetAllJobsExResponse;
			return soap_in__ns1__GetAllJobsExResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAllJobsEx"))
		{	*type = SOAP_TYPE__ns1__GetAllJobsEx;
			return soap_in__ns1__GetAllJobsEx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAllJobsResponse"))
		{	*type = SOAP_TYPE__ns1__GetAllJobsResponse;
			return soap_in__ns1__GetAllJobsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetAllJobs"))
		{	*type = SOAP_TYPE__ns1__GetAllJobs;
			return soap_in__ns1__GetAllJobs(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetExpirationResponse"))
		{	*type = SOAP_TYPE__ns1__GetExpirationResponse;
			return soap_in__ns1__GetExpirationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetExpiration"))
		{	*type = SOAP_TYPE__ns1__GetExpiration;
			return soap_in__ns1__GetExpiration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BatchJobExResponse"))
		{	*type = SOAP_TYPE__ns1__BatchJobExResponse;
			return soap_in__ns1__BatchJobExResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BatchJobEx"))
		{	*type = SOAP_TYPE__ns1__BatchJobEx;
			return soap_in__ns1__BatchJobEx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BatchJobResponse"))
		{	*type = SOAP_TYPE__ns1__BatchJobResponse;
			return soap_in__ns1__BatchJobResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BatchJob"))
		{	*type = SOAP_TYPE__ns1__BatchJob;
			return soap_in__ns1__BatchJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CloseJobResponse"))
		{	*type = SOAP_TYPE__ns1__CloseJobResponse;
			return soap_in__ns1__CloseJobResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CloseJob"))
		{	*type = SOAP_TYPE__ns1__CloseJob;
			return soap_in__ns1__CloseJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteExResponse"))
		{	*type = SOAP_TYPE__ns1__ExecuteExResponse;
			return soap_in__ns1__ExecuteExResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteEx"))
		{	*type = SOAP_TYPE__ns1__ExecuteEx;
			return soap_in__ns1__ExecuteEx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ExecuteResponse"))
		{	*type = SOAP_TYPE__ns1__ExecuteResponse;
			return soap_in__ns1__ExecuteResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Execute"))
		{	*type = SOAP_TYPE__ns1__Execute;
			return soap_in__ns1__Execute(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RenewLeaseResponse"))
		{	*type = SOAP_TYPE__ns1__RenewLeaseResponse;
			return soap_in__ns1__RenewLeaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RenewLease"))
		{	*type = SOAP_TYPE__ns1__RenewLease;
			return soap_in__ns1__RenewLease(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OpenJobExResponse"))
		{	*type = SOAP_TYPE__ns1__OpenJobExResponse;
			return soap_in__ns1__OpenJobExResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OpenJobResponse"))
		{	*type = SOAP_TYPE__ns1__OpenJobResponse;
			return soap_in__ns1__OpenJobResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OpenJobEx"))
		{	*type = SOAP_TYPE__ns1__OpenJobEx;
			return soap_in__ns1__OpenJobEx(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OpenJob"))
		{	*type = SOAP_TYPE__ns1__OpenJob;
			return soap_in__ns1__OpenJob(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStatusResponse"))
		{	*type = SOAP_TYPE__ns1__GetStatusResponse;
			return soap_in__ns1__GetStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetStatus"))
		{	*type = SOAP_TYPE__ns1__GetStatus;
			return soap_in__ns1__GetStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVersionResponse"))
		{	*type = SOAP_TYPE__ns1__GetVersionResponse;
			return soap_in__ns1__GetVersionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GetVersion"))
		{	*type = SOAP_TYPE__ns1__GetVersion;
			return soap_in__ns1__GetVersion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HelloWorldResponse"))
		{	*type = SOAP_TYPE__ns1__HelloWorldResponse;
			return soap_in__ns1__HelloWorldResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HelloWorld"))
		{	*type = SOAP_TYPE__ns1__HelloWorld;
			return soap_in__ns1__HelloWorld(soap, NULL, NULL, NULL);
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				if (soap_ignore(soap) || soap_element_end_in(soap, NULL))
					return soap->error;
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_ns1__LuaType:
		return soap_out_ns1__LuaType(soap, tag, id, (const enum ns1__LuaType *)ptr, "ns1:LuaType");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__ns1__DiagExResponse:
		return ((_ns1__DiagExResponse *)ptr)->soap_out(soap, "ns1:DiagExResponse", id, "");
	case SOAP_TYPE__ns1__DiagEx:
		return ((_ns1__DiagEx *)ptr)->soap_out(soap, "ns1:DiagEx", id, "");
	case SOAP_TYPE__ns1__DiagResponse:
		return ((_ns1__DiagResponse *)ptr)->soap_out(soap, "ns1:DiagResponse", id, "");
	case SOAP_TYPE__ns1__Diag:
		return ((_ns1__Diag *)ptr)->soap_out(soap, "ns1:Diag", id, "");
	case SOAP_TYPE__ns1__CloseAllJobsResponse:
		return ((_ns1__CloseAllJobsResponse *)ptr)->soap_out(soap, "ns1:CloseAllJobsResponse", id, "");
	case SOAP_TYPE__ns1__CloseAllJobs:
		return ((_ns1__CloseAllJobs *)ptr)->soap_out(soap, "ns1:CloseAllJobs", id, "");
	case SOAP_TYPE__ns1__CloseExpiredJobsResponse:
		return ((_ns1__CloseExpiredJobsResponse *)ptr)->soap_out(soap, "ns1:CloseExpiredJobsResponse", id, "");
	case SOAP_TYPE__ns1__CloseExpiredJobs:
		return ((_ns1__CloseExpiredJobs *)ptr)->soap_out(soap, "ns1:CloseExpiredJobs", id, "");
	case SOAP_TYPE__ns1__GetAllJobsExResponse:
		return ((_ns1__GetAllJobsExResponse *)ptr)->soap_out(soap, "ns1:GetAllJobsExResponse", id, "");
	case SOAP_TYPE__ns1__GetAllJobsEx:
		return ((_ns1__GetAllJobsEx *)ptr)->soap_out(soap, "ns1:GetAllJobsEx", id, "");
	case SOAP_TYPE__ns1__GetAllJobsResponse:
		return ((_ns1__GetAllJobsResponse *)ptr)->soap_out(soap, "ns1:GetAllJobsResponse", id, "");
	case SOAP_TYPE__ns1__GetAllJobs:
		return ((_ns1__GetAllJobs *)ptr)->soap_out(soap, "ns1:GetAllJobs", id, "");
	case SOAP_TYPE__ns1__GetExpirationResponse:
		return ((_ns1__GetExpirationResponse *)ptr)->soap_out(soap, "ns1:GetExpirationResponse", id, "");
	case SOAP_TYPE__ns1__GetExpiration:
		return ((_ns1__GetExpiration *)ptr)->soap_out(soap, "ns1:GetExpiration", id, "");
	case SOAP_TYPE__ns1__BatchJobExResponse:
		return ((_ns1__BatchJobExResponse *)ptr)->soap_out(soap, "ns1:BatchJobExResponse", id, "");
	case SOAP_TYPE__ns1__BatchJobEx:
		return ((_ns1__BatchJobEx *)ptr)->soap_out(soap, "ns1:BatchJobEx", id, "");
	case SOAP_TYPE__ns1__BatchJobResponse:
		return ((_ns1__BatchJobResponse *)ptr)->soap_out(soap, "ns1:BatchJobResponse", id, "");
	case SOAP_TYPE__ns1__BatchJob:
		return ((_ns1__BatchJob *)ptr)->soap_out(soap, "ns1:BatchJob", id, "");
	case SOAP_TYPE__ns1__CloseJobResponse:
		return ((_ns1__CloseJobResponse *)ptr)->soap_out(soap, "ns1:CloseJobResponse", id, "");
	case SOAP_TYPE__ns1__CloseJob:
		return ((_ns1__CloseJob *)ptr)->soap_out(soap, "ns1:CloseJob", id, "");
	case SOAP_TYPE__ns1__ExecuteExResponse:
		return ((_ns1__ExecuteExResponse *)ptr)->soap_out(soap, "ns1:ExecuteExResponse", id, "");
	case SOAP_TYPE__ns1__ExecuteEx:
		return ((_ns1__ExecuteEx *)ptr)->soap_out(soap, "ns1:ExecuteEx", id, "");
	case SOAP_TYPE__ns1__ExecuteResponse:
		return ((_ns1__ExecuteResponse *)ptr)->soap_out(soap, "ns1:ExecuteResponse", id, "");
	case SOAP_TYPE__ns1__Execute:
		return ((_ns1__Execute *)ptr)->soap_out(soap, "ns1:Execute", id, "");
	case SOAP_TYPE__ns1__RenewLeaseResponse:
		return ((_ns1__RenewLeaseResponse *)ptr)->soap_out(soap, "ns1:RenewLeaseResponse", id, "");
	case SOAP_TYPE__ns1__RenewLease:
		return ((_ns1__RenewLease *)ptr)->soap_out(soap, "ns1:RenewLease", id, "");
	case SOAP_TYPE__ns1__OpenJobExResponse:
		return ((_ns1__OpenJobExResponse *)ptr)->soap_out(soap, "ns1:OpenJobExResponse", id, "");
	case SOAP_TYPE__ns1__OpenJobResponse:
		return ((_ns1__OpenJobResponse *)ptr)->soap_out(soap, "ns1:OpenJobResponse", id, "");
	case SOAP_TYPE__ns1__OpenJobEx:
		return ((_ns1__OpenJobEx *)ptr)->soap_out(soap, "ns1:OpenJobEx", id, "");
	case SOAP_TYPE__ns1__OpenJob:
		return ((_ns1__OpenJob *)ptr)->soap_out(soap, "ns1:OpenJob", id, "");
	case SOAP_TYPE__ns1__GetStatusResponse:
		return ((_ns1__GetStatusResponse *)ptr)->soap_out(soap, "ns1:GetStatusResponse", id, "");
	case SOAP_TYPE__ns1__GetStatus:
		return ((_ns1__GetStatus *)ptr)->soap_out(soap, "ns1:GetStatus", id, "");
	case SOAP_TYPE__ns1__GetVersionResponse:
		return ((_ns1__GetVersionResponse *)ptr)->soap_out(soap, "ns1:GetVersionResponse", id, "");
	case SOAP_TYPE__ns1__GetVersion:
		return ((_ns1__GetVersion *)ptr)->soap_out(soap, "ns1:GetVersion", id, "");
	case SOAP_TYPE__ns1__HelloWorldResponse:
		return ((_ns1__HelloWorldResponse *)ptr)->soap_out(soap, "ns1:HelloWorldResponse", id, "");
	case SOAP_TYPE__ns1__HelloWorld:
		return ((_ns1__HelloWorld *)ptr)->soap_out(soap, "ns1:HelloWorld", id, "");
	case SOAP_TYPE_ns1__LuaValue:
		return ((ns1__LuaValue *)ptr)->soap_out(soap, tag, id, "ns1:LuaValue");
	case SOAP_TYPE_ns1__ArrayOfJob:
		return ((ns1__ArrayOfJob *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfJob");
	case SOAP_TYPE_ns1__ArrayOfLuaValue:
		return ((ns1__ArrayOfLuaValue *)ptr)->soap_out(soap, tag, id, "ns1:ArrayOfLuaValue");
	case SOAP_TYPE_ns1__ScriptExecution:
		return ((ns1__ScriptExecution *)ptr)->soap_out(soap, tag, id, "ns1:ScriptExecution");
	case SOAP_TYPE_ns1__Job:
		return ((ns1__Job *)ptr)->soap_out(soap, tag, id, "ns1:Job");
	case SOAP_TYPE_ns1__Status:
		return ((ns1__Status *)ptr)->soap_out(soap, tag, id, "ns1:Status");
	case SOAP_TYPE_PointerTo_ns1__DiagEx:
		return soap_out_PointerTo_ns1__DiagEx(soap, tag, id, (_ns1__DiagEx *const*)ptr, "ns1:DiagEx");
	case SOAP_TYPE_PointerTo_ns1__Diag:
		return soap_out_PointerTo_ns1__Diag(soap, tag, id, (_ns1__Diag *const*)ptr, "ns1:Diag");
	case SOAP_TYPE_PointerTo_ns1__CloseAllJobs:
		return soap_out_PointerTo_ns1__CloseAllJobs(soap, tag, id, (_ns1__CloseAllJobs *const*)ptr, "ns1:CloseAllJobs");
	case SOAP_TYPE_PointerTo_ns1__CloseExpiredJobs:
		return soap_out_PointerTo_ns1__CloseExpiredJobs(soap, tag, id, (_ns1__CloseExpiredJobs *const*)ptr, "ns1:CloseExpiredJobs");
	case SOAP_TYPE_PointerTo_ns1__GetAllJobsEx:
		return soap_out_PointerTo_ns1__GetAllJobsEx(soap, tag, id, (_ns1__GetAllJobsEx *const*)ptr, "ns1:GetAllJobsEx");
	case SOAP_TYPE_PointerTo_ns1__GetAllJobs:
		return soap_out_PointerTo_ns1__GetAllJobs(soap, tag, id, (_ns1__GetAllJobs *const*)ptr, "ns1:GetAllJobs");
	case SOAP_TYPE_PointerTo_ns1__GetExpiration:
		return soap_out_PointerTo_ns1__GetExpiration(soap, tag, id, (_ns1__GetExpiration *const*)ptr, "ns1:GetExpiration");
	case SOAP_TYPE_PointerTo_ns1__BatchJobEx:
		return soap_out_PointerTo_ns1__BatchJobEx(soap, tag, id, (_ns1__BatchJobEx *const*)ptr, "ns1:BatchJobEx");
	case SOAP_TYPE_PointerTo_ns1__BatchJob:
		return soap_out_PointerTo_ns1__BatchJob(soap, tag, id, (_ns1__BatchJob *const*)ptr, "ns1:BatchJob");
	case SOAP_TYPE_PointerTo_ns1__CloseJob:
		return soap_out_PointerTo_ns1__CloseJob(soap, tag, id, (_ns1__CloseJob *const*)ptr, "ns1:CloseJob");
	case SOAP_TYPE_PointerTo_ns1__ExecuteEx:
		return soap_out_PointerTo_ns1__ExecuteEx(soap, tag, id, (_ns1__ExecuteEx *const*)ptr, "ns1:ExecuteEx");
	case SOAP_TYPE_PointerTo_ns1__Execute:
		return soap_out_PointerTo_ns1__Execute(soap, tag, id, (_ns1__Execute *const*)ptr, "ns1:Execute");
	case SOAP_TYPE_PointerTo_ns1__RenewLease:
		return soap_out_PointerTo_ns1__RenewLease(soap, tag, id, (_ns1__RenewLease *const*)ptr, "ns1:RenewLease");
	case SOAP_TYPE_PointerTo_ns1__OpenJobEx:
		return soap_out_PointerTo_ns1__OpenJobEx(soap, tag, id, (_ns1__OpenJobEx *const*)ptr, "ns1:OpenJobEx");
	case SOAP_TYPE_PointerTo_ns1__OpenJob:
		return soap_out_PointerTo_ns1__OpenJob(soap, tag, id, (_ns1__OpenJob *const*)ptr, "ns1:OpenJob");
	case SOAP_TYPE_PointerTo_ns1__GetStatus:
		return soap_out_PointerTo_ns1__GetStatus(soap, tag, id, (_ns1__GetStatus *const*)ptr, "ns1:GetStatus");
	case SOAP_TYPE_PointerTo_ns1__GetVersion:
		return soap_out_PointerTo_ns1__GetVersion(soap, tag, id, (_ns1__GetVersion *const*)ptr, "ns1:GetVersion");
	case SOAP_TYPE_PointerTo_ns1__HelloWorld:
		return soap_out_PointerTo_ns1__HelloWorld(soap, tag, id, (_ns1__HelloWorld *const*)ptr, "ns1:HelloWorld");
	case SOAP_TYPE_PointerTons1__ArrayOfJob:
		return soap_out_PointerTons1__ArrayOfJob(soap, tag, id, (ns1__ArrayOfJob *const*)ptr, "ns1:ArrayOfJob");
	case SOAP_TYPE_PointerTons1__ScriptExecution:
		return soap_out_PointerTons1__ScriptExecution(soap, tag, id, (ns1__ScriptExecution *const*)ptr, "ns1:ScriptExecution");
	case SOAP_TYPE_PointerTons1__Status:
		return soap_out_PointerTons1__Status(soap, tag, id, (ns1__Status *const*)ptr, "ns1:Status");
	case SOAP_TYPE_PointerTons1__Job:
		return soap_out_PointerTons1__Job(soap, tag, id, (ns1__Job *const*)ptr, "ns1:Job");
	case SOAP_TYPE_PointerTons1__LuaValue:
		return soap_out_PointerTons1__LuaValue(soap, tag, id, (ns1__LuaValue *const*)ptr, "ns1:LuaValue");
	case SOAP_TYPE_PointerTons1__ArrayOfLuaValue:
		return soap_out_PointerTons1__ArrayOfLuaValue(soap, tag, id, (ns1__ArrayOfLuaValue *const*)ptr, "ns1:ArrayOfLuaValue");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__ns1__DiagExResponse:
		((_ns1__DiagExResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DiagEx:
		((_ns1__DiagEx *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__DiagResponse:
		((_ns1__DiagResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Diag:
		((_ns1__Diag *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CloseAllJobsResponse:
		((_ns1__CloseAllJobsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CloseAllJobs:
		((_ns1__CloseAllJobs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CloseExpiredJobsResponse:
		((_ns1__CloseExpiredJobsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CloseExpiredJobs:
		((_ns1__CloseExpiredJobs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAllJobsExResponse:
		((_ns1__GetAllJobsExResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAllJobsEx:
		((_ns1__GetAllJobsEx *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAllJobsResponse:
		((_ns1__GetAllJobsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetAllJobs:
		((_ns1__GetAllJobs *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetExpirationResponse:
		((_ns1__GetExpirationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetExpiration:
		((_ns1__GetExpiration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BatchJobExResponse:
		((_ns1__BatchJobExResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BatchJobEx:
		((_ns1__BatchJobEx *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BatchJobResponse:
		((_ns1__BatchJobResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__BatchJob:
		((_ns1__BatchJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CloseJobResponse:
		((_ns1__CloseJobResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__CloseJob:
		((_ns1__CloseJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExecuteExResponse:
		((_ns1__ExecuteExResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExecuteEx:
		((_ns1__ExecuteEx *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__ExecuteResponse:
		((_ns1__ExecuteResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__Execute:
		((_ns1__Execute *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RenewLeaseResponse:
		((_ns1__RenewLeaseResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__RenewLease:
		((_ns1__RenewLease *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OpenJobExResponse:
		((_ns1__OpenJobExResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OpenJobResponse:
		((_ns1__OpenJobResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OpenJobEx:
		((_ns1__OpenJobEx *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__OpenJob:
		((_ns1__OpenJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStatusResponse:
		((_ns1__GetStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetStatus:
		((_ns1__GetStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetVersionResponse:
		((_ns1__GetVersionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__GetVersion:
		((_ns1__GetVersion *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__HelloWorldResponse:
		((_ns1__HelloWorldResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__ns1__HelloWorld:
		((_ns1__HelloWorld *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LuaValue:
		((ns1__LuaValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfJob:
		((ns1__ArrayOfJob *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ArrayOfLuaValue:
		((ns1__ArrayOfLuaValue *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ScriptExecution:
		((ns1__ScriptExecution *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Job:
		((ns1__Job *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__Status:
		((ns1__Status *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__DiagEx_:
		soap_serialize___ns1__DiagEx_(soap, (const struct __ns1__DiagEx_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Diag_:
		soap_serialize___ns1__Diag_(soap, (const struct __ns1__Diag_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CloseAllJobs_:
		soap_serialize___ns1__CloseAllJobs_(soap, (const struct __ns1__CloseAllJobs_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CloseExpiredJobs_:
		soap_serialize___ns1__CloseExpiredJobs_(soap, (const struct __ns1__CloseExpiredJobs_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAllJobsEx_:
		soap_serialize___ns1__GetAllJobsEx_(soap, (const struct __ns1__GetAllJobsEx_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAllJobs_:
		soap_serialize___ns1__GetAllJobs_(soap, (const struct __ns1__GetAllJobs_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetExpiration_:
		soap_serialize___ns1__GetExpiration_(soap, (const struct __ns1__GetExpiration_ *)ptr);
		break;
	case SOAP_TYPE___ns1__BatchJobEx_:
		soap_serialize___ns1__BatchJobEx_(soap, (const struct __ns1__BatchJobEx_ *)ptr);
		break;
	case SOAP_TYPE___ns1__BatchJob_:
		soap_serialize___ns1__BatchJob_(soap, (const struct __ns1__BatchJob_ *)ptr);
		break;
	case SOAP_TYPE___ns1__CloseJob_:
		soap_serialize___ns1__CloseJob_(soap, (const struct __ns1__CloseJob_ *)ptr);
		break;
	case SOAP_TYPE___ns1__ExecuteEx_:
		soap_serialize___ns1__ExecuteEx_(soap, (const struct __ns1__ExecuteEx_ *)ptr);
		break;
	case SOAP_TYPE___ns1__Execute_:
		soap_serialize___ns1__Execute_(soap, (const struct __ns1__Execute_ *)ptr);
		break;
	case SOAP_TYPE___ns1__RenewLease_:
		soap_serialize___ns1__RenewLease_(soap, (const struct __ns1__RenewLease_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OpenJobEx_:
		soap_serialize___ns1__OpenJobEx_(soap, (const struct __ns1__OpenJobEx_ *)ptr);
		break;
	case SOAP_TYPE___ns1__OpenJob_:
		soap_serialize___ns1__OpenJob_(soap, (const struct __ns1__OpenJob_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStatus_:
		soap_serialize___ns1__GetStatus_(soap, (const struct __ns1__GetStatus_ *)ptr);
		break;
	case SOAP_TYPE___ns1__GetVersion_:
		soap_serialize___ns1__GetVersion_(soap, (const struct __ns1__GetVersion_ *)ptr);
		break;
	case SOAP_TYPE___ns1__HelloWorld_:
		soap_serialize___ns1__HelloWorld_(soap, (const struct __ns1__HelloWorld_ *)ptr);
		break;
	case SOAP_TYPE___ns1__DiagEx:
		soap_serialize___ns1__DiagEx(soap, (const struct __ns1__DiagEx *)ptr);
		break;
	case SOAP_TYPE___ns1__Diag:
		soap_serialize___ns1__Diag(soap, (const struct __ns1__Diag *)ptr);
		break;
	case SOAP_TYPE___ns1__CloseAllJobs:
		soap_serialize___ns1__CloseAllJobs(soap, (const struct __ns1__CloseAllJobs *)ptr);
		break;
	case SOAP_TYPE___ns1__CloseExpiredJobs:
		soap_serialize___ns1__CloseExpiredJobs(soap, (const struct __ns1__CloseExpiredJobs *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAllJobsEx:
		soap_serialize___ns1__GetAllJobsEx(soap, (const struct __ns1__GetAllJobsEx *)ptr);
		break;
	case SOAP_TYPE___ns1__GetAllJobs:
		soap_serialize___ns1__GetAllJobs(soap, (const struct __ns1__GetAllJobs *)ptr);
		break;
	case SOAP_TYPE___ns1__GetExpiration:
		soap_serialize___ns1__GetExpiration(soap, (const struct __ns1__GetExpiration *)ptr);
		break;
	case SOAP_TYPE___ns1__BatchJobEx:
		soap_serialize___ns1__BatchJobEx(soap, (const struct __ns1__BatchJobEx *)ptr);
		break;
	case SOAP_TYPE___ns1__BatchJob:
		soap_serialize___ns1__BatchJob(soap, (const struct __ns1__BatchJob *)ptr);
		break;
	case SOAP_TYPE___ns1__CloseJob:
		soap_serialize___ns1__CloseJob(soap, (const struct __ns1__CloseJob *)ptr);
		break;
	case SOAP_TYPE___ns1__ExecuteEx:
		soap_serialize___ns1__ExecuteEx(soap, (const struct __ns1__ExecuteEx *)ptr);
		break;
	case SOAP_TYPE___ns1__Execute:
		soap_serialize___ns1__Execute(soap, (const struct __ns1__Execute *)ptr);
		break;
	case SOAP_TYPE___ns1__RenewLease:
		soap_serialize___ns1__RenewLease(soap, (const struct __ns1__RenewLease *)ptr);
		break;
	case SOAP_TYPE___ns1__OpenJobEx:
		soap_serialize___ns1__OpenJobEx(soap, (const struct __ns1__OpenJobEx *)ptr);
		break;
	case SOAP_TYPE___ns1__OpenJob:
		soap_serialize___ns1__OpenJob(soap, (const struct __ns1__OpenJob *)ptr);
		break;
	case SOAP_TYPE___ns1__GetStatus:
		soap_serialize___ns1__GetStatus(soap, (const struct __ns1__GetStatus *)ptr);
		break;
	case SOAP_TYPE___ns1__GetVersion:
		soap_serialize___ns1__GetVersion(soap, (const struct __ns1__GetVersion *)ptr);
		break;
	case SOAP_TYPE___ns1__HelloWorld:
		soap_serialize___ns1__HelloWorld(soap, (const struct __ns1__HelloWorld *)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__DiagEx:
		soap_serialize_PointerTo_ns1__DiagEx(soap, (_ns1__DiagEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Diag:
		soap_serialize_PointerTo_ns1__Diag(soap, (_ns1__Diag *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CloseAllJobs:
		soap_serialize_PointerTo_ns1__CloseAllJobs(soap, (_ns1__CloseAllJobs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CloseExpiredJobs:
		soap_serialize_PointerTo_ns1__CloseExpiredJobs(soap, (_ns1__CloseExpiredJobs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAllJobsEx:
		soap_serialize_PointerTo_ns1__GetAllJobsEx(soap, (_ns1__GetAllJobsEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetAllJobs:
		soap_serialize_PointerTo_ns1__GetAllJobs(soap, (_ns1__GetAllJobs *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetExpiration:
		soap_serialize_PointerTo_ns1__GetExpiration(soap, (_ns1__GetExpiration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BatchJobEx:
		soap_serialize_PointerTo_ns1__BatchJobEx(soap, (_ns1__BatchJobEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__BatchJob:
		soap_serialize_PointerTo_ns1__BatchJob(soap, (_ns1__BatchJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__CloseJob:
		soap_serialize_PointerTo_ns1__CloseJob(soap, (_ns1__CloseJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__ExecuteEx:
		soap_serialize_PointerTo_ns1__ExecuteEx(soap, (_ns1__ExecuteEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__Execute:
		soap_serialize_PointerTo_ns1__Execute(soap, (_ns1__Execute *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__RenewLease:
		soap_serialize_PointerTo_ns1__RenewLease(soap, (_ns1__RenewLease *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OpenJobEx:
		soap_serialize_PointerTo_ns1__OpenJobEx(soap, (_ns1__OpenJobEx *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__OpenJob:
		soap_serialize_PointerTo_ns1__OpenJob(soap, (_ns1__OpenJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetStatus:
		soap_serialize_PointerTo_ns1__GetStatus(soap, (_ns1__GetStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__GetVersion:
		soap_serialize_PointerTo_ns1__GetVersion(soap, (_ns1__GetVersion *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_ns1__HelloWorld:
		soap_serialize_PointerTo_ns1__HelloWorld(soap, (_ns1__HelloWorld *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfJob:
		soap_serialize_PointerTons1__ArrayOfJob(soap, (ns1__ArrayOfJob *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ScriptExecution:
		soap_serialize_PointerTons1__ScriptExecution(soap, (ns1__ScriptExecution *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Status:
		soap_serialize_PointerTons1__Status(soap, (ns1__Status *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__Job:
		soap_serialize_PointerTons1__Job(soap, (ns1__Job *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LuaValue:
		soap_serialize_PointerTons1__LuaValue(soap, (ns1__LuaValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ArrayOfLuaValue:
		soap_serialize_PointerTons1__ArrayOfLuaValue(soap, (ns1__ArrayOfLuaValue *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Status:
		return (void*)soap_instantiate_ns1__Status(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__Job:
		return (void*)soap_instantiate_ns1__Job(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ScriptExecution:
		return (void*)soap_instantiate_ns1__ScriptExecution(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfLuaValue:
		return (void*)soap_instantiate_ns1__ArrayOfLuaValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ArrayOfJob:
		return (void*)soap_instantiate_ns1__ArrayOfJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LuaValue:
		return (void*)soap_instantiate_ns1__LuaValue(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__HelloWorld:
		return (void*)soap_instantiate__ns1__HelloWorld(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__HelloWorldResponse:
		return (void*)soap_instantiate__ns1__HelloWorldResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetVersion:
		return (void*)soap_instantiate__ns1__GetVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetVersionResponse:
		return (void*)soap_instantiate__ns1__GetVersionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStatus:
		return (void*)soap_instantiate__ns1__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetStatusResponse:
		return (void*)soap_instantiate__ns1__GetStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OpenJob:
		return (void*)soap_instantiate__ns1__OpenJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OpenJobEx:
		return (void*)soap_instantiate__ns1__OpenJobEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OpenJobResponse:
		return (void*)soap_instantiate__ns1__OpenJobResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__OpenJobExResponse:
		return (void*)soap_instantiate__ns1__OpenJobExResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RenewLease:
		return (void*)soap_instantiate__ns1__RenewLease(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__RenewLeaseResponse:
		return (void*)soap_instantiate__ns1__RenewLeaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Execute:
		return (void*)soap_instantiate__ns1__Execute(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExecuteResponse:
		return (void*)soap_instantiate__ns1__ExecuteResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExecuteEx:
		return (void*)soap_instantiate__ns1__ExecuteEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__ExecuteExResponse:
		return (void*)soap_instantiate__ns1__ExecuteExResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CloseJob:
		return (void*)soap_instantiate__ns1__CloseJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CloseJobResponse:
		return (void*)soap_instantiate__ns1__CloseJobResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BatchJob:
		return (void*)soap_instantiate__ns1__BatchJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BatchJobResponse:
		return (void*)soap_instantiate__ns1__BatchJobResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BatchJobEx:
		return (void*)soap_instantiate__ns1__BatchJobEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__BatchJobExResponse:
		return (void*)soap_instantiate__ns1__BatchJobExResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetExpiration:
		return (void*)soap_instantiate__ns1__GetExpiration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetExpirationResponse:
		return (void*)soap_instantiate__ns1__GetExpirationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAllJobs:
		return (void*)soap_instantiate__ns1__GetAllJobs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAllJobsResponse:
		return (void*)soap_instantiate__ns1__GetAllJobsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAllJobsEx:
		return (void*)soap_instantiate__ns1__GetAllJobsEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__GetAllJobsExResponse:
		return (void*)soap_instantiate__ns1__GetAllJobsExResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CloseExpiredJobs:
		return (void*)soap_instantiate__ns1__CloseExpiredJobs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CloseExpiredJobsResponse:
		return (void*)soap_instantiate__ns1__CloseExpiredJobsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CloseAllJobs:
		return (void*)soap_instantiate__ns1__CloseAllJobs(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__CloseAllJobsResponse:
		return (void*)soap_instantiate__ns1__CloseAllJobsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__Diag:
		return (void*)soap_instantiate__ns1__Diag(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DiagResponse:
		return (void*)soap_instantiate__ns1__DiagResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DiagEx:
		return (void*)soap_instantiate__ns1__DiagEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE__ns1__DiagExResponse:
		return (void*)soap_instantiate__ns1__DiagExResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__HelloWorld:
		return (void*)soap_instantiate___ns1__HelloWorld(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetVersion:
		return (void*)soap_instantiate___ns1__GetVersion(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetStatus:
		return (void*)soap_instantiate___ns1__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OpenJob:
		return (void*)soap_instantiate___ns1__OpenJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OpenJobEx:
		return (void*)soap_instantiate___ns1__OpenJobEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RenewLease:
		return (void*)soap_instantiate___ns1__RenewLease(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Execute:
		return (void*)soap_instantiate___ns1__Execute(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ExecuteEx:
		return (void*)soap_instantiate___ns1__ExecuteEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CloseJob:
		return (void*)soap_instantiate___ns1__CloseJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BatchJob:
		return (void*)soap_instantiate___ns1__BatchJob(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BatchJobEx:
		return (void*)soap_instantiate___ns1__BatchJobEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetExpiration:
		return (void*)soap_instantiate___ns1__GetExpiration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAllJobs:
		return (void*)soap_instantiate___ns1__GetAllJobs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAllJobsEx:
		return (void*)soap_instantiate___ns1__GetAllJobsEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CloseExpiredJobs:
		return (void*)soap_instantiate___ns1__CloseExpiredJobs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CloseAllJobs:
		return (void*)soap_instantiate___ns1__CloseAllJobs(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Diag:
		return (void*)soap_instantiate___ns1__Diag(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DiagEx:
		return (void*)soap_instantiate___ns1__DiagEx(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__HelloWorld_:
		return (void*)soap_instantiate___ns1__HelloWorld_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetVersion_:
		return (void*)soap_instantiate___ns1__GetVersion_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetStatus_:
		return (void*)soap_instantiate___ns1__GetStatus_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OpenJob_:
		return (void*)soap_instantiate___ns1__OpenJob_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__OpenJobEx_:
		return (void*)soap_instantiate___ns1__OpenJobEx_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__RenewLease_:
		return (void*)soap_instantiate___ns1__RenewLease_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Execute_:
		return (void*)soap_instantiate___ns1__Execute_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__ExecuteEx_:
		return (void*)soap_instantiate___ns1__ExecuteEx_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CloseJob_:
		return (void*)soap_instantiate___ns1__CloseJob_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BatchJob_:
		return (void*)soap_instantiate___ns1__BatchJob_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__BatchJobEx_:
		return (void*)soap_instantiate___ns1__BatchJobEx_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetExpiration_:
		return (void*)soap_instantiate___ns1__GetExpiration_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAllJobs_:
		return (void*)soap_instantiate___ns1__GetAllJobs_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__GetAllJobsEx_:
		return (void*)soap_instantiate___ns1__GetAllJobsEx_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CloseExpiredJobs_:
		return (void*)soap_instantiate___ns1__CloseExpiredJobs_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__CloseAllJobs_:
		return (void*)soap_instantiate___ns1__CloseAllJobs_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__Diag_:
		return (void*)soap_instantiate___ns1__Diag_(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__DiagEx_:
		return (void*)soap_instantiate___ns1__DiagEx_(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Job:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__Job(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__LuaValue:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__LuaValue(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::string*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::string*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__Status:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Status*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Status*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__Job:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__Job*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__Job*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ScriptExecution:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ScriptExecution*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ScriptExecution*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ArrayOfLuaValue:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfLuaValue*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfLuaValue*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__ArrayOfJob:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__ArrayOfJob*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__ArrayOfJob*>(p->ptr));
		break;
	case SOAP_TYPE_ns1__LuaValue:
		if (p->size < 0)
			SOAP_DELETE(static_cast<ns1__LuaValue*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<ns1__LuaValue*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__HelloWorld:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__HelloWorld*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__HelloWorld*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__HelloWorldResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__HelloWorldResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__HelloWorldResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetVersion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetVersion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetVersion*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetVersionResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetVersionResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetVersionResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetStatus:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetStatus*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetStatus*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetStatusResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetStatusResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetStatusResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__OpenJob:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__OpenJob*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__OpenJob*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__OpenJobEx:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__OpenJobEx*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__OpenJobEx*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__OpenJobResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__OpenJobResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__OpenJobResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__OpenJobExResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__OpenJobExResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__OpenJobExResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RenewLease:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RenewLease*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RenewLease*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__RenewLeaseResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__RenewLeaseResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__RenewLeaseResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__Execute:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Execute*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Execute*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ExecuteResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ExecuteResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ExecuteResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ExecuteEx:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ExecuteEx*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ExecuteEx*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__ExecuteExResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__ExecuteExResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__ExecuteExResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CloseJob:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CloseJob*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CloseJob*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CloseJobResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CloseJobResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CloseJobResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__BatchJob:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__BatchJob*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__BatchJob*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__BatchJobResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__BatchJobResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__BatchJobResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__BatchJobEx:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__BatchJobEx*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__BatchJobEx*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__BatchJobExResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__BatchJobExResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__BatchJobExResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetExpiration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetExpiration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetExpiration*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetExpirationResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetExpirationResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetExpirationResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetAllJobs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetAllJobs*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetAllJobs*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetAllJobsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetAllJobsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetAllJobsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetAllJobsEx:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetAllJobsEx*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetAllJobsEx*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__GetAllJobsExResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__GetAllJobsExResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__GetAllJobsExResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CloseExpiredJobs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CloseExpiredJobs*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CloseExpiredJobs*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CloseExpiredJobsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CloseExpiredJobsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CloseExpiredJobsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CloseAllJobs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CloseAllJobs*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CloseAllJobs*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__CloseAllJobsResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__CloseAllJobsResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__CloseAllJobsResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__Diag:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__Diag*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__Diag*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DiagResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DiagResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DiagResponse*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DiagEx:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DiagEx*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DiagEx*>(p->ptr));
		break;
	case SOAP_TYPE__ns1__DiagExResponse:
		if (p->size < 0)
			SOAP_DELETE(static_cast<_ns1__DiagExResponse*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<_ns1__DiagExResponse*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__HelloWorld:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__HelloWorld*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__HelloWorld*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetVersion:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetVersion*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetVersion*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetStatus:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetStatus*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetStatus*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__OpenJob:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__OpenJob*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__OpenJob*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__OpenJobEx:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__OpenJobEx*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__OpenJobEx*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__RenewLease:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__RenewLease*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__RenewLease*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__Execute:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Execute*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Execute*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ExecuteEx:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExecuteEx*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExecuteEx*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CloseJob:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CloseJob*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CloseJob*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__BatchJob:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__BatchJob*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__BatchJob*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__BatchJobEx:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__BatchJobEx*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__BatchJobEx*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetExpiration:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetExpiration*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetExpiration*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetAllJobs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetAllJobs*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetAllJobs*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetAllJobsEx:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetAllJobsEx*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetAllJobsEx*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CloseExpiredJobs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CloseExpiredJobs*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CloseExpiredJobs*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CloseAllJobs:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CloseAllJobs*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CloseAllJobs*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__Diag:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Diag*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Diag*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__DiagEx:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DiagEx*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DiagEx*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__HelloWorld_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__HelloWorld_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__HelloWorld_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetVersion_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetVersion_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetVersion_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetStatus_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetStatus_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetStatus_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__OpenJob_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__OpenJob_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__OpenJob_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__OpenJobEx_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__OpenJobEx_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__OpenJobEx_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__RenewLease_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__RenewLease_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__RenewLease_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__Execute_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Execute_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Execute_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__ExecuteEx_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__ExecuteEx_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__ExecuteEx_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CloseJob_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CloseJob_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CloseJob_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__BatchJob_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__BatchJob_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__BatchJob_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__BatchJobEx_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__BatchJobEx_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__BatchJobEx_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetExpiration_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetExpiration_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetExpiration_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetAllJobs_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetAllJobs_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetAllJobs_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__GetAllJobsEx_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__GetAllJobsEx_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__GetAllJobsEx_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CloseExpiredJobs_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CloseExpiredJobs_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CloseExpiredJobs_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__CloseAllJobs_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__CloseAllJobs_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__CloseAllJobs_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__Diag_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__Diag_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__Diag_*>(p->ptr));
		break;
	case SOAP_TYPE___ns1__DiagEx_:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct __ns1__DiagEx_*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct __ns1__DiagEx_*>(p->ptr));
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Header*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Code*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Detail*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Reason*>(p->ptr));
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<struct SOAP_ENV__Fault*>(p->ptr));
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Job:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__Job *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__Job *> *>(p->ptr));
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__LuaValue:
		if (p->size < 0)
			SOAP_DELETE(static_cast<std::vector<ns1__LuaValue *> *>(p->ptr));
		else
			SOAP_DELETE_ARRAY(static_cast<std::vector<ns1__LuaValue *> *>(p->ptr));
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__Job:
		if (t == SOAP_TYPE_ns1__Job || soap_fbase(t, SOAP_TYPE_ns1__Job))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__Job *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__Job *> *)p)[index] = *(ns1__Job **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__LuaValue:
		if (t == SOAP_TYPE_ns1__LuaValue || soap_fbase(t, SOAP_TYPE_ns1__LuaValue))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<ns1__LuaValue *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<ns1__LuaValue *> *)p)[index] = *(ns1__LuaValue **)q;
		}
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_ns1__Status:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Status type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Status*)p = *(ns1__Status*)q;
		break;
	case SOAP_TYPE_ns1__Job:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__Job type=%d location=%p object=%p\n", t, p, q));
		*(ns1__Job*)p = *(ns1__Job*)q;
		break;
	case SOAP_TYPE_ns1__ScriptExecution:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ScriptExecution type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ScriptExecution*)p = *(ns1__ScriptExecution*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfLuaValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfLuaValue type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfLuaValue*)p = *(ns1__ArrayOfLuaValue*)q;
		break;
	case SOAP_TYPE_ns1__ArrayOfJob:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__ArrayOfJob type=%d location=%p object=%p\n", t, p, q));
		*(ns1__ArrayOfJob*)p = *(ns1__ArrayOfJob*)q;
		break;
	case SOAP_TYPE_ns1__LuaValue:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy ns1__LuaValue type=%d location=%p object=%p\n", t, p, q));
		*(ns1__LuaValue*)p = *(ns1__LuaValue*)q;
		break;
	case SOAP_TYPE__ns1__HelloWorld:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__HelloWorld type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__HelloWorld*)p = *(_ns1__HelloWorld*)q;
		break;
	case SOAP_TYPE__ns1__HelloWorldResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__HelloWorldResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__HelloWorldResponse*)p = *(_ns1__HelloWorldResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetVersion type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetVersion*)p = *(_ns1__GetVersion*)q;
		break;
	case SOAP_TYPE__ns1__GetVersionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetVersionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetVersionResponse*)p = *(_ns1__GetVersionResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetStatus type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetStatus*)p = *(_ns1__GetStatus*)q;
		break;
	case SOAP_TYPE__ns1__GetStatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetStatusResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetStatusResponse*)p = *(_ns1__GetStatusResponse*)q;
		break;
	case SOAP_TYPE__ns1__OpenJob:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OpenJob type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OpenJob*)p = *(_ns1__OpenJob*)q;
		break;
	case SOAP_TYPE__ns1__OpenJobEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OpenJobEx type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OpenJobEx*)p = *(_ns1__OpenJobEx*)q;
		break;
	case SOAP_TYPE__ns1__OpenJobResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OpenJobResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OpenJobResponse*)p = *(_ns1__OpenJobResponse*)q;
		break;
	case SOAP_TYPE__ns1__OpenJobExResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__OpenJobExResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__OpenJobExResponse*)p = *(_ns1__OpenJobExResponse*)q;
		break;
	case SOAP_TYPE__ns1__RenewLease:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RenewLease type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RenewLease*)p = *(_ns1__RenewLease*)q;
		break;
	case SOAP_TYPE__ns1__RenewLeaseResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__RenewLeaseResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__RenewLeaseResponse*)p = *(_ns1__RenewLeaseResponse*)q;
		break;
	case SOAP_TYPE__ns1__Execute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Execute type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Execute*)p = *(_ns1__Execute*)q;
		break;
	case SOAP_TYPE__ns1__ExecuteResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExecuteResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExecuteResponse*)p = *(_ns1__ExecuteResponse*)q;
		break;
	case SOAP_TYPE__ns1__ExecuteEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExecuteEx type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExecuteEx*)p = *(_ns1__ExecuteEx*)q;
		break;
	case SOAP_TYPE__ns1__ExecuteExResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__ExecuteExResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__ExecuteExResponse*)p = *(_ns1__ExecuteExResponse*)q;
		break;
	case SOAP_TYPE__ns1__CloseJob:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CloseJob type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CloseJob*)p = *(_ns1__CloseJob*)q;
		break;
	case SOAP_TYPE__ns1__CloseJobResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CloseJobResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CloseJobResponse*)p = *(_ns1__CloseJobResponse*)q;
		break;
	case SOAP_TYPE__ns1__BatchJob:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BatchJob type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BatchJob*)p = *(_ns1__BatchJob*)q;
		break;
	case SOAP_TYPE__ns1__BatchJobResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BatchJobResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BatchJobResponse*)p = *(_ns1__BatchJobResponse*)q;
		break;
	case SOAP_TYPE__ns1__BatchJobEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BatchJobEx type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BatchJobEx*)p = *(_ns1__BatchJobEx*)q;
		break;
	case SOAP_TYPE__ns1__BatchJobExResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__BatchJobExResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__BatchJobExResponse*)p = *(_ns1__BatchJobExResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetExpiration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetExpiration type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetExpiration*)p = *(_ns1__GetExpiration*)q;
		break;
	case SOAP_TYPE__ns1__GetExpirationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetExpirationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetExpirationResponse*)p = *(_ns1__GetExpirationResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetAllJobs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAllJobs type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAllJobs*)p = *(_ns1__GetAllJobs*)q;
		break;
	case SOAP_TYPE__ns1__GetAllJobsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAllJobsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAllJobsResponse*)p = *(_ns1__GetAllJobsResponse*)q;
		break;
	case SOAP_TYPE__ns1__GetAllJobsEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAllJobsEx type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAllJobsEx*)p = *(_ns1__GetAllJobsEx*)q;
		break;
	case SOAP_TYPE__ns1__GetAllJobsExResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__GetAllJobsExResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__GetAllJobsExResponse*)p = *(_ns1__GetAllJobsExResponse*)q;
		break;
	case SOAP_TYPE__ns1__CloseExpiredJobs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CloseExpiredJobs type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CloseExpiredJobs*)p = *(_ns1__CloseExpiredJobs*)q;
		break;
	case SOAP_TYPE__ns1__CloseExpiredJobsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CloseExpiredJobsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CloseExpiredJobsResponse*)p = *(_ns1__CloseExpiredJobsResponse*)q;
		break;
	case SOAP_TYPE__ns1__CloseAllJobs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CloseAllJobs type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CloseAllJobs*)p = *(_ns1__CloseAllJobs*)q;
		break;
	case SOAP_TYPE__ns1__CloseAllJobsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__CloseAllJobsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__CloseAllJobsResponse*)p = *(_ns1__CloseAllJobsResponse*)q;
		break;
	case SOAP_TYPE__ns1__Diag:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__Diag type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__Diag*)p = *(_ns1__Diag*)q;
		break;
	case SOAP_TYPE__ns1__DiagResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DiagResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DiagResponse*)p = *(_ns1__DiagResponse*)q;
		break;
	case SOAP_TYPE__ns1__DiagEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DiagEx type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DiagEx*)p = *(_ns1__DiagEx*)q;
		break;
	case SOAP_TYPE__ns1__DiagExResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _ns1__DiagExResponse type=%d location=%p object=%p\n", t, p, q));
		*(_ns1__DiagExResponse*)p = *(_ns1__DiagExResponse*)q;
		break;
	case SOAP_TYPE___ns1__HelloWorld:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__HelloWorld type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__HelloWorld*)p = *(struct __ns1__HelloWorld*)q;
		break;
	case SOAP_TYPE___ns1__GetVersion:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetVersion type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetVersion*)p = *(struct __ns1__GetVersion*)q;
		break;
	case SOAP_TYPE___ns1__GetStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetStatus*)p = *(struct __ns1__GetStatus*)q;
		break;
	case SOAP_TYPE___ns1__OpenJob:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OpenJob type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OpenJob*)p = *(struct __ns1__OpenJob*)q;
		break;
	case SOAP_TYPE___ns1__OpenJobEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OpenJobEx type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OpenJobEx*)p = *(struct __ns1__OpenJobEx*)q;
		break;
	case SOAP_TYPE___ns1__RenewLease:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__RenewLease type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__RenewLease*)p = *(struct __ns1__RenewLease*)q;
		break;
	case SOAP_TYPE___ns1__Execute:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Execute type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Execute*)p = *(struct __ns1__Execute*)q;
		break;
	case SOAP_TYPE___ns1__ExecuteEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExecuteEx type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExecuteEx*)p = *(struct __ns1__ExecuteEx*)q;
		break;
	case SOAP_TYPE___ns1__CloseJob:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CloseJob type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CloseJob*)p = *(struct __ns1__CloseJob*)q;
		break;
	case SOAP_TYPE___ns1__BatchJob:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BatchJob type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BatchJob*)p = *(struct __ns1__BatchJob*)q;
		break;
	case SOAP_TYPE___ns1__BatchJobEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BatchJobEx type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BatchJobEx*)p = *(struct __ns1__BatchJobEx*)q;
		break;
	case SOAP_TYPE___ns1__GetExpiration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetExpiration type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetExpiration*)p = *(struct __ns1__GetExpiration*)q;
		break;
	case SOAP_TYPE___ns1__GetAllJobs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetAllJobs type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetAllJobs*)p = *(struct __ns1__GetAllJobs*)q;
		break;
	case SOAP_TYPE___ns1__GetAllJobsEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetAllJobsEx type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetAllJobsEx*)p = *(struct __ns1__GetAllJobsEx*)q;
		break;
	case SOAP_TYPE___ns1__CloseExpiredJobs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CloseExpiredJobs type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CloseExpiredJobs*)p = *(struct __ns1__CloseExpiredJobs*)q;
		break;
	case SOAP_TYPE___ns1__CloseAllJobs:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CloseAllJobs type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CloseAllJobs*)p = *(struct __ns1__CloseAllJobs*)q;
		break;
	case SOAP_TYPE___ns1__Diag:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Diag type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Diag*)p = *(struct __ns1__Diag*)q;
		break;
	case SOAP_TYPE___ns1__DiagEx:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DiagEx type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DiagEx*)p = *(struct __ns1__DiagEx*)q;
		break;
	case SOAP_TYPE___ns1__HelloWorld_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__HelloWorld_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__HelloWorld_*)p = *(struct __ns1__HelloWorld_*)q;
		break;
	case SOAP_TYPE___ns1__GetVersion_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetVersion_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetVersion_*)p = *(struct __ns1__GetVersion_*)q;
		break;
	case SOAP_TYPE___ns1__GetStatus_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetStatus_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetStatus_*)p = *(struct __ns1__GetStatus_*)q;
		break;
	case SOAP_TYPE___ns1__OpenJob_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OpenJob_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OpenJob_*)p = *(struct __ns1__OpenJob_*)q;
		break;
	case SOAP_TYPE___ns1__OpenJobEx_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__OpenJobEx_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__OpenJobEx_*)p = *(struct __ns1__OpenJobEx_*)q;
		break;
	case SOAP_TYPE___ns1__RenewLease_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__RenewLease_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__RenewLease_*)p = *(struct __ns1__RenewLease_*)q;
		break;
	case SOAP_TYPE___ns1__Execute_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Execute_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Execute_*)p = *(struct __ns1__Execute_*)q;
		break;
	case SOAP_TYPE___ns1__ExecuteEx_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__ExecuteEx_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__ExecuteEx_*)p = *(struct __ns1__ExecuteEx_*)q;
		break;
	case SOAP_TYPE___ns1__CloseJob_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CloseJob_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CloseJob_*)p = *(struct __ns1__CloseJob_*)q;
		break;
	case SOAP_TYPE___ns1__BatchJob_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BatchJob_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BatchJob_*)p = *(struct __ns1__BatchJob_*)q;
		break;
	case SOAP_TYPE___ns1__BatchJobEx_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__BatchJobEx_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__BatchJobEx_*)p = *(struct __ns1__BatchJobEx_*)q;
		break;
	case SOAP_TYPE___ns1__GetExpiration_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetExpiration_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetExpiration_*)p = *(struct __ns1__GetExpiration_*)q;
		break;
	case SOAP_TYPE___ns1__GetAllJobs_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetAllJobs_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetAllJobs_*)p = *(struct __ns1__GetAllJobs_*)q;
		break;
	case SOAP_TYPE___ns1__GetAllJobsEx_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__GetAllJobsEx_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__GetAllJobsEx_*)p = *(struct __ns1__GetAllJobsEx_*)q;
		break;
	case SOAP_TYPE___ns1__CloseExpiredJobs_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CloseExpiredJobs_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CloseExpiredJobs_*)p = *(struct __ns1__CloseExpiredJobs_*)q;
		break;
	case SOAP_TYPE___ns1__CloseAllJobs_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__CloseAllJobs_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__CloseAllJobs_*)p = *(struct __ns1__CloseAllJobs_*)q;
		break;
	case SOAP_TYPE___ns1__Diag_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__Diag_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__Diag_*)p = *(struct __ns1__Diag_*)q;
		break;
	case SOAP_TYPE___ns1__DiagEx_:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __ns1__DiagEx_ type=%d location=%p object=%p\n", t, p, q));
		*(struct __ns1__DiagEx_*)p = *(struct __ns1__DiagEx_*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type = %d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_ns1__LuaType[] =
{	{ (LONG64)ns1__LuaType__LUA_USCORETNIL, "LUA_TNIL" },
	{ (LONG64)ns1__LuaType__LUA_USCORETBOOLEAN, "LUA_TBOOLEAN" },
	{ (LONG64)ns1__LuaType__LUA_USCORETNUMBER, "LUA_TNUMBER" },
	{ (LONG64)ns1__LuaType__LUA_USCORETSTRING, "LUA_TSTRING" },
	{ (LONG64)ns1__LuaType__LUA_USCORETTABLE, "LUA_TTABLE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__LuaType2s(struct soap *soap, enum ns1__LuaType n)
{	const char *s = soap_code_str(soap_codes_ns1__LuaType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LuaType(struct soap *soap, const char *tag, int id, const enum ns1__LuaType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LuaType), type) || soap_send(soap, soap_ns1__LuaType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__LuaType(struct soap *soap, const char *s, enum ns1__LuaType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__LuaType, s);
	if (map)
		*a = (enum ns1__LuaType)map->code;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 4)
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__LuaType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__LuaType * SOAP_FMAC4 soap_in_ns1__LuaType(struct soap *soap, const char *tag, enum ns1__LuaType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__LuaType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LuaType, sizeof(enum ns1__LuaType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (soap_s2ns1__LuaType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__LuaType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LuaType, SOAP_TYPE_ns1__LuaType, sizeof(enum ns1__LuaType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum ns1__LuaType * SOAP_FMAC4 soap_new_ns1__LuaType(struct soap *soap, int n)
{
	enum ns1__LuaType *a = static_cast<enum ns1__LuaType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum ns1__LuaType)));
	for (enum ns1__LuaType *p = a; p && n--; ++p)
		soap_default_ns1__LuaType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__LuaType(struct soap *soap, const enum ns1__LuaType *a, const char *tag, const char *type)
{
	if (soap_out_ns1__LuaType(soap, tag ? tag : "ns1:LuaType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__LuaType * SOAP_FMAC4 soap_get_ns1__LuaType(struct soap *soap, enum ns1__LuaType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LuaType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	if (n < 0)
	{	p = SOAP_NEW(std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__string, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DiagExResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__DiagExResponse::DiagExResult = NULL;
	/* transient soap skipped */
}

void _ns1__DiagExResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfLuaValue(soap, &this->_ns1__DiagExResponse::DiagExResult);
#endif
}

int _ns1__DiagExResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DiagExResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DiagExResponse(struct soap *soap, const char *tag, int id, const _ns1__DiagExResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DiagExResponse), type))
		return soap->error;
	if (a->DiagExResult)
		soap_element_result(soap, "ns1:DiagExResult");
	if (!a->_ns1__DiagExResponse::DiagExResult)
	{	if (soap_element_empty(soap, "ns1:DiagExResult"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ArrayOfLuaValue(soap, "ns1:DiagExResult", -1, &a->_ns1__DiagExResponse::DiagExResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DiagExResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DiagExResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DiagExResponse * SOAP_FMAC4 soap_in__ns1__DiagExResponse(struct soap *soap, const char *tag, _ns1__DiagExResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DiagExResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DiagExResponse, sizeof(_ns1__DiagExResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DiagExResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DiagExResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_DiagExResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DiagExResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfLuaValue(soap, "ns1:DiagExResult", &a->_ns1__DiagExResponse::DiagExResult, "ns1:ArrayOfLuaValue"))
				{	soap_flag_DiagExResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:DiagExResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__DiagExResponse::DiagExResult))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DiagExResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DiagExResponse, SOAP_TYPE__ns1__DiagExResponse, sizeof(_ns1__DiagExResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DiagExResponse * SOAP_FMAC2 soap_instantiate__ns1__DiagExResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DiagExResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DiagExResponse *p;
	size_t k = sizeof(_ns1__DiagExResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DiagExResponse);
		if (p)
			((_ns1__DiagExResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DiagExResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DiagExResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DiagExResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DiagExResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DiagExResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DiagExResponse(soap, tag ? tag : "ns1:DiagExResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DiagExResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DiagExResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DiagExResponse * SOAP_FMAC4 soap_get__ns1__DiagExResponse(struct soap *soap, _ns1__DiagExResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DiagExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DiagEx::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__DiagEx::type);
	this->_ns1__DiagEx::jobID = NULL;
	/* transient soap skipped */
}

void _ns1__DiagEx::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__DiagEx::jobID);
#endif
}

int _ns1__DiagEx::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DiagEx(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DiagEx(struct soap *soap, const char *tag, int id, const _ns1__DiagEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DiagEx), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:type", -1, &a->_ns1__DiagEx::type, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:jobID", -1, &a->_ns1__DiagEx::jobID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DiagEx::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DiagEx(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DiagEx * SOAP_FMAC4 soap_in__ns1__DiagEx(struct soap *soap, const char *tag, _ns1__DiagEx *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DiagEx *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DiagEx, sizeof(_ns1__DiagEx), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DiagEx)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DiagEx *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_type1 = 1;
	size_t soap_flag_jobID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:type", &a->_ns1__DiagEx::type, "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:jobID", &a->_ns1__DiagEx::jobID, "xsd:string"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DiagEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DiagEx, SOAP_TYPE__ns1__DiagEx, sizeof(_ns1__DiagEx), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DiagEx * SOAP_FMAC2 soap_instantiate__ns1__DiagEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DiagEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DiagEx *p;
	size_t k = sizeof(_ns1__DiagEx);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DiagEx);
		if (p)
			((_ns1__DiagEx*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DiagEx, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DiagEx*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DiagEx location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DiagEx, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DiagEx::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DiagEx(soap, tag ? tag : "ns1:DiagEx", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DiagEx::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DiagEx(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DiagEx * SOAP_FMAC4 soap_get__ns1__DiagEx(struct soap *soap, _ns1__DiagEx *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DiagEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__DiagResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__LuaValue(soap, &this->_ns1__DiagResponse::DiagResult);
	/* transient soap skipped */
}

void _ns1__DiagResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__LuaValue(soap, &this->_ns1__DiagResponse::DiagResult);
#endif
}

int _ns1__DiagResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__DiagResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__DiagResponse(struct soap *soap, const char *tag, int id, const _ns1__DiagResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__DiagResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:DiagResult");
	if (soap_out_std__vectorTemplateOfPointerTons1__LuaValue(soap, "ns1:DiagResult", -1, &a->_ns1__DiagResponse::DiagResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__DiagResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__DiagResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__DiagResponse * SOAP_FMAC4 soap_in__ns1__DiagResponse(struct soap *soap, const char *tag, _ns1__DiagResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__DiagResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__DiagResponse, sizeof(_ns1__DiagResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__DiagResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__DiagResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__LuaValue(soap, "ns1:DiagResult", &a->_ns1__DiagResponse::DiagResult, "ns1:LuaValue"))
					continue;
			soap_check_result(soap, "ns1:DiagResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__DiagResponse::DiagResult.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__DiagResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__DiagResponse, SOAP_TYPE__ns1__DiagResponse, sizeof(_ns1__DiagResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__DiagResponse * SOAP_FMAC2 soap_instantiate__ns1__DiagResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__DiagResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__DiagResponse *p;
	size_t k = sizeof(_ns1__DiagResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__DiagResponse);
		if (p)
			((_ns1__DiagResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__DiagResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__DiagResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__DiagResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__DiagResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__DiagResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__DiagResponse(soap, tag ? tag : "ns1:DiagResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__DiagResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__DiagResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__DiagResponse * SOAP_FMAC4 soap_get__ns1__DiagResponse(struct soap *soap, _ns1__DiagResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__DiagResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Diag::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__Diag::type);
	this->_ns1__Diag::jobID = NULL;
	/* transient soap skipped */
}

void _ns1__Diag::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__Diag::jobID);
#endif
}

int _ns1__Diag::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Diag(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Diag(struct soap *soap, const char *tag, int id, const _ns1__Diag *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Diag), type))
		return soap->error;
	if (soap_out_int(soap, "ns1:type", -1, &a->_ns1__Diag::type, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:jobID", -1, &a->_ns1__Diag::jobID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Diag::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Diag(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Diag * SOAP_FMAC4 soap_in__ns1__Diag(struct soap *soap, const char *tag, _ns1__Diag *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Diag *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Diag, sizeof(_ns1__Diag), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Diag)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Diag *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_type1 = 1;
	size_t soap_flag_jobID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:type", &a->_ns1__Diag::type, "xsd:int"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:jobID", &a->_ns1__Diag::jobID, "xsd:string"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__Diag *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Diag, SOAP_TYPE__ns1__Diag, sizeof(_ns1__Diag), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Diag * SOAP_FMAC2 soap_instantiate__ns1__Diag(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Diag(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Diag *p;
	size_t k = sizeof(_ns1__Diag);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Diag);
		if (p)
			((_ns1__Diag*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Diag, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Diag*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Diag location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__Diag, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Diag::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Diag(soap, tag ? tag : "ns1:Diag", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Diag::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Diag(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Diag * SOAP_FMAC4 soap_get__ns1__Diag(struct soap *soap, _ns1__Diag *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Diag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CloseAllJobsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__CloseAllJobsResponse::CloseAllJobsResult);
	/* transient soap skipped */
}

void _ns1__CloseAllJobsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CloseAllJobsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CloseAllJobsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CloseAllJobsResponse(struct soap *soap, const char *tag, int id, const _ns1__CloseAllJobsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CloseAllJobsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:CloseAllJobsResult");
	if (soap_out_int(soap, "ns1:CloseAllJobsResult", -1, &a->_ns1__CloseAllJobsResponse::CloseAllJobsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CloseAllJobsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CloseAllJobsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CloseAllJobsResponse * SOAP_FMAC4 soap_in__ns1__CloseAllJobsResponse(struct soap *soap, const char *tag, _ns1__CloseAllJobsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CloseAllJobsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CloseAllJobsResponse, sizeof(_ns1__CloseAllJobsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CloseAllJobsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CloseAllJobsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CloseAllJobsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CloseAllJobsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:CloseAllJobsResult", &a->_ns1__CloseAllJobsResponse::CloseAllJobsResult, "xsd:int"))
				{	soap_flag_CloseAllJobsResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:CloseAllJobsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CloseAllJobsResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CloseAllJobsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CloseAllJobsResponse, SOAP_TYPE__ns1__CloseAllJobsResponse, sizeof(_ns1__CloseAllJobsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CloseAllJobsResponse * SOAP_FMAC2 soap_instantiate__ns1__CloseAllJobsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CloseAllJobsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CloseAllJobsResponse *p;
	size_t k = sizeof(_ns1__CloseAllJobsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CloseAllJobsResponse);
		if (p)
			((_ns1__CloseAllJobsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CloseAllJobsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CloseAllJobsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CloseAllJobsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CloseAllJobsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CloseAllJobsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CloseAllJobsResponse(soap, tag ? tag : "ns1:CloseAllJobsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CloseAllJobsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CloseAllJobsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CloseAllJobsResponse * SOAP_FMAC4 soap_get__ns1__CloseAllJobsResponse(struct soap *soap, _ns1__CloseAllJobsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CloseAllJobsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CloseAllJobs::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__CloseAllJobs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CloseAllJobs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CloseAllJobs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CloseAllJobs(struct soap *soap, const char *tag, int id, const _ns1__CloseAllJobs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CloseAllJobs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CloseAllJobs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CloseAllJobs(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CloseAllJobs * SOAP_FMAC4 soap_in__ns1__CloseAllJobs(struct soap *soap, const char *tag, _ns1__CloseAllJobs *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CloseAllJobs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CloseAllJobs, sizeof(_ns1__CloseAllJobs), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CloseAllJobs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CloseAllJobs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CloseAllJobs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CloseAllJobs, SOAP_TYPE__ns1__CloseAllJobs, sizeof(_ns1__CloseAllJobs), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CloseAllJobs * SOAP_FMAC2 soap_instantiate__ns1__CloseAllJobs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CloseAllJobs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CloseAllJobs *p;
	size_t k = sizeof(_ns1__CloseAllJobs);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CloseAllJobs);
		if (p)
			((_ns1__CloseAllJobs*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CloseAllJobs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CloseAllJobs*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CloseAllJobs location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CloseAllJobs, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CloseAllJobs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CloseAllJobs(soap, tag ? tag : "ns1:CloseAllJobs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CloseAllJobs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CloseAllJobs(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CloseAllJobs * SOAP_FMAC4 soap_get__ns1__CloseAllJobs(struct soap *soap, _ns1__CloseAllJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CloseAllJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CloseExpiredJobsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_ns1__CloseExpiredJobsResponse::CloseExpiredJobsResult);
	/* transient soap skipped */
}

void _ns1__CloseExpiredJobsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CloseExpiredJobsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CloseExpiredJobsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CloseExpiredJobsResponse(struct soap *soap, const char *tag, int id, const _ns1__CloseExpiredJobsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CloseExpiredJobsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:CloseExpiredJobsResult");
	if (soap_out_int(soap, "ns1:CloseExpiredJobsResult", -1, &a->_ns1__CloseExpiredJobsResponse::CloseExpiredJobsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CloseExpiredJobsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CloseExpiredJobsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CloseExpiredJobsResponse * SOAP_FMAC4 soap_in__ns1__CloseExpiredJobsResponse(struct soap *soap, const char *tag, _ns1__CloseExpiredJobsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CloseExpiredJobsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CloseExpiredJobsResponse, sizeof(_ns1__CloseExpiredJobsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CloseExpiredJobsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CloseExpiredJobsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_CloseExpiredJobsResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CloseExpiredJobsResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:CloseExpiredJobsResult", &a->_ns1__CloseExpiredJobsResponse::CloseExpiredJobsResult, "xsd:int"))
				{	soap_flag_CloseExpiredJobsResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:CloseExpiredJobsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CloseExpiredJobsResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CloseExpiredJobsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CloseExpiredJobsResponse, SOAP_TYPE__ns1__CloseExpiredJobsResponse, sizeof(_ns1__CloseExpiredJobsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CloseExpiredJobsResponse * SOAP_FMAC2 soap_instantiate__ns1__CloseExpiredJobsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CloseExpiredJobsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CloseExpiredJobsResponse *p;
	size_t k = sizeof(_ns1__CloseExpiredJobsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CloseExpiredJobsResponse);
		if (p)
			((_ns1__CloseExpiredJobsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CloseExpiredJobsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CloseExpiredJobsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CloseExpiredJobsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CloseExpiredJobsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CloseExpiredJobsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CloseExpiredJobsResponse(soap, tag ? tag : "ns1:CloseExpiredJobsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CloseExpiredJobsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CloseExpiredJobsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CloseExpiredJobsResponse * SOAP_FMAC4 soap_get__ns1__CloseExpiredJobsResponse(struct soap *soap, _ns1__CloseExpiredJobsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CloseExpiredJobsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CloseExpiredJobs::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__CloseExpiredJobs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CloseExpiredJobs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CloseExpiredJobs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CloseExpiredJobs(struct soap *soap, const char *tag, int id, const _ns1__CloseExpiredJobs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CloseExpiredJobs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CloseExpiredJobs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CloseExpiredJobs(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CloseExpiredJobs * SOAP_FMAC4 soap_in__ns1__CloseExpiredJobs(struct soap *soap, const char *tag, _ns1__CloseExpiredJobs *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CloseExpiredJobs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CloseExpiredJobs, sizeof(_ns1__CloseExpiredJobs), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CloseExpiredJobs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CloseExpiredJobs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CloseExpiredJobs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CloseExpiredJobs, SOAP_TYPE__ns1__CloseExpiredJobs, sizeof(_ns1__CloseExpiredJobs), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CloseExpiredJobs * SOAP_FMAC2 soap_instantiate__ns1__CloseExpiredJobs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CloseExpiredJobs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CloseExpiredJobs *p;
	size_t k = sizeof(_ns1__CloseExpiredJobs);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CloseExpiredJobs);
		if (p)
			((_ns1__CloseExpiredJobs*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CloseExpiredJobs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CloseExpiredJobs*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CloseExpiredJobs location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CloseExpiredJobs, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CloseExpiredJobs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CloseExpiredJobs(soap, tag ? tag : "ns1:CloseExpiredJobs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CloseExpiredJobs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CloseExpiredJobs(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CloseExpiredJobs * SOAP_FMAC4 soap_get__ns1__CloseExpiredJobs(struct soap *soap, _ns1__CloseExpiredJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CloseExpiredJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAllJobsExResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetAllJobsExResponse::GetAllJobsExResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetAllJobsExResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfJob(soap, &this->_ns1__GetAllJobsExResponse::GetAllJobsExResult);
#endif
}

int _ns1__GetAllJobsExResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAllJobsExResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAllJobsExResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAllJobsExResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAllJobsExResponse), type))
		return soap->error;
	if (a->GetAllJobsExResult)
		soap_element_result(soap, "ns1:GetAllJobsExResult");
	if (!a->_ns1__GetAllJobsExResponse::GetAllJobsExResult)
	{	if (soap_element_empty(soap, "ns1:GetAllJobsExResult"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ArrayOfJob(soap, "ns1:GetAllJobsExResult", -1, &a->_ns1__GetAllJobsExResponse::GetAllJobsExResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAllJobsExResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAllJobsExResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAllJobsExResponse * SOAP_FMAC4 soap_in__ns1__GetAllJobsExResponse(struct soap *soap, const char *tag, _ns1__GetAllJobsExResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAllJobsExResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAllJobsExResponse, sizeof(_ns1__GetAllJobsExResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAllJobsExResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAllJobsExResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetAllJobsExResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetAllJobsExResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfJob(soap, "ns1:GetAllJobsExResult", &a->_ns1__GetAllJobsExResponse::GetAllJobsExResult, "ns1:ArrayOfJob"))
				{	soap_flag_GetAllJobsExResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:GetAllJobsExResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__GetAllJobsExResponse::GetAllJobsExResult))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetAllJobsExResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAllJobsExResponse, SOAP_TYPE__ns1__GetAllJobsExResponse, sizeof(_ns1__GetAllJobsExResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAllJobsExResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAllJobsExResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAllJobsExResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAllJobsExResponse *p;
	size_t k = sizeof(_ns1__GetAllJobsExResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetAllJobsExResponse);
		if (p)
			((_ns1__GetAllJobsExResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetAllJobsExResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetAllJobsExResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAllJobsExResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetAllJobsExResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetAllJobsExResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAllJobsExResponse(soap, tag ? tag : "ns1:GetAllJobsExResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAllJobsExResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAllJobsExResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAllJobsExResponse * SOAP_FMAC4 soap_get__ns1__GetAllJobsExResponse(struct soap *soap, _ns1__GetAllJobsExResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAllJobsExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAllJobsEx::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetAllJobsEx::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetAllJobsEx::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAllJobsEx(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAllJobsEx(struct soap *soap, const char *tag, int id, const _ns1__GetAllJobsEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAllJobsEx), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAllJobsEx::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAllJobsEx(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAllJobsEx * SOAP_FMAC4 soap_in__ns1__GetAllJobsEx(struct soap *soap, const char *tag, _ns1__GetAllJobsEx *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAllJobsEx *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAllJobsEx, sizeof(_ns1__GetAllJobsEx), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAllJobsEx)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAllJobsEx *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAllJobsEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAllJobsEx, SOAP_TYPE__ns1__GetAllJobsEx, sizeof(_ns1__GetAllJobsEx), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAllJobsEx * SOAP_FMAC2 soap_instantiate__ns1__GetAllJobsEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAllJobsEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAllJobsEx *p;
	size_t k = sizeof(_ns1__GetAllJobsEx);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetAllJobsEx);
		if (p)
			((_ns1__GetAllJobsEx*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetAllJobsEx, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetAllJobsEx*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAllJobsEx location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetAllJobsEx, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetAllJobsEx::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAllJobsEx(soap, tag ? tag : "ns1:GetAllJobsEx", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAllJobsEx::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAllJobsEx(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAllJobsEx * SOAP_FMAC4 soap_get__ns1__GetAllJobsEx(struct soap *soap, _ns1__GetAllJobsEx *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAllJobsEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAllJobsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Job(soap, &this->_ns1__GetAllJobsResponse::GetAllJobsResult);
	/* transient soap skipped */
}

void _ns1__GetAllJobsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Job(soap, &this->_ns1__GetAllJobsResponse::GetAllJobsResult);
#endif
}

int _ns1__GetAllJobsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAllJobsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAllJobsResponse(struct soap *soap, const char *tag, int id, const _ns1__GetAllJobsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAllJobsResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:GetAllJobsResult");
	if (soap_out_std__vectorTemplateOfPointerTons1__Job(soap, "ns1:GetAllJobsResult", -1, &a->_ns1__GetAllJobsResponse::GetAllJobsResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAllJobsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAllJobsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAllJobsResponse * SOAP_FMAC4 soap_in__ns1__GetAllJobsResponse(struct soap *soap, const char *tag, _ns1__GetAllJobsResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAllJobsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAllJobsResponse, sizeof(_ns1__GetAllJobsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAllJobsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAllJobsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Job(soap, "ns1:GetAllJobsResult", &a->_ns1__GetAllJobsResponse::GetAllJobsResult, "ns1:Job"))
					continue;
			soap_check_result(soap, "ns1:GetAllJobsResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__GetAllJobsResponse::GetAllJobsResult.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetAllJobsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAllJobsResponse, SOAP_TYPE__ns1__GetAllJobsResponse, sizeof(_ns1__GetAllJobsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAllJobsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAllJobsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAllJobsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAllJobsResponse *p;
	size_t k = sizeof(_ns1__GetAllJobsResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetAllJobsResponse);
		if (p)
			((_ns1__GetAllJobsResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetAllJobsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetAllJobsResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAllJobsResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetAllJobsResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetAllJobsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAllJobsResponse(soap, tag ? tag : "ns1:GetAllJobsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAllJobsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAllJobsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAllJobsResponse * SOAP_FMAC4 soap_get__ns1__GetAllJobsResponse(struct soap *soap, _ns1__GetAllJobsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAllJobsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetAllJobs::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetAllJobs::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetAllJobs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetAllJobs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetAllJobs(struct soap *soap, const char *tag, int id, const _ns1__GetAllJobs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetAllJobs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetAllJobs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetAllJobs(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetAllJobs * SOAP_FMAC4 soap_in__ns1__GetAllJobs(struct soap *soap, const char *tag, _ns1__GetAllJobs *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetAllJobs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetAllJobs, sizeof(_ns1__GetAllJobs), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetAllJobs)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetAllJobs *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetAllJobs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetAllJobs, SOAP_TYPE__ns1__GetAllJobs, sizeof(_ns1__GetAllJobs), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetAllJobs * SOAP_FMAC2 soap_instantiate__ns1__GetAllJobs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetAllJobs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetAllJobs *p;
	size_t k = sizeof(_ns1__GetAllJobs);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetAllJobs);
		if (p)
			((_ns1__GetAllJobs*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetAllJobs, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetAllJobs*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetAllJobs location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetAllJobs, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetAllJobs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetAllJobs(soap, tag ? tag : "ns1:GetAllJobs", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetAllJobs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetAllJobs(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetAllJobs * SOAP_FMAC4 soap_get__ns1__GetAllJobs(struct soap *soap, _ns1__GetAllJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetAllJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetExpirationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->_ns1__GetExpirationResponse::GetExpirationResult);
	/* transient soap skipped */
}

void _ns1__GetExpirationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetExpirationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetExpirationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetExpirationResponse(struct soap *soap, const char *tag, int id, const _ns1__GetExpirationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetExpirationResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:GetExpirationResult");
	if (soap_out_double(soap, "ns1:GetExpirationResult", -1, &a->_ns1__GetExpirationResponse::GetExpirationResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetExpirationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetExpirationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetExpirationResponse * SOAP_FMAC4 soap_in__ns1__GetExpirationResponse(struct soap *soap, const char *tag, _ns1__GetExpirationResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetExpirationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetExpirationResponse, sizeof(_ns1__GetExpirationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetExpirationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetExpirationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetExpirationResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetExpirationResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:GetExpirationResult", &a->_ns1__GetExpirationResponse::GetExpirationResult, "xsd:double"))
				{	soap_flag_GetExpirationResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:GetExpirationResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetExpirationResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetExpirationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetExpirationResponse, SOAP_TYPE__ns1__GetExpirationResponse, sizeof(_ns1__GetExpirationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetExpirationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetExpirationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetExpirationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetExpirationResponse *p;
	size_t k = sizeof(_ns1__GetExpirationResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetExpirationResponse);
		if (p)
			((_ns1__GetExpirationResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetExpirationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetExpirationResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetExpirationResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetExpirationResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetExpirationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetExpirationResponse(soap, tag ? tag : "ns1:GetExpirationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetExpirationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetExpirationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetExpirationResponse * SOAP_FMAC4 soap_get__ns1__GetExpirationResponse(struct soap *soap, _ns1__GetExpirationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetExpirationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetExpiration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__GetExpiration::jobID);
	/* transient soap skipped */
}

void _ns1__GetExpiration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GetExpiration::jobID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__GetExpiration::jobID);
#endif
}

int _ns1__GetExpiration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetExpiration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetExpiration(struct soap *soap, const char *tag, int id, const _ns1__GetExpiration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetExpiration), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:jobID", -1, &a->_ns1__GetExpiration::jobID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetExpiration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetExpiration(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetExpiration * SOAP_FMAC4 soap_in__ns1__GetExpiration(struct soap *soap, const char *tag, _ns1__GetExpiration *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetExpiration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetExpiration, sizeof(_ns1__GetExpiration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetExpiration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetExpiration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_jobID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:jobID", &a->_ns1__GetExpiration::jobID, "xsd:string"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetExpiration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetExpiration, SOAP_TYPE__ns1__GetExpiration, sizeof(_ns1__GetExpiration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetExpiration * SOAP_FMAC2 soap_instantiate__ns1__GetExpiration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetExpiration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetExpiration *p;
	size_t k = sizeof(_ns1__GetExpiration);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetExpiration);
		if (p)
			((_ns1__GetExpiration*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetExpiration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetExpiration*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetExpiration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetExpiration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetExpiration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetExpiration(soap, tag ? tag : "ns1:GetExpiration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetExpiration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetExpiration(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetExpiration * SOAP_FMAC4 soap_get__ns1__GetExpiration(struct soap *soap, _ns1__GetExpiration *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetExpiration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BatchJobExResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BatchJobExResponse::BatchJobExResult = NULL;
	/* transient soap skipped */
}

void _ns1__BatchJobExResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfLuaValue(soap, &this->_ns1__BatchJobExResponse::BatchJobExResult);
#endif
}

int _ns1__BatchJobExResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BatchJobExResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BatchJobExResponse(struct soap *soap, const char *tag, int id, const _ns1__BatchJobExResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BatchJobExResponse), type))
		return soap->error;
	if (a->BatchJobExResult)
		soap_element_result(soap, "ns1:BatchJobExResult");
	if (!a->_ns1__BatchJobExResponse::BatchJobExResult)
	{	if (soap_element_empty(soap, "ns1:BatchJobExResult"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ArrayOfLuaValue(soap, "ns1:BatchJobExResult", -1, &a->_ns1__BatchJobExResponse::BatchJobExResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BatchJobExResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BatchJobExResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BatchJobExResponse * SOAP_FMAC4 soap_in__ns1__BatchJobExResponse(struct soap *soap, const char *tag, _ns1__BatchJobExResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BatchJobExResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BatchJobExResponse, sizeof(_ns1__BatchJobExResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BatchJobExResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BatchJobExResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_BatchJobExResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_BatchJobExResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfLuaValue(soap, "ns1:BatchJobExResult", &a->_ns1__BatchJobExResponse::BatchJobExResult, "ns1:ArrayOfLuaValue"))
				{	soap_flag_BatchJobExResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:BatchJobExResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__BatchJobExResponse::BatchJobExResult))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__BatchJobExResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BatchJobExResponse, SOAP_TYPE__ns1__BatchJobExResponse, sizeof(_ns1__BatchJobExResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BatchJobExResponse * SOAP_FMAC2 soap_instantiate__ns1__BatchJobExResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BatchJobExResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BatchJobExResponse *p;
	size_t k = sizeof(_ns1__BatchJobExResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__BatchJobExResponse);
		if (p)
			((_ns1__BatchJobExResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__BatchJobExResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__BatchJobExResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BatchJobExResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__BatchJobExResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__BatchJobExResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BatchJobExResponse(soap, tag ? tag : "ns1:BatchJobExResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BatchJobExResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BatchJobExResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BatchJobExResponse * SOAP_FMAC4 soap_get__ns1__BatchJobExResponse(struct soap *soap, _ns1__BatchJobExResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BatchJobExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BatchJobEx::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BatchJobEx::job = NULL;
	this->_ns1__BatchJobEx::script = NULL;
	/* transient soap skipped */
}

void _ns1__BatchJobEx::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Job(soap, &this->_ns1__BatchJobEx::job);
	soap_serialize_PointerTons1__ScriptExecution(soap, &this->_ns1__BatchJobEx::script);
#endif
}

int _ns1__BatchJobEx::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BatchJobEx(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BatchJobEx(struct soap *soap, const char *tag, int id, const _ns1__BatchJobEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BatchJobEx), type))
		return soap->error;
	if (!a->_ns1__BatchJobEx::job)
	{	if (soap_element_empty(soap, "ns1:job"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Job(soap, "ns1:job", -1, &a->_ns1__BatchJobEx::job, ""))
		return soap->error;
	if (!a->_ns1__BatchJobEx::script)
	{	if (soap_element_empty(soap, "ns1:script"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ScriptExecution(soap, "ns1:script", -1, &a->_ns1__BatchJobEx::script, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BatchJobEx::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BatchJobEx(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BatchJobEx * SOAP_FMAC4 soap_in__ns1__BatchJobEx(struct soap *soap, const char *tag, _ns1__BatchJobEx *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BatchJobEx *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BatchJobEx, sizeof(_ns1__BatchJobEx), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BatchJobEx)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BatchJobEx *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_job1 = 1;
	size_t soap_flag_script1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_job1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Job(soap, "ns1:job", &a->_ns1__BatchJobEx::job, "ns1:Job"))
				{	soap_flag_job1--;
					continue;
				}
			if (soap_flag_script1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ScriptExecution(soap, "ns1:script", &a->_ns1__BatchJobEx::script, "ns1:ScriptExecution"))
				{	soap_flag_script1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__BatchJobEx::job || !a->_ns1__BatchJobEx::script))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__BatchJobEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BatchJobEx, SOAP_TYPE__ns1__BatchJobEx, sizeof(_ns1__BatchJobEx), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BatchJobEx * SOAP_FMAC2 soap_instantiate__ns1__BatchJobEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BatchJobEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BatchJobEx *p;
	size_t k = sizeof(_ns1__BatchJobEx);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__BatchJobEx);
		if (p)
			((_ns1__BatchJobEx*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__BatchJobEx, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__BatchJobEx*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BatchJobEx location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__BatchJobEx, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__BatchJobEx::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BatchJobEx(soap, tag ? tag : "ns1:BatchJobEx", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BatchJobEx::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BatchJobEx(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BatchJobEx * SOAP_FMAC4 soap_get__ns1__BatchJobEx(struct soap *soap, _ns1__BatchJobEx *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BatchJobEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BatchJobResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__LuaValue(soap, &this->_ns1__BatchJobResponse::BatchJobResult);
	/* transient soap skipped */
}

void _ns1__BatchJobResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__LuaValue(soap, &this->_ns1__BatchJobResponse::BatchJobResult);
#endif
}

int _ns1__BatchJobResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BatchJobResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BatchJobResponse(struct soap *soap, const char *tag, int id, const _ns1__BatchJobResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BatchJobResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:BatchJobResult");
	if (soap_out_std__vectorTemplateOfPointerTons1__LuaValue(soap, "ns1:BatchJobResult", -1, &a->_ns1__BatchJobResponse::BatchJobResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BatchJobResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BatchJobResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BatchJobResponse * SOAP_FMAC4 soap_in__ns1__BatchJobResponse(struct soap *soap, const char *tag, _ns1__BatchJobResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BatchJobResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BatchJobResponse, sizeof(_ns1__BatchJobResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BatchJobResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BatchJobResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__LuaValue(soap, "ns1:BatchJobResult", &a->_ns1__BatchJobResponse::BatchJobResult, "ns1:LuaValue"))
					continue;
			soap_check_result(soap, "ns1:BatchJobResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__BatchJobResponse::BatchJobResult.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__BatchJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BatchJobResponse, SOAP_TYPE__ns1__BatchJobResponse, sizeof(_ns1__BatchJobResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BatchJobResponse * SOAP_FMAC2 soap_instantiate__ns1__BatchJobResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BatchJobResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BatchJobResponse *p;
	size_t k = sizeof(_ns1__BatchJobResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__BatchJobResponse);
		if (p)
			((_ns1__BatchJobResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__BatchJobResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__BatchJobResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BatchJobResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__BatchJobResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__BatchJobResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BatchJobResponse(soap, tag ? tag : "ns1:BatchJobResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BatchJobResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BatchJobResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BatchJobResponse * SOAP_FMAC4 soap_get__ns1__BatchJobResponse(struct soap *soap, _ns1__BatchJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BatchJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__BatchJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__BatchJob::job = NULL;
	this->_ns1__BatchJob::script = NULL;
	/* transient soap skipped */
}

void _ns1__BatchJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Job(soap, &this->_ns1__BatchJob::job);
	soap_serialize_PointerTons1__ScriptExecution(soap, &this->_ns1__BatchJob::script);
#endif
}

int _ns1__BatchJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__BatchJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__BatchJob(struct soap *soap, const char *tag, int id, const _ns1__BatchJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__BatchJob), type))
		return soap->error;
	if (!a->_ns1__BatchJob::job)
	{	if (soap_element_empty(soap, "ns1:job"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Job(soap, "ns1:job", -1, &a->_ns1__BatchJob::job, ""))
		return soap->error;
	if (!a->_ns1__BatchJob::script)
	{	if (soap_element_empty(soap, "ns1:script"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ScriptExecution(soap, "ns1:script", -1, &a->_ns1__BatchJob::script, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__BatchJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__BatchJob(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__BatchJob * SOAP_FMAC4 soap_in__ns1__BatchJob(struct soap *soap, const char *tag, _ns1__BatchJob *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__BatchJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__BatchJob, sizeof(_ns1__BatchJob), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__BatchJob)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__BatchJob *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_job1 = 1;
	size_t soap_flag_script1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_job1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Job(soap, "ns1:job", &a->_ns1__BatchJob::job, "ns1:Job"))
				{	soap_flag_job1--;
					continue;
				}
			if (soap_flag_script1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ScriptExecution(soap, "ns1:script", &a->_ns1__BatchJob::script, "ns1:ScriptExecution"))
				{	soap_flag_script1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__BatchJob::job || !a->_ns1__BatchJob::script))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__BatchJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__BatchJob, SOAP_TYPE__ns1__BatchJob, sizeof(_ns1__BatchJob), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__BatchJob * SOAP_FMAC2 soap_instantiate__ns1__BatchJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__BatchJob(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__BatchJob *p;
	size_t k = sizeof(_ns1__BatchJob);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__BatchJob);
		if (p)
			((_ns1__BatchJob*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__BatchJob, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__BatchJob*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__BatchJob location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__BatchJob, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__BatchJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__BatchJob(soap, tag ? tag : "ns1:BatchJob", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__BatchJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__BatchJob(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__BatchJob * SOAP_FMAC4 soap_get__ns1__BatchJob(struct soap *soap, _ns1__BatchJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__BatchJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CloseJobResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__CloseJobResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__CloseJobResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CloseJobResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CloseJobResponse(struct soap *soap, const char *tag, int id, const _ns1__CloseJobResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CloseJobResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CloseJobResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CloseJobResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CloseJobResponse * SOAP_FMAC4 soap_in__ns1__CloseJobResponse(struct soap *soap, const char *tag, _ns1__CloseJobResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CloseJobResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CloseJobResponse, sizeof(_ns1__CloseJobResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CloseJobResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CloseJobResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__CloseJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CloseJobResponse, SOAP_TYPE__ns1__CloseJobResponse, sizeof(_ns1__CloseJobResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CloseJobResponse * SOAP_FMAC2 soap_instantiate__ns1__CloseJobResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CloseJobResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CloseJobResponse *p;
	size_t k = sizeof(_ns1__CloseJobResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CloseJobResponse);
		if (p)
			((_ns1__CloseJobResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CloseJobResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CloseJobResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CloseJobResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CloseJobResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CloseJobResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CloseJobResponse(soap, tag ? tag : "ns1:CloseJobResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CloseJobResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CloseJobResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CloseJobResponse * SOAP_FMAC4 soap_get__ns1__CloseJobResponse(struct soap *soap, _ns1__CloseJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CloseJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__CloseJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__CloseJob::jobID);
	/* transient soap skipped */
}

void _ns1__CloseJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__CloseJob::jobID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__CloseJob::jobID);
#endif
}

int _ns1__CloseJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__CloseJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__CloseJob(struct soap *soap, const char *tag, int id, const _ns1__CloseJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__CloseJob), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:jobID", -1, &a->_ns1__CloseJob::jobID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__CloseJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__CloseJob(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__CloseJob * SOAP_FMAC4 soap_in__ns1__CloseJob(struct soap *soap, const char *tag, _ns1__CloseJob *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__CloseJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__CloseJob, sizeof(_ns1__CloseJob), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__CloseJob)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__CloseJob *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_jobID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:jobID", &a->_ns1__CloseJob::jobID, "xsd:string"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobID1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__CloseJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__CloseJob, SOAP_TYPE__ns1__CloseJob, sizeof(_ns1__CloseJob), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__CloseJob * SOAP_FMAC2 soap_instantiate__ns1__CloseJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__CloseJob(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__CloseJob *p;
	size_t k = sizeof(_ns1__CloseJob);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__CloseJob);
		if (p)
			((_ns1__CloseJob*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__CloseJob, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__CloseJob*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__CloseJob location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__CloseJob, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__CloseJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__CloseJob(soap, tag ? tag : "ns1:CloseJob", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__CloseJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__CloseJob(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__CloseJob * SOAP_FMAC4 soap_get__ns1__CloseJob(struct soap *soap, _ns1__CloseJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__CloseJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExecuteExResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__ExecuteExResponse::ExecuteExResult = NULL;
	/* transient soap skipped */
}

void _ns1__ExecuteExResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfLuaValue(soap, &this->_ns1__ExecuteExResponse::ExecuteExResult);
#endif
}

int _ns1__ExecuteExResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExecuteExResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteExResponse(struct soap *soap, const char *tag, int id, const _ns1__ExecuteExResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteExResponse), type))
		return soap->error;
	if (a->ExecuteExResult)
		soap_element_result(soap, "ns1:ExecuteExResult");
	if (!a->_ns1__ExecuteExResponse::ExecuteExResult)
	{	if (soap_element_empty(soap, "ns1:ExecuteExResult"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ArrayOfLuaValue(soap, "ns1:ExecuteExResult", -1, &a->_ns1__ExecuteExResponse::ExecuteExResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExecuteExResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExecuteExResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExecuteExResponse * SOAP_FMAC4 soap_in__ns1__ExecuteExResponse(struct soap *soap, const char *tag, _ns1__ExecuteExResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExecuteExResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteExResponse, sizeof(_ns1__ExecuteExResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExecuteExResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExecuteExResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ExecuteExResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ExecuteExResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfLuaValue(soap, "ns1:ExecuteExResult", &a->_ns1__ExecuteExResponse::ExecuteExResult, "ns1:ArrayOfLuaValue"))
				{	soap_flag_ExecuteExResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:ExecuteExResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__ExecuteExResponse::ExecuteExResult))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ExecuteExResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteExResponse, SOAP_TYPE__ns1__ExecuteExResponse, sizeof(_ns1__ExecuteExResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExecuteExResponse * SOAP_FMAC2 soap_instantiate__ns1__ExecuteExResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExecuteExResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExecuteExResponse *p;
	size_t k = sizeof(_ns1__ExecuteExResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ExecuteExResponse);
		if (p)
			((_ns1__ExecuteExResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ExecuteExResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ExecuteExResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExecuteExResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ExecuteExResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ExecuteExResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExecuteExResponse(soap, tag ? tag : "ns1:ExecuteExResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExecuteExResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExecuteExResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExecuteExResponse * SOAP_FMAC4 soap_get__ns1__ExecuteExResponse(struct soap *soap, _ns1__ExecuteExResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExecuteEx::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__ExecuteEx::jobID);
	this->_ns1__ExecuteEx::script = NULL;
	/* transient soap skipped */
}

void _ns1__ExecuteEx::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__ExecuteEx::jobID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__ExecuteEx::jobID);
	soap_serialize_PointerTons1__ScriptExecution(soap, &this->_ns1__ExecuteEx::script);
#endif
}

int _ns1__ExecuteEx::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExecuteEx(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteEx(struct soap *soap, const char *tag, int id, const _ns1__ExecuteEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteEx), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:jobID", -1, &a->_ns1__ExecuteEx::jobID, ""))
		return soap->error;
	if (!a->_ns1__ExecuteEx::script)
	{	if (soap_element_empty(soap, "ns1:script"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ScriptExecution(soap, "ns1:script", -1, &a->_ns1__ExecuteEx::script, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExecuteEx::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExecuteEx(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExecuteEx * SOAP_FMAC4 soap_in__ns1__ExecuteEx(struct soap *soap, const char *tag, _ns1__ExecuteEx *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExecuteEx *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteEx, sizeof(_ns1__ExecuteEx), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExecuteEx)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExecuteEx *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_jobID1 = 1;
	size_t soap_flag_script1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:jobID", &a->_ns1__ExecuteEx::jobID, "xsd:string"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap_flag_script1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ScriptExecution(soap, "ns1:script", &a->_ns1__ExecuteEx::script, "ns1:ScriptExecution"))
				{	soap_flag_script1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobID1 > 0 || !a->_ns1__ExecuteEx::script))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ExecuteEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteEx, SOAP_TYPE__ns1__ExecuteEx, sizeof(_ns1__ExecuteEx), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExecuteEx * SOAP_FMAC2 soap_instantiate__ns1__ExecuteEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExecuteEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExecuteEx *p;
	size_t k = sizeof(_ns1__ExecuteEx);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ExecuteEx);
		if (p)
			((_ns1__ExecuteEx*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ExecuteEx, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ExecuteEx*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExecuteEx location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ExecuteEx, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ExecuteEx::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExecuteEx(soap, tag ? tag : "ns1:ExecuteEx", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExecuteEx::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExecuteEx(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExecuteEx * SOAP_FMAC4 soap_get__ns1__ExecuteEx(struct soap *soap, _ns1__ExecuteEx *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__ExecuteResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__LuaValue(soap, &this->_ns1__ExecuteResponse::ExecuteResult);
	/* transient soap skipped */
}

void _ns1__ExecuteResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__LuaValue(soap, &this->_ns1__ExecuteResponse::ExecuteResult);
#endif
}

int _ns1__ExecuteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__ExecuteResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__ExecuteResponse(struct soap *soap, const char *tag, int id, const _ns1__ExecuteResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__ExecuteResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:ExecuteResult");
	if (soap_out_std__vectorTemplateOfPointerTons1__LuaValue(soap, "ns1:ExecuteResult", -1, &a->_ns1__ExecuteResponse::ExecuteResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__ExecuteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__ExecuteResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__ExecuteResponse * SOAP_FMAC4 soap_in__ns1__ExecuteResponse(struct soap *soap, const char *tag, _ns1__ExecuteResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__ExecuteResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__ExecuteResponse, sizeof(_ns1__ExecuteResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__ExecuteResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__ExecuteResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__LuaValue(soap, "ns1:ExecuteResult", &a->_ns1__ExecuteResponse::ExecuteResult, "ns1:LuaValue"))
					continue;
			soap_check_result(soap, "ns1:ExecuteResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (a->_ns1__ExecuteResponse::ExecuteResult.size() < 1))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__ExecuteResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__ExecuteResponse, SOAP_TYPE__ns1__ExecuteResponse, sizeof(_ns1__ExecuteResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__ExecuteResponse * SOAP_FMAC2 soap_instantiate__ns1__ExecuteResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__ExecuteResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__ExecuteResponse *p;
	size_t k = sizeof(_ns1__ExecuteResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__ExecuteResponse);
		if (p)
			((_ns1__ExecuteResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__ExecuteResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__ExecuteResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__ExecuteResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__ExecuteResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__ExecuteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__ExecuteResponse(soap, tag ? tag : "ns1:ExecuteResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__ExecuteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__ExecuteResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__ExecuteResponse * SOAP_FMAC4 soap_get__ns1__ExecuteResponse(struct soap *soap, _ns1__ExecuteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__ExecuteResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__Execute::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__Execute::jobID);
	this->_ns1__Execute::script = NULL;
	/* transient soap skipped */
}

void _ns1__Execute::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__Execute::jobID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__Execute::jobID);
	soap_serialize_PointerTons1__ScriptExecution(soap, &this->_ns1__Execute::script);
#endif
}

int _ns1__Execute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__Execute(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__Execute(struct soap *soap, const char *tag, int id, const _ns1__Execute *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__Execute), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:jobID", -1, &a->_ns1__Execute::jobID, ""))
		return soap->error;
	if (!a->_ns1__Execute::script)
	{	if (soap_element_empty(soap, "ns1:script"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ScriptExecution(soap, "ns1:script", -1, &a->_ns1__Execute::script, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__Execute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__Execute(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__Execute * SOAP_FMAC4 soap_in__ns1__Execute(struct soap *soap, const char *tag, _ns1__Execute *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__Execute *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__Execute, sizeof(_ns1__Execute), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__Execute)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__Execute *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_jobID1 = 1;
	size_t soap_flag_script1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:jobID", &a->_ns1__Execute::jobID, "xsd:string"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap_flag_script1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ScriptExecution(soap, "ns1:script", &a->_ns1__Execute::script, "ns1:ScriptExecution"))
				{	soap_flag_script1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobID1 > 0 || !a->_ns1__Execute::script))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__Execute *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__Execute, SOAP_TYPE__ns1__Execute, sizeof(_ns1__Execute), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__Execute * SOAP_FMAC2 soap_instantiate__ns1__Execute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__Execute(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__Execute *p;
	size_t k = sizeof(_ns1__Execute);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__Execute);
		if (p)
			((_ns1__Execute*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__Execute, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__Execute*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__Execute location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__Execute, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__Execute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__Execute(soap, tag ? tag : "ns1:Execute", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__Execute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__Execute(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__Execute * SOAP_FMAC4 soap_get__ns1__Execute(struct soap *soap, _ns1__Execute *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__Execute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RenewLeaseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_double(soap, &this->_ns1__RenewLeaseResponse::RenewLeaseResult);
	/* transient soap skipped */
}

void _ns1__RenewLeaseResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__RenewLeaseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RenewLeaseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RenewLeaseResponse(struct soap *soap, const char *tag, int id, const _ns1__RenewLeaseResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RenewLeaseResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:RenewLeaseResult");
	if (soap_out_double(soap, "ns1:RenewLeaseResult", -1, &a->_ns1__RenewLeaseResponse::RenewLeaseResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RenewLeaseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RenewLeaseResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RenewLeaseResponse * SOAP_FMAC4 soap_in__ns1__RenewLeaseResponse(struct soap *soap, const char *tag, _ns1__RenewLeaseResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RenewLeaseResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RenewLeaseResponse, sizeof(_ns1__RenewLeaseResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__RenewLeaseResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__RenewLeaseResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RenewLeaseResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RenewLeaseResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:RenewLeaseResult", &a->_ns1__RenewLeaseResponse::RenewLeaseResult, "xsd:double"))
				{	soap_flag_RenewLeaseResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:RenewLeaseResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RenewLeaseResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RenewLeaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RenewLeaseResponse, SOAP_TYPE__ns1__RenewLeaseResponse, sizeof(_ns1__RenewLeaseResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RenewLeaseResponse * SOAP_FMAC2 soap_instantiate__ns1__RenewLeaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RenewLeaseResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RenewLeaseResponse *p;
	size_t k = sizeof(_ns1__RenewLeaseResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RenewLeaseResponse);
		if (p)
			((_ns1__RenewLeaseResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RenewLeaseResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RenewLeaseResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RenewLeaseResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RenewLeaseResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RenewLeaseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__RenewLeaseResponse(soap, tag ? tag : "ns1:RenewLeaseResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RenewLeaseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RenewLeaseResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RenewLeaseResponse * SOAP_FMAC4 soap_get__ns1__RenewLeaseResponse(struct soap *soap, _ns1__RenewLeaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RenewLeaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__RenewLease::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__RenewLease::jobID);
	soap_default_double(soap, &this->_ns1__RenewLease::expirationInSeconds);
	/* transient soap skipped */
}

void _ns1__RenewLease::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__RenewLease::jobID, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__RenewLease::jobID);
#endif
}

int _ns1__RenewLease::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__RenewLease(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__RenewLease(struct soap *soap, const char *tag, int id, const _ns1__RenewLease *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__RenewLease), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:jobID", -1, &a->_ns1__RenewLease::jobID, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:expirationInSeconds", -1, &a->_ns1__RenewLease::expirationInSeconds, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__RenewLease::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__RenewLease(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__RenewLease * SOAP_FMAC4 soap_in__ns1__RenewLease(struct soap *soap, const char *tag, _ns1__RenewLease *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__RenewLease *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__RenewLease, sizeof(_ns1__RenewLease), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__RenewLease)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__RenewLease *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_jobID1 = 1;
	size_t soap_flag_expirationInSeconds1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_jobID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:jobID", &a->_ns1__RenewLease::jobID, "xsd:string"))
				{	soap_flag_jobID1--;
					continue;
				}
			if (soap_flag_expirationInSeconds1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:expirationInSeconds", &a->_ns1__RenewLease::expirationInSeconds, "xsd:double"))
				{	soap_flag_expirationInSeconds1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_jobID1 > 0 || soap_flag_expirationInSeconds1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__RenewLease *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__RenewLease, SOAP_TYPE__ns1__RenewLease, sizeof(_ns1__RenewLease), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__RenewLease * SOAP_FMAC2 soap_instantiate__ns1__RenewLease(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__RenewLease(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__RenewLease *p;
	size_t k = sizeof(_ns1__RenewLease);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__RenewLease);
		if (p)
			((_ns1__RenewLease*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__RenewLease, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__RenewLease*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__RenewLease location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__RenewLease, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__RenewLease::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__RenewLease(soap, tag ? tag : "ns1:RenewLease", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__RenewLease::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__RenewLease(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__RenewLease * SOAP_FMAC4 soap_get__ns1__RenewLease(struct soap *soap, _ns1__RenewLease *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__RenewLease(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OpenJobExResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OpenJobExResponse::OpenJobExResult = NULL;
	/* transient soap skipped */
}

void _ns1__OpenJobExResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__ArrayOfLuaValue(soap, &this->_ns1__OpenJobExResponse::OpenJobExResult);
#endif
}

int _ns1__OpenJobExResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OpenJobExResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OpenJobExResponse(struct soap *soap, const char *tag, int id, const _ns1__OpenJobExResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OpenJobExResponse), type))
		return soap->error;
	if (a->OpenJobExResult)
		soap_element_result(soap, "ns1:OpenJobExResult");
	if (!a->_ns1__OpenJobExResponse::OpenJobExResult)
	{	if (soap_element_empty(soap, "ns1:OpenJobExResult"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__ArrayOfLuaValue(soap, "ns1:OpenJobExResult", -1, &a->_ns1__OpenJobExResponse::OpenJobExResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OpenJobExResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OpenJobExResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OpenJobExResponse * SOAP_FMAC4 soap_in__ns1__OpenJobExResponse(struct soap *soap, const char *tag, _ns1__OpenJobExResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OpenJobExResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OpenJobExResponse, sizeof(_ns1__OpenJobExResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OpenJobExResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OpenJobExResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_OpenJobExResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_OpenJobExResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfLuaValue(soap, "ns1:OpenJobExResult", &a->_ns1__OpenJobExResponse::OpenJobExResult, "ns1:ArrayOfLuaValue"))
				{	soap_flag_OpenJobExResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:OpenJobExResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__OpenJobExResponse::OpenJobExResult))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__OpenJobExResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OpenJobExResponse, SOAP_TYPE__ns1__OpenJobExResponse, sizeof(_ns1__OpenJobExResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OpenJobExResponse * SOAP_FMAC2 soap_instantiate__ns1__OpenJobExResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OpenJobExResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OpenJobExResponse *p;
	size_t k = sizeof(_ns1__OpenJobExResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__OpenJobExResponse);
		if (p)
			((_ns1__OpenJobExResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__OpenJobExResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__OpenJobExResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OpenJobExResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__OpenJobExResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__OpenJobExResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OpenJobExResponse(soap, tag ? tag : "ns1:OpenJobExResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OpenJobExResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OpenJobExResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OpenJobExResponse * SOAP_FMAC4 soap_get__ns1__OpenJobExResponse(struct soap *soap, _ns1__OpenJobExResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OpenJobExResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OpenJobResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__LuaValue(soap, &this->_ns1__OpenJobResponse::OpenJobResult);
	/* transient soap skipped */
}

void _ns1__OpenJobResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__LuaValue(soap, &this->_ns1__OpenJobResponse::OpenJobResult);
#endif
}

int _ns1__OpenJobResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OpenJobResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OpenJobResponse(struct soap *soap, const char *tag, int id, const _ns1__OpenJobResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OpenJobResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:OpenJobResult");
	if (soap_out_std__vectorTemplateOfPointerTons1__LuaValue(soap, "ns1:OpenJobResult", -1, &a->_ns1__OpenJobResponse::OpenJobResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OpenJobResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OpenJobResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OpenJobResponse * SOAP_FMAC4 soap_in__ns1__OpenJobResponse(struct soap *soap, const char *tag, _ns1__OpenJobResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OpenJobResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OpenJobResponse, sizeof(_ns1__OpenJobResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OpenJobResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OpenJobResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__LuaValue(soap, "ns1:OpenJobResult", &a->_ns1__OpenJobResponse::OpenJobResult, "ns1:LuaValue"))
					continue;
			soap_check_result(soap, "ns1:OpenJobResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__OpenJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OpenJobResponse, SOAP_TYPE__ns1__OpenJobResponse, sizeof(_ns1__OpenJobResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OpenJobResponse * SOAP_FMAC2 soap_instantiate__ns1__OpenJobResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OpenJobResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OpenJobResponse *p;
	size_t k = sizeof(_ns1__OpenJobResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__OpenJobResponse);
		if (p)
			((_ns1__OpenJobResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__OpenJobResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__OpenJobResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OpenJobResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__OpenJobResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__OpenJobResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OpenJobResponse(soap, tag ? tag : "ns1:OpenJobResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OpenJobResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OpenJobResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OpenJobResponse * SOAP_FMAC4 soap_get__ns1__OpenJobResponse(struct soap *soap, _ns1__OpenJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OpenJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OpenJobEx::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OpenJobEx::job = NULL;
	this->_ns1__OpenJobEx::script = NULL;
	/* transient soap skipped */
}

void _ns1__OpenJobEx::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Job(soap, &this->_ns1__OpenJobEx::job);
	soap_serialize_PointerTons1__ScriptExecution(soap, &this->_ns1__OpenJobEx::script);
#endif
}

int _ns1__OpenJobEx::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OpenJobEx(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OpenJobEx(struct soap *soap, const char *tag, int id, const _ns1__OpenJobEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OpenJobEx), type))
		return soap->error;
	if (!a->_ns1__OpenJobEx::job)
	{	if (soap_element_empty(soap, "ns1:job"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Job(soap, "ns1:job", -1, &a->_ns1__OpenJobEx::job, ""))
		return soap->error;
	if (soap_out_PointerTons1__ScriptExecution(soap, "ns1:script", -1, &a->_ns1__OpenJobEx::script, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OpenJobEx::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OpenJobEx(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OpenJobEx * SOAP_FMAC4 soap_in__ns1__OpenJobEx(struct soap *soap, const char *tag, _ns1__OpenJobEx *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OpenJobEx *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OpenJobEx, sizeof(_ns1__OpenJobEx), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OpenJobEx)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OpenJobEx *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_job1 = 1;
	size_t soap_flag_script1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_job1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Job(soap, "ns1:job", &a->_ns1__OpenJobEx::job, "ns1:Job"))
				{	soap_flag_job1--;
					continue;
				}
			if (soap_flag_script1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ScriptExecution(soap, "ns1:script", &a->_ns1__OpenJobEx::script, "ns1:ScriptExecution"))
				{	soap_flag_script1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__OpenJobEx::job))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__OpenJobEx *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OpenJobEx, SOAP_TYPE__ns1__OpenJobEx, sizeof(_ns1__OpenJobEx), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OpenJobEx * SOAP_FMAC2 soap_instantiate__ns1__OpenJobEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OpenJobEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OpenJobEx *p;
	size_t k = sizeof(_ns1__OpenJobEx);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__OpenJobEx);
		if (p)
			((_ns1__OpenJobEx*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__OpenJobEx, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__OpenJobEx*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OpenJobEx location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__OpenJobEx, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__OpenJobEx::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OpenJobEx(soap, tag ? tag : "ns1:OpenJobEx", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OpenJobEx::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OpenJobEx(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OpenJobEx * SOAP_FMAC4 soap_get__ns1__OpenJobEx(struct soap *soap, _ns1__OpenJobEx *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OpenJobEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__OpenJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__OpenJob::job = NULL;
	this->_ns1__OpenJob::script = NULL;
	/* transient soap skipped */
}

void _ns1__OpenJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Job(soap, &this->_ns1__OpenJob::job);
	soap_serialize_PointerTons1__ScriptExecution(soap, &this->_ns1__OpenJob::script);
#endif
}

int _ns1__OpenJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__OpenJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__OpenJob(struct soap *soap, const char *tag, int id, const _ns1__OpenJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__OpenJob), type))
		return soap->error;
	if (!a->_ns1__OpenJob::job)
	{	if (soap_element_empty(soap, "ns1:job"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Job(soap, "ns1:job", -1, &a->_ns1__OpenJob::job, ""))
		return soap->error;
	if (soap_out_PointerTons1__ScriptExecution(soap, "ns1:script", -1, &a->_ns1__OpenJob::script, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__OpenJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__OpenJob(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__OpenJob * SOAP_FMAC4 soap_in__ns1__OpenJob(struct soap *soap, const char *tag, _ns1__OpenJob *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__OpenJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__OpenJob, sizeof(_ns1__OpenJob), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__OpenJob)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__OpenJob *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_job1 = 1;
	size_t soap_flag_script1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_job1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Job(soap, "ns1:job", &a->_ns1__OpenJob::job, "ns1:Job"))
				{	soap_flag_job1--;
					continue;
				}
			if (soap_flag_script1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ScriptExecution(soap, "ns1:script", &a->_ns1__OpenJob::script, "ns1:ScriptExecution"))
				{	soap_flag_script1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__OpenJob::job))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__OpenJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__OpenJob, SOAP_TYPE__ns1__OpenJob, sizeof(_ns1__OpenJob), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__OpenJob * SOAP_FMAC2 soap_instantiate__ns1__OpenJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__OpenJob(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__OpenJob *p;
	size_t k = sizeof(_ns1__OpenJob);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__OpenJob);
		if (p)
			((_ns1__OpenJob*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__OpenJob, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__OpenJob*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__OpenJob location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__OpenJob, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__OpenJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__OpenJob(soap, tag ? tag : "ns1:OpenJob", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__OpenJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__OpenJob(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__OpenJob * SOAP_FMAC4 soap_get__ns1__OpenJob(struct soap *soap, _ns1__OpenJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__OpenJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__GetStatusResponse::GetStatusResult = NULL;
	/* transient soap skipped */
}

void _ns1__GetStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTons1__Status(soap, &this->_ns1__GetStatusResponse::GetStatusResult);
#endif
}

int _ns1__GetStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStatusResponse(struct soap *soap, const char *tag, int id, const _ns1__GetStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStatusResponse), type))
		return soap->error;
	if (a->GetStatusResult)
		soap_element_result(soap, "ns1:GetStatusResult");
	if (!a->_ns1__GetStatusResponse::GetStatusResult)
	{	if (soap_element_empty(soap, "ns1:GetStatusResult"))
			return soap->error;
	}
	else
	if (soap_out_PointerTons1__Status(soap, "ns1:GetStatusResult", -1, &a->_ns1__GetStatusResponse::GetStatusResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStatusResponse * SOAP_FMAC4 soap_in__ns1__GetStatusResponse(struct soap *soap, const char *tag, _ns1__GetStatusResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStatusResponse, sizeof(_ns1__GetStatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetStatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetStatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetStatusResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetStatusResult1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__Status(soap, "ns1:GetStatusResult", &a->_ns1__GetStatusResponse::GetStatusResult, "ns1:Status"))
				{	soap_flag_GetStatusResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:GetStatusResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_ns1__GetStatusResponse::GetStatusResult))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStatusResponse, SOAP_TYPE__ns1__GetStatusResponse, sizeof(_ns1__GetStatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetStatusResponse *p;
	size_t k = sizeof(_ns1__GetStatusResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetStatusResponse);
		if (p)
			((_ns1__GetStatusResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetStatusResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetStatusResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetStatusResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetStatusResponse(soap, tag ? tag : "ns1:GetStatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStatusResponse * SOAP_FMAC4 soap_get__ns1__GetStatusResponse(struct soap *soap, _ns1__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetStatus(struct soap *soap, const char *tag, int id, const _ns1__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetStatus), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetStatus(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetStatus * SOAP_FMAC4 soap_in__ns1__GetStatus(struct soap *soap, const char *tag, _ns1__GetStatus *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetStatus, sizeof(_ns1__GetStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetStatus, SOAP_TYPE__ns1__GetStatus, sizeof(_ns1__GetStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetStatus * SOAP_FMAC2 soap_instantiate__ns1__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetStatus *p;
	size_t k = sizeof(_ns1__GetStatus);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetStatus);
		if (p)
			((_ns1__GetStatus*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetStatus*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetStatus location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetStatus, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetStatus(soap, tag ? tag : "ns1:GetStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetStatus(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetStatus * SOAP_FMAC4 soap_get__ns1__GetStatus(struct soap *soap, _ns1__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetVersionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_ns1__GetVersionResponse::GetVersionResult);
	/* transient soap skipped */
}

void _ns1__GetVersionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_ns1__GetVersionResponse::GetVersionResult, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_ns1__GetVersionResponse::GetVersionResult);
#endif
}

int _ns1__GetVersionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetVersionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVersionResponse(struct soap *soap, const char *tag, int id, const _ns1__GetVersionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVersionResponse), type))
		return soap->error;
	soap_element_result(soap, "ns1:GetVersionResult");
	if (soap_out_std__string(soap, "ns1:GetVersionResult", -1, &a->_ns1__GetVersionResponse::GetVersionResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetVersionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetVersionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetVersionResponse * SOAP_FMAC4 soap_in__ns1__GetVersionResponse(struct soap *soap, const char *tag, _ns1__GetVersionResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetVersionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVersionResponse, sizeof(_ns1__GetVersionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetVersionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetVersionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_GetVersionResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_GetVersionResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:GetVersionResult", &a->_ns1__GetVersionResponse::GetVersionResult, "xsd:string"))
				{	soap_flag_GetVersionResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:GetVersionResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GetVersionResult1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_ns1__GetVersionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVersionResponse, SOAP_TYPE__ns1__GetVersionResponse, sizeof(_ns1__GetVersionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetVersionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetVersionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetVersionResponse *p;
	size_t k = sizeof(_ns1__GetVersionResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetVersionResponse);
		if (p)
			((_ns1__GetVersionResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetVersionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetVersionResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetVersionResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetVersionResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetVersionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetVersionResponse(soap, tag ? tag : "ns1:GetVersionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetVersionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetVersionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetVersionResponse * SOAP_FMAC4 soap_get__ns1__GetVersionResponse(struct soap *soap, _ns1__GetVersionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVersionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__GetVersion::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__GetVersion::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__GetVersion::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__GetVersion(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__GetVersion(struct soap *soap, const char *tag, int id, const _ns1__GetVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__GetVersion), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__GetVersion::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__GetVersion(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__GetVersion * SOAP_FMAC4 soap_in__ns1__GetVersion(struct soap *soap, const char *tag, _ns1__GetVersion *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__GetVersion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__GetVersion, sizeof(_ns1__GetVersion), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__GetVersion)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__GetVersion *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__GetVersion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__GetVersion, SOAP_TYPE__ns1__GetVersion, sizeof(_ns1__GetVersion), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__GetVersion * SOAP_FMAC2 soap_instantiate__ns1__GetVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__GetVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__GetVersion *p;
	size_t k = sizeof(_ns1__GetVersion);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__GetVersion);
		if (p)
			((_ns1__GetVersion*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__GetVersion, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__GetVersion*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__GetVersion location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__GetVersion, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__GetVersion::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__GetVersion(soap, tag ? tag : "ns1:GetVersion", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__GetVersion::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__GetVersion(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__GetVersion * SOAP_FMAC4 soap_get__ns1__GetVersion(struct soap *soap, _ns1__GetVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__GetVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__HelloWorldResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_ns1__HelloWorldResponse::HelloWorldResult = NULL;
	/* transient soap skipped */
}

void _ns1__HelloWorldResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->_ns1__HelloWorldResponse::HelloWorldResult);
#endif
}

int _ns1__HelloWorldResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__HelloWorldResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__HelloWorldResponse(struct soap *soap, const char *tag, int id, const _ns1__HelloWorldResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__HelloWorldResponse), type))
		return soap->error;
	if (a->HelloWorldResult)
		soap_element_result(soap, "ns1:HelloWorldResult");
	if (soap_out_PointerTostd__string(soap, "ns1:HelloWorldResult", -1, &a->_ns1__HelloWorldResponse::HelloWorldResult, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__HelloWorldResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__HelloWorldResponse(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__HelloWorldResponse * SOAP_FMAC4 soap_in__ns1__HelloWorldResponse(struct soap *soap, const char *tag, _ns1__HelloWorldResponse *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__HelloWorldResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__HelloWorldResponse, sizeof(_ns1__HelloWorldResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__HelloWorldResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__HelloWorldResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_HelloWorldResult1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HelloWorldResult1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:HelloWorldResult", &a->_ns1__HelloWorldResponse::HelloWorldResult, "xsd:string"))
				{	soap_flag_HelloWorldResult1--;
					continue;
				}
			soap_check_result(soap, "ns1:HelloWorldResult");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__HelloWorldResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__HelloWorldResponse, SOAP_TYPE__ns1__HelloWorldResponse, sizeof(_ns1__HelloWorldResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__HelloWorldResponse * SOAP_FMAC2 soap_instantiate__ns1__HelloWorldResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__HelloWorldResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__HelloWorldResponse *p;
	size_t k = sizeof(_ns1__HelloWorldResponse);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__HelloWorldResponse);
		if (p)
			((_ns1__HelloWorldResponse*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__HelloWorldResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__HelloWorldResponse*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__HelloWorldResponse location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__HelloWorldResponse, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__HelloWorldResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__HelloWorldResponse(soap, tag ? tag : "ns1:HelloWorldResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__HelloWorldResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__HelloWorldResponse(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__HelloWorldResponse * SOAP_FMAC4 soap_get__ns1__HelloWorldResponse(struct soap *soap, _ns1__HelloWorldResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__HelloWorldResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _ns1__HelloWorld::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _ns1__HelloWorld::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _ns1__HelloWorld::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__ns1__HelloWorld(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__HelloWorld(struct soap *soap, const char *tag, int id, const _ns1__HelloWorld *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__ns1__HelloWorld), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_ns1__HelloWorld::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__ns1__HelloWorld(soap, tag, this, type);
}

SOAP_FMAC3 _ns1__HelloWorld * SOAP_FMAC4 soap_in__ns1__HelloWorld(struct soap *soap, const char *tag, _ns1__HelloWorld *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_ns1__HelloWorld *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__ns1__HelloWorld, sizeof(_ns1__HelloWorld), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__ns1__HelloWorld)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_ns1__HelloWorld *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_ns1__HelloWorld *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__ns1__HelloWorld, SOAP_TYPE__ns1__HelloWorld, sizeof(_ns1__HelloWorld), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _ns1__HelloWorld * SOAP_FMAC2 soap_instantiate__ns1__HelloWorld(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__ns1__HelloWorld(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_ns1__HelloWorld *p;
	size_t k = sizeof(_ns1__HelloWorld);
	if (n < 0)
	{	p = SOAP_NEW(_ns1__HelloWorld);
		if (p)
			((_ns1__HelloWorld*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(_ns1__HelloWorld, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((_ns1__HelloWorld*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _ns1__HelloWorld location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE__ns1__HelloWorld, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int _ns1__HelloWorld::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__ns1__HelloWorld(soap, tag ? tag : "ns1:HelloWorld", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_ns1__HelloWorld::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__ns1__HelloWorld(soap, this, tag, type);
}

SOAP_FMAC3 _ns1__HelloWorld * SOAP_FMAC4 soap_get__ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld *p, const char *tag, const char *type)
{
	if ((p = soap_in__ns1__HelloWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__LuaValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__LuaType(soap, &this->ns1__LuaValue::type);
	this->ns1__LuaValue::value = NULL;
	this->ns1__LuaValue::table = NULL;
	/* transient soap skipped */
}

void ns1__LuaValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__LuaValue::value);
	soap_serialize_PointerTons1__ArrayOfLuaValue(soap, &this->ns1__LuaValue::table);
#endif
}

int ns1__LuaValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LuaValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LuaValue(struct soap *soap, const char *tag, int id, const ns1__LuaValue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LuaValue), type))
		return soap->error;
	if (soap_out_ns1__LuaType(soap, "ns1:type", -1, &a->ns1__LuaValue::type, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:value", -1, &a->ns1__LuaValue::value, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfLuaValue(soap, "ns1:table", -1, &a->ns1__LuaValue::table, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__LuaValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LuaValue(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LuaValue * SOAP_FMAC4 soap_in_ns1__LuaValue(struct soap *soap, const char *tag, ns1__LuaValue *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LuaValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LuaValue, sizeof(ns1__LuaValue), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__LuaValue)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__LuaValue *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_type1 = 1;
	size_t soap_flag_value1 = 1;
	size_t soap_flag_table1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__LuaType(soap, "ns1:type", &a->ns1__LuaValue::type, "ns1:LuaType"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_value1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:value", &a->ns1__LuaValue::value, "xsd:string"))
				{	soap_flag_value1--;
					continue;
				}
			if (soap_flag_table1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfLuaValue(soap, "ns1:table", &a->ns1__LuaValue::table, "ns1:ArrayOfLuaValue"))
				{	soap_flag_table1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__LuaValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LuaValue, SOAP_TYPE_ns1__LuaValue, sizeof(ns1__LuaValue), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__LuaValue * SOAP_FMAC2 soap_instantiate_ns1__LuaValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LuaValue(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__LuaValue *p;
	size_t k = sizeof(ns1__LuaValue);
	if (n < 0)
	{	p = SOAP_NEW(ns1__LuaValue);
		if (p)
			((ns1__LuaValue*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__LuaValue, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__LuaValue*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__LuaValue location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__LuaValue, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__LuaValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__LuaValue(soap, tag ? tag : "ns1:LuaValue", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__LuaValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LuaValue(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LuaValue * SOAP_FMAC4 soap_get_ns1__LuaValue(struct soap *soap, ns1__LuaValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LuaValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfJob::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__Job(soap, &this->ns1__ArrayOfJob::Job);
	/* transient soap skipped */
}

void ns1__ArrayOfJob::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__Job(soap, &this->ns1__ArrayOfJob::Job);
#endif
}

int ns1__ArrayOfJob::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfJob(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfJob(struct soap *soap, const char *tag, int id, const ns1__ArrayOfJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfJob), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__Job(soap, "ns1:Job", -1, &a->ns1__ArrayOfJob::Job, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfJob::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfJob(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfJob * SOAP_FMAC4 soap_in_ns1__ArrayOfJob(struct soap *soap, const char *tag, ns1__ArrayOfJob *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfJob, sizeof(ns1__ArrayOfJob), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfJob)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfJob *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__Job(soap, "ns1:Job", &a->ns1__ArrayOfJob::Job, "ns1:Job"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfJob, SOAP_TYPE_ns1__ArrayOfJob, sizeof(ns1__ArrayOfJob), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfJob * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfJob(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfJob *p;
	size_t k = sizeof(ns1__ArrayOfJob);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfJob);
		if (p)
			((ns1__ArrayOfJob*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfJob, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfJob*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfJob location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ArrayOfJob, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfJob::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfJob(soap, tag ? tag : "ns1:ArrayOfJob", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfJob::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfJob(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfJob * SOAP_FMAC4 soap_get_ns1__ArrayOfJob(struct soap *soap, ns1__ArrayOfJob *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ArrayOfLuaValue::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__LuaValue(soap, &this->ns1__ArrayOfLuaValue::LuaValue);
	/* transient soap skipped */
}

void ns1__ArrayOfLuaValue::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTons1__LuaValue(soap, &this->ns1__ArrayOfLuaValue::LuaValue);
#endif
}

int ns1__ArrayOfLuaValue::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ArrayOfLuaValue(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ArrayOfLuaValue(struct soap *soap, const char *tag, int id, const ns1__ArrayOfLuaValue *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ArrayOfLuaValue), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__LuaValue(soap, "ns1:LuaValue", -1, &a->ns1__ArrayOfLuaValue::LuaValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ArrayOfLuaValue::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ArrayOfLuaValue(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ArrayOfLuaValue * SOAP_FMAC4 soap_in_ns1__ArrayOfLuaValue(struct soap *soap, const char *tag, ns1__ArrayOfLuaValue *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ArrayOfLuaValue *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ArrayOfLuaValue, sizeof(ns1__ArrayOfLuaValue), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ArrayOfLuaValue)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ArrayOfLuaValue *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__LuaValue(soap, "ns1:LuaValue", &a->ns1__ArrayOfLuaValue::LuaValue, "ns1:LuaValue"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ArrayOfLuaValue *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ArrayOfLuaValue, SOAP_TYPE_ns1__ArrayOfLuaValue, sizeof(ns1__ArrayOfLuaValue), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ArrayOfLuaValue * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfLuaValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ArrayOfLuaValue(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ArrayOfLuaValue *p;
	size_t k = sizeof(ns1__ArrayOfLuaValue);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ArrayOfLuaValue);
		if (p)
			((ns1__ArrayOfLuaValue*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ArrayOfLuaValue, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ArrayOfLuaValue*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ArrayOfLuaValue location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ArrayOfLuaValue, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ArrayOfLuaValue::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ArrayOfLuaValue(soap, tag ? tag : "ns1:ArrayOfLuaValue", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ArrayOfLuaValue::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ArrayOfLuaValue(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ArrayOfLuaValue * SOAP_FMAC4 soap_get_ns1__ArrayOfLuaValue(struct soap *soap, ns1__ArrayOfLuaValue *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ArrayOfLuaValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__ScriptExecution::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__ScriptExecution::name = NULL;
	this->ns1__ScriptExecution::script = NULL;
	this->ns1__ScriptExecution::arguments = NULL;
	/* transient soap skipped */
}

void ns1__ScriptExecution::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__ScriptExecution::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__ScriptExecution::script);
	soap_serialize_PointerTons1__ArrayOfLuaValue(soap, &this->ns1__ScriptExecution::arguments);
#endif
}

int ns1__ScriptExecution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ScriptExecution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScriptExecution(struct soap *soap, const char *tag, int id, const ns1__ScriptExecution *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ScriptExecution), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:name", -1, &a->ns1__ScriptExecution::name, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:script", -1, &a->ns1__ScriptExecution::script, ""))
		return soap->error;
	if (soap_out_PointerTons1__ArrayOfLuaValue(soap, "ns1:arguments", -1, &a->ns1__ScriptExecution::arguments, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__ScriptExecution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ScriptExecution(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ScriptExecution * SOAP_FMAC4 soap_in_ns1__ScriptExecution(struct soap *soap, const char *tag, ns1__ScriptExecution *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ScriptExecution *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScriptExecution, sizeof(ns1__ScriptExecution), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__ScriptExecution)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__ScriptExecution *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_name1 = 1;
	size_t soap_flag_script1 = 1;
	size_t soap_flag_arguments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:name", &a->ns1__ScriptExecution::name, "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_script1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:script", &a->ns1__ScriptExecution::script, "xsd:string"))
				{	soap_flag_script1--;
					continue;
				}
			if (soap_flag_arguments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ArrayOfLuaValue(soap, "ns1:arguments", &a->ns1__ScriptExecution::arguments, "ns1:ArrayOfLuaValue"))
				{	soap_flag_arguments1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ScriptExecution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ScriptExecution, SOAP_TYPE_ns1__ScriptExecution, sizeof(ns1__ScriptExecution), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__ScriptExecution * SOAP_FMAC2 soap_instantiate_ns1__ScriptExecution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ScriptExecution(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__ScriptExecution *p;
	size_t k = sizeof(ns1__ScriptExecution);
	if (n < 0)
	{	p = SOAP_NEW(ns1__ScriptExecution);
		if (p)
			((ns1__ScriptExecution*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__ScriptExecution, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__ScriptExecution*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__ScriptExecution location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__ScriptExecution, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__ScriptExecution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__ScriptExecution(soap, tag ? tag : "ns1:ScriptExecution", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__ScriptExecution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ScriptExecution(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ScriptExecution * SOAP_FMAC4 soap_get_ns1__ScriptExecution(struct soap *soap, ns1__ScriptExecution *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScriptExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Job::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__Job::id);
	soap_default_double(soap, &this->ns1__Job::expirationInSeconds);
	soap_default_int(soap, &this->ns1__Job::category);
	soap_default_double(soap, &this->ns1__Job::cores);
	/* transient soap skipped */
}

void ns1__Job::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->ns1__Job::id, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__Job::id);
#endif
}

int ns1__Job::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Job(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Job(struct soap *soap, const char *tag, int id, const ns1__Job *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Job), type))
		return soap->error;
	if (soap_out_std__string(soap, "ns1:id", -1, &a->ns1__Job::id, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:expirationInSeconds", -1, &a->ns1__Job::expirationInSeconds, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:category", -1, &a->ns1__Job::category, ""))
		return soap->error;
	if (soap_out_double(soap, "ns1:cores", -1, &a->ns1__Job::cores, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Job::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Job(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Job * SOAP_FMAC4 soap_in_ns1__Job(struct soap *soap, const char *tag, ns1__Job *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Job *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Job, sizeof(ns1__Job), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Job)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Job *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_id1 = 1;
	size_t soap_flag_expirationInSeconds1 = 1;
	size_t soap_flag_category1 = 1;
	size_t soap_flag_cores1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "ns1:id", &a->ns1__Job::id, "xsd:string"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_expirationInSeconds1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:expirationInSeconds", &a->ns1__Job::expirationInSeconds, "xsd:double"))
				{	soap_flag_expirationInSeconds1--;
					continue;
				}
			if (soap_flag_category1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:category", &a->ns1__Job::category, "xsd:int"))
				{	soap_flag_category1--;
					continue;
				}
			if (soap_flag_cores1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "ns1:cores", &a->ns1__Job::cores, "xsd:double"))
				{	soap_flag_cores1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_id1 > 0 || soap_flag_expirationInSeconds1 > 0 || soap_flag_category1 > 0 || soap_flag_cores1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Job *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Job, SOAP_TYPE_ns1__Job, sizeof(ns1__Job), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Job * SOAP_FMAC2 soap_instantiate_ns1__Job(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Job(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Job *p;
	size_t k = sizeof(ns1__Job);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Job);
		if (p)
			((ns1__Job*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Job, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__Job*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Job location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Job, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Job::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Job(soap, tag ? tag : "ns1:Job", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Job::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Job(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Job * SOAP_FMAC4 soap_get_ns1__Job(struct soap *soap, ns1__Job *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Job(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void ns1__Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__Status::version = NULL;
	soap_default_int(soap, &this->ns1__Status::environmentCount);
	/* transient soap skipped */
}

void ns1__Status::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostd__string(soap, &this->ns1__Status::version);
#endif
}

int ns1__Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Status(struct soap *soap, const char *tag, int id, const ns1__Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Status), type))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "ns1:version", -1, &a->ns1__Status::version, ""))
		return soap->error;
	if (soap_out_int(soap, "ns1:environmentCount", -1, &a->ns1__Status::environmentCount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__Status::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__Status(soap, tag, this, type);
}

SOAP_FMAC3 ns1__Status * SOAP_FMAC4 soap_in_ns1__Status(struct soap *soap, const char *tag, ns1__Status *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Status, sizeof(ns1__Status), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_ns1__Status)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (ns1__Status *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_version1 = 1;
	size_t soap_flag_environmentCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "ns1:version", &a->ns1__Status::version, "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_environmentCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "ns1:environmentCount", &a->ns1__Status::environmentCount, "xsd:int"))
				{	soap_flag_environmentCount1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_environmentCount1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && !*soap->href)
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (ns1__Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Status, SOAP_TYPE_ns1__Status, sizeof(ns1__Status), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns1__Status * SOAP_FMAC2 soap_instantiate_ns1__Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__Status(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	ns1__Status *p;
	size_t k = sizeof(ns1__Status);
	if (n < 0)
	{	p = SOAP_NEW(ns1__Status);
		if (p)
			((ns1__Status*)p)->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(ns1__Status, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				((ns1__Status*)p)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated ns1__Status location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_ns1__Status, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

int ns1__Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_ns1__Status(soap, tag ? tag : "ns1:Status", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__Status(soap, this, tag, type);
}

SOAP_FMAC3 ns1__Status * SOAP_FMAC4 soap_get_ns1__Status(struct soap *soap, ns1__Status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	if (n < 0)
	{	p = SOAP_NEW(struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DiagEx_(struct soap *soap, struct __ns1__DiagEx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DiagEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DiagEx_(struct soap *soap, const struct __ns1__DiagEx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DiagEx(soap, &a->ns1__DiagEx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DiagEx_(struct soap *soap, const char *tag, int id, const struct __ns1__DiagEx_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DiagEx(soap, "ns1:DiagEx", -1, &a->ns1__DiagEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DiagEx_ * SOAP_FMAC4 soap_in___ns1__DiagEx_(struct soap *soap, const char *tag, struct __ns1__DiagEx_ *a, const char *type)
{
	size_t soap_flag_ns1__DiagEx = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DiagEx_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DiagEx_, sizeof(struct __ns1__DiagEx_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DiagEx_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DiagEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DiagEx(soap, "ns1:DiagEx", &a->ns1__DiagEx, ""))
				{	soap_flag_ns1__DiagEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DiagEx_ * SOAP_FMAC2 soap_instantiate___ns1__DiagEx_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DiagEx_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DiagEx_ *p;
	size_t k = sizeof(struct __ns1__DiagEx_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DiagEx_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DiagEx_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DiagEx_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__DiagEx_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DiagEx_(struct soap *soap, const struct __ns1__DiagEx_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DiagEx_(soap, tag ? tag : "-ns1:DiagEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DiagEx_ * SOAP_FMAC4 soap_get___ns1__DiagEx_(struct soap *soap, struct __ns1__DiagEx_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DiagEx_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Diag_(struct soap *soap, struct __ns1__Diag_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Diag = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Diag_(struct soap *soap, const struct __ns1__Diag_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Diag(soap, &a->ns1__Diag);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Diag_(struct soap *soap, const char *tag, int id, const struct __ns1__Diag_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Diag(soap, "ns1:Diag", -1, &a->ns1__Diag, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Diag_ * SOAP_FMAC4 soap_in___ns1__Diag_(struct soap *soap, const char *tag, struct __ns1__Diag_ *a, const char *type)
{
	size_t soap_flag_ns1__Diag = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Diag_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Diag_, sizeof(struct __ns1__Diag_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Diag_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Diag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Diag(soap, "ns1:Diag", &a->ns1__Diag, ""))
				{	soap_flag_ns1__Diag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Diag_ * SOAP_FMAC2 soap_instantiate___ns1__Diag_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Diag_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Diag_ *p;
	size_t k = sizeof(struct __ns1__Diag_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Diag_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Diag_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Diag_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__Diag_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Diag_(struct soap *soap, const struct __ns1__Diag_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Diag_(soap, tag ? tag : "-ns1:Diag", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Diag_ * SOAP_FMAC4 soap_get___ns1__Diag_(struct soap *soap, struct __ns1__Diag_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Diag_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CloseAllJobs_(struct soap *soap, struct __ns1__CloseAllJobs_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CloseAllJobs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CloseAllJobs_(struct soap *soap, const struct __ns1__CloseAllJobs_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CloseAllJobs(soap, &a->ns1__CloseAllJobs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CloseAllJobs_(struct soap *soap, const char *tag, int id, const struct __ns1__CloseAllJobs_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CloseAllJobs(soap, "ns1:CloseAllJobs", -1, &a->ns1__CloseAllJobs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseAllJobs_ * SOAP_FMAC4 soap_in___ns1__CloseAllJobs_(struct soap *soap, const char *tag, struct __ns1__CloseAllJobs_ *a, const char *type)
{
	size_t soap_flag_ns1__CloseAllJobs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CloseAllJobs_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CloseAllJobs_, sizeof(struct __ns1__CloseAllJobs_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CloseAllJobs_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CloseAllJobs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CloseAllJobs(soap, "ns1:CloseAllJobs", &a->ns1__CloseAllJobs, ""))
				{	soap_flag_ns1__CloseAllJobs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CloseAllJobs_ * SOAP_FMAC2 soap_instantiate___ns1__CloseAllJobs_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CloseAllJobs_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CloseAllJobs_ *p;
	size_t k = sizeof(struct __ns1__CloseAllJobs_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CloseAllJobs_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CloseAllJobs_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CloseAllJobs_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CloseAllJobs_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CloseAllJobs_(struct soap *soap, const struct __ns1__CloseAllJobs_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CloseAllJobs_(soap, tag ? tag : "-ns1:CloseAllJobs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseAllJobs_ * SOAP_FMAC4 soap_get___ns1__CloseAllJobs_(struct soap *soap, struct __ns1__CloseAllJobs_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CloseAllJobs_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CloseExpiredJobs_(struct soap *soap, struct __ns1__CloseExpiredJobs_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CloseExpiredJobs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CloseExpiredJobs_(struct soap *soap, const struct __ns1__CloseExpiredJobs_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CloseExpiredJobs(soap, &a->ns1__CloseExpiredJobs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CloseExpiredJobs_(struct soap *soap, const char *tag, int id, const struct __ns1__CloseExpiredJobs_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CloseExpiredJobs(soap, "ns1:CloseExpiredJobs", -1, &a->ns1__CloseExpiredJobs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseExpiredJobs_ * SOAP_FMAC4 soap_in___ns1__CloseExpiredJobs_(struct soap *soap, const char *tag, struct __ns1__CloseExpiredJobs_ *a, const char *type)
{
	size_t soap_flag_ns1__CloseExpiredJobs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CloseExpiredJobs_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CloseExpiredJobs_, sizeof(struct __ns1__CloseExpiredJobs_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CloseExpiredJobs_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CloseExpiredJobs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CloseExpiredJobs(soap, "ns1:CloseExpiredJobs", &a->ns1__CloseExpiredJobs, ""))
				{	soap_flag_ns1__CloseExpiredJobs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CloseExpiredJobs_ * SOAP_FMAC2 soap_instantiate___ns1__CloseExpiredJobs_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CloseExpiredJobs_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CloseExpiredJobs_ *p;
	size_t k = sizeof(struct __ns1__CloseExpiredJobs_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CloseExpiredJobs_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CloseExpiredJobs_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CloseExpiredJobs_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CloseExpiredJobs_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CloseExpiredJobs_(struct soap *soap, const struct __ns1__CloseExpiredJobs_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CloseExpiredJobs_(soap, tag ? tag : "-ns1:CloseExpiredJobs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseExpiredJobs_ * SOAP_FMAC4 soap_get___ns1__CloseExpiredJobs_(struct soap *soap, struct __ns1__CloseExpiredJobs_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CloseExpiredJobs_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAllJobsEx_(struct soap *soap, struct __ns1__GetAllJobsEx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAllJobsEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAllJobsEx_(struct soap *soap, const struct __ns1__GetAllJobsEx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAllJobsEx(soap, &a->ns1__GetAllJobsEx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAllJobsEx_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAllJobsEx_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAllJobsEx(soap, "ns1:GetAllJobsEx", -1, &a->ns1__GetAllJobsEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllJobsEx_ * SOAP_FMAC4 soap_in___ns1__GetAllJobsEx_(struct soap *soap, const char *tag, struct __ns1__GetAllJobsEx_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAllJobsEx = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAllJobsEx_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAllJobsEx_, sizeof(struct __ns1__GetAllJobsEx_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAllJobsEx_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAllJobsEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAllJobsEx(soap, "ns1:GetAllJobsEx", &a->ns1__GetAllJobsEx, ""))
				{	soap_flag_ns1__GetAllJobsEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetAllJobsEx_ * SOAP_FMAC2 soap_instantiate___ns1__GetAllJobsEx_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAllJobsEx_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetAllJobsEx_ *p;
	size_t k = sizeof(struct __ns1__GetAllJobsEx_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetAllJobsEx_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetAllJobsEx_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetAllJobsEx_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetAllJobsEx_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAllJobsEx_(struct soap *soap, const struct __ns1__GetAllJobsEx_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAllJobsEx_(soap, tag ? tag : "-ns1:GetAllJobsEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllJobsEx_ * SOAP_FMAC4 soap_get___ns1__GetAllJobsEx_(struct soap *soap, struct __ns1__GetAllJobsEx_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAllJobsEx_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAllJobs_(struct soap *soap, struct __ns1__GetAllJobs_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAllJobs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAllJobs_(struct soap *soap, const struct __ns1__GetAllJobs_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAllJobs(soap, &a->ns1__GetAllJobs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAllJobs_(struct soap *soap, const char *tag, int id, const struct __ns1__GetAllJobs_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAllJobs(soap, "ns1:GetAllJobs", -1, &a->ns1__GetAllJobs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllJobs_ * SOAP_FMAC4 soap_in___ns1__GetAllJobs_(struct soap *soap, const char *tag, struct __ns1__GetAllJobs_ *a, const char *type)
{
	size_t soap_flag_ns1__GetAllJobs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAllJobs_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAllJobs_, sizeof(struct __ns1__GetAllJobs_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAllJobs_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAllJobs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAllJobs(soap, "ns1:GetAllJobs", &a->ns1__GetAllJobs, ""))
				{	soap_flag_ns1__GetAllJobs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetAllJobs_ * SOAP_FMAC2 soap_instantiate___ns1__GetAllJobs_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAllJobs_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetAllJobs_ *p;
	size_t k = sizeof(struct __ns1__GetAllJobs_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetAllJobs_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetAllJobs_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetAllJobs_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetAllJobs_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAllJobs_(struct soap *soap, const struct __ns1__GetAllJobs_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAllJobs_(soap, tag ? tag : "-ns1:GetAllJobs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllJobs_ * SOAP_FMAC4 soap_get___ns1__GetAllJobs_(struct soap *soap, struct __ns1__GetAllJobs_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAllJobs_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetExpiration_(struct soap *soap, struct __ns1__GetExpiration_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetExpiration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetExpiration_(struct soap *soap, const struct __ns1__GetExpiration_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetExpiration(soap, &a->ns1__GetExpiration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetExpiration_(struct soap *soap, const char *tag, int id, const struct __ns1__GetExpiration_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetExpiration(soap, "ns1:GetExpiration", -1, &a->ns1__GetExpiration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetExpiration_ * SOAP_FMAC4 soap_in___ns1__GetExpiration_(struct soap *soap, const char *tag, struct __ns1__GetExpiration_ *a, const char *type)
{
	size_t soap_flag_ns1__GetExpiration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetExpiration_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetExpiration_, sizeof(struct __ns1__GetExpiration_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetExpiration_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetExpiration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetExpiration(soap, "ns1:GetExpiration", &a->ns1__GetExpiration, ""))
				{	soap_flag_ns1__GetExpiration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetExpiration_ * SOAP_FMAC2 soap_instantiate___ns1__GetExpiration_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetExpiration_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetExpiration_ *p;
	size_t k = sizeof(struct __ns1__GetExpiration_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetExpiration_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetExpiration_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetExpiration_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetExpiration_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetExpiration_(struct soap *soap, const struct __ns1__GetExpiration_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetExpiration_(soap, tag ? tag : "-ns1:GetExpiration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetExpiration_ * SOAP_FMAC4 soap_get___ns1__GetExpiration_(struct soap *soap, struct __ns1__GetExpiration_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetExpiration_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BatchJobEx_(struct soap *soap, struct __ns1__BatchJobEx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BatchJobEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BatchJobEx_(struct soap *soap, const struct __ns1__BatchJobEx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BatchJobEx(soap, &a->ns1__BatchJobEx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BatchJobEx_(struct soap *soap, const char *tag, int id, const struct __ns1__BatchJobEx_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BatchJobEx(soap, "ns1:BatchJobEx", -1, &a->ns1__BatchJobEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BatchJobEx_ * SOAP_FMAC4 soap_in___ns1__BatchJobEx_(struct soap *soap, const char *tag, struct __ns1__BatchJobEx_ *a, const char *type)
{
	size_t soap_flag_ns1__BatchJobEx = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BatchJobEx_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BatchJobEx_, sizeof(struct __ns1__BatchJobEx_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BatchJobEx_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BatchJobEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BatchJobEx(soap, "ns1:BatchJobEx", &a->ns1__BatchJobEx, ""))
				{	soap_flag_ns1__BatchJobEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BatchJobEx_ * SOAP_FMAC2 soap_instantiate___ns1__BatchJobEx_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BatchJobEx_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BatchJobEx_ *p;
	size_t k = sizeof(struct __ns1__BatchJobEx_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__BatchJobEx_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__BatchJobEx_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BatchJobEx_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__BatchJobEx_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BatchJobEx_(struct soap *soap, const struct __ns1__BatchJobEx_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BatchJobEx_(soap, tag ? tag : "-ns1:BatchJobEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BatchJobEx_ * SOAP_FMAC4 soap_get___ns1__BatchJobEx_(struct soap *soap, struct __ns1__BatchJobEx_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BatchJobEx_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BatchJob_(struct soap *soap, struct __ns1__BatchJob_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BatchJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BatchJob_(struct soap *soap, const struct __ns1__BatchJob_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BatchJob(soap, &a->ns1__BatchJob);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BatchJob_(struct soap *soap, const char *tag, int id, const struct __ns1__BatchJob_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BatchJob(soap, "ns1:BatchJob", -1, &a->ns1__BatchJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BatchJob_ * SOAP_FMAC4 soap_in___ns1__BatchJob_(struct soap *soap, const char *tag, struct __ns1__BatchJob_ *a, const char *type)
{
	size_t soap_flag_ns1__BatchJob = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BatchJob_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BatchJob_, sizeof(struct __ns1__BatchJob_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BatchJob_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BatchJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BatchJob(soap, "ns1:BatchJob", &a->ns1__BatchJob, ""))
				{	soap_flag_ns1__BatchJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BatchJob_ * SOAP_FMAC2 soap_instantiate___ns1__BatchJob_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BatchJob_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BatchJob_ *p;
	size_t k = sizeof(struct __ns1__BatchJob_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__BatchJob_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__BatchJob_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BatchJob_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__BatchJob_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BatchJob_(struct soap *soap, const struct __ns1__BatchJob_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BatchJob_(soap, tag ? tag : "-ns1:BatchJob", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BatchJob_ * SOAP_FMAC4 soap_get___ns1__BatchJob_(struct soap *soap, struct __ns1__BatchJob_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BatchJob_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CloseJob_(struct soap *soap, struct __ns1__CloseJob_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CloseJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CloseJob_(struct soap *soap, const struct __ns1__CloseJob_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CloseJob(soap, &a->ns1__CloseJob);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CloseJob_(struct soap *soap, const char *tag, int id, const struct __ns1__CloseJob_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CloseJob(soap, "ns1:CloseJob", -1, &a->ns1__CloseJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseJob_ * SOAP_FMAC4 soap_in___ns1__CloseJob_(struct soap *soap, const char *tag, struct __ns1__CloseJob_ *a, const char *type)
{
	size_t soap_flag_ns1__CloseJob = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CloseJob_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CloseJob_, sizeof(struct __ns1__CloseJob_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CloseJob_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CloseJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CloseJob(soap, "ns1:CloseJob", &a->ns1__CloseJob, ""))
				{	soap_flag_ns1__CloseJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CloseJob_ * SOAP_FMAC2 soap_instantiate___ns1__CloseJob_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CloseJob_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CloseJob_ *p;
	size_t k = sizeof(struct __ns1__CloseJob_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CloseJob_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CloseJob_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CloseJob_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CloseJob_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CloseJob_(struct soap *soap, const struct __ns1__CloseJob_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CloseJob_(soap, tag ? tag : "-ns1:CloseJob", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseJob_ * SOAP_FMAC4 soap_get___ns1__CloseJob_(struct soap *soap, struct __ns1__CloseJob_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CloseJob_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExecuteEx_(struct soap *soap, struct __ns1__ExecuteEx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExecuteEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExecuteEx_(struct soap *soap, const struct __ns1__ExecuteEx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExecuteEx(soap, &a->ns1__ExecuteEx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExecuteEx_(struct soap *soap, const char *tag, int id, const struct __ns1__ExecuteEx_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExecuteEx(soap, "ns1:ExecuteEx", -1, &a->ns1__ExecuteEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteEx_ * SOAP_FMAC4 soap_in___ns1__ExecuteEx_(struct soap *soap, const char *tag, struct __ns1__ExecuteEx_ *a, const char *type)
{
	size_t soap_flag_ns1__ExecuteEx = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExecuteEx_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExecuteEx_, sizeof(struct __ns1__ExecuteEx_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExecuteEx_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExecuteEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ExecuteEx(soap, "ns1:ExecuteEx", &a->ns1__ExecuteEx, ""))
				{	soap_flag_ns1__ExecuteEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExecuteEx_ * SOAP_FMAC2 soap_instantiate___ns1__ExecuteEx_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExecuteEx_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExecuteEx_ *p;
	size_t k = sizeof(struct __ns1__ExecuteEx_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExecuteEx_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExecuteEx_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExecuteEx_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ExecuteEx_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExecuteEx_(struct soap *soap, const struct __ns1__ExecuteEx_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExecuteEx_(soap, tag ? tag : "-ns1:ExecuteEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteEx_ * SOAP_FMAC4 soap_get___ns1__ExecuteEx_(struct soap *soap, struct __ns1__ExecuteEx_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExecuteEx_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Execute_(struct soap *soap, struct __ns1__Execute_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Execute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Execute_(struct soap *soap, const struct __ns1__Execute_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Execute(soap, &a->ns1__Execute);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Execute_(struct soap *soap, const char *tag, int id, const struct __ns1__Execute_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Execute(soap, "ns1:Execute", -1, &a->ns1__Execute, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Execute_ * SOAP_FMAC4 soap_in___ns1__Execute_(struct soap *soap, const char *tag, struct __ns1__Execute_ *a, const char *type)
{
	size_t soap_flag_ns1__Execute = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Execute_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Execute_, sizeof(struct __ns1__Execute_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Execute_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Execute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Execute(soap, "ns1:Execute", &a->ns1__Execute, ""))
				{	soap_flag_ns1__Execute--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Execute_ * SOAP_FMAC2 soap_instantiate___ns1__Execute_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Execute_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Execute_ *p;
	size_t k = sizeof(struct __ns1__Execute_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Execute_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Execute_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Execute_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__Execute_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Execute_(struct soap *soap, const struct __ns1__Execute_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Execute_(soap, tag ? tag : "-ns1:Execute", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Execute_ * SOAP_FMAC4 soap_get___ns1__Execute_(struct soap *soap, struct __ns1__Execute_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Execute_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RenewLease_(struct soap *soap, struct __ns1__RenewLease_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RenewLease = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RenewLease_(struct soap *soap, const struct __ns1__RenewLease_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RenewLease(soap, &a->ns1__RenewLease);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RenewLease_(struct soap *soap, const char *tag, int id, const struct __ns1__RenewLease_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RenewLease(soap, "ns1:RenewLease", -1, &a->ns1__RenewLease, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RenewLease_ * SOAP_FMAC4 soap_in___ns1__RenewLease_(struct soap *soap, const char *tag, struct __ns1__RenewLease_ *a, const char *type)
{
	size_t soap_flag_ns1__RenewLease = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__RenewLease_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RenewLease_, sizeof(struct __ns1__RenewLease_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RenewLease_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RenewLease && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RenewLease(soap, "ns1:RenewLease", &a->ns1__RenewLease, ""))
				{	soap_flag_ns1__RenewLease--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__RenewLease_ * SOAP_FMAC2 soap_instantiate___ns1__RenewLease_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RenewLease_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__RenewLease_ *p;
	size_t k = sizeof(struct __ns1__RenewLease_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__RenewLease_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__RenewLease_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__RenewLease_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__RenewLease_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RenewLease_(struct soap *soap, const struct __ns1__RenewLease_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__RenewLease_(soap, tag ? tag : "-ns1:RenewLease", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RenewLease_ * SOAP_FMAC4 soap_get___ns1__RenewLease_(struct soap *soap, struct __ns1__RenewLease_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RenewLease_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OpenJobEx_(struct soap *soap, struct __ns1__OpenJobEx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OpenJobEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OpenJobEx_(struct soap *soap, const struct __ns1__OpenJobEx_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OpenJobEx(soap, &a->ns1__OpenJobEx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OpenJobEx_(struct soap *soap, const char *tag, int id, const struct __ns1__OpenJobEx_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OpenJobEx(soap, "ns1:OpenJobEx", -1, &a->ns1__OpenJobEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenJobEx_ * SOAP_FMAC4 soap_in___ns1__OpenJobEx_(struct soap *soap, const char *tag, struct __ns1__OpenJobEx_ *a, const char *type)
{
	size_t soap_flag_ns1__OpenJobEx = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OpenJobEx_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OpenJobEx_, sizeof(struct __ns1__OpenJobEx_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OpenJobEx_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OpenJobEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OpenJobEx(soap, "ns1:OpenJobEx", &a->ns1__OpenJobEx, ""))
				{	soap_flag_ns1__OpenJobEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OpenJobEx_ * SOAP_FMAC2 soap_instantiate___ns1__OpenJobEx_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OpenJobEx_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OpenJobEx_ *p;
	size_t k = sizeof(struct __ns1__OpenJobEx_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__OpenJobEx_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__OpenJobEx_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OpenJobEx_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__OpenJobEx_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OpenJobEx_(struct soap *soap, const struct __ns1__OpenJobEx_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OpenJobEx_(soap, tag ? tag : "-ns1:OpenJobEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenJobEx_ * SOAP_FMAC4 soap_get___ns1__OpenJobEx_(struct soap *soap, struct __ns1__OpenJobEx_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OpenJobEx_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OpenJob_(struct soap *soap, struct __ns1__OpenJob_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OpenJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OpenJob_(struct soap *soap, const struct __ns1__OpenJob_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OpenJob(soap, &a->ns1__OpenJob);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OpenJob_(struct soap *soap, const char *tag, int id, const struct __ns1__OpenJob_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OpenJob(soap, "ns1:OpenJob", -1, &a->ns1__OpenJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenJob_ * SOAP_FMAC4 soap_in___ns1__OpenJob_(struct soap *soap, const char *tag, struct __ns1__OpenJob_ *a, const char *type)
{
	size_t soap_flag_ns1__OpenJob = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OpenJob_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OpenJob_, sizeof(struct __ns1__OpenJob_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OpenJob_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OpenJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OpenJob(soap, "ns1:OpenJob", &a->ns1__OpenJob, ""))
				{	soap_flag_ns1__OpenJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OpenJob_ * SOAP_FMAC2 soap_instantiate___ns1__OpenJob_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OpenJob_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OpenJob_ *p;
	size_t k = sizeof(struct __ns1__OpenJob_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__OpenJob_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__OpenJob_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OpenJob_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__OpenJob_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OpenJob_(struct soap *soap, const struct __ns1__OpenJob_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OpenJob_(soap, tag ? tag : "-ns1:OpenJob", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenJob_ * SOAP_FMAC4 soap_get___ns1__OpenJob_(struct soap *soap, struct __ns1__OpenJob_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OpenJob_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStatus_(struct soap *soap, struct __ns1__GetStatus_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStatus_(struct soap *soap, const struct __ns1__GetStatus_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetStatus(soap, &a->ns1__GetStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStatus_(struct soap *soap, const char *tag, int id, const struct __ns1__GetStatus_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetStatus(soap, "ns1:GetStatus", -1, &a->ns1__GetStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStatus_ * SOAP_FMAC4 soap_in___ns1__GetStatus_(struct soap *soap, const char *tag, struct __ns1__GetStatus_ *a, const char *type)
{
	size_t soap_flag_ns1__GetStatus = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetStatus_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetStatus_, sizeof(struct __ns1__GetStatus_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStatus_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetStatus(soap, "ns1:GetStatus", &a->ns1__GetStatus, ""))
				{	soap_flag_ns1__GetStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetStatus_ * SOAP_FMAC2 soap_instantiate___ns1__GetStatus_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetStatus_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetStatus_ *p;
	size_t k = sizeof(struct __ns1__GetStatus_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetStatus_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetStatus_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetStatus_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetStatus_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStatus_(struct soap *soap, const struct __ns1__GetStatus_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetStatus_(soap, tag ? tag : "-ns1:GetStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStatus_ * SOAP_FMAC4 soap_get___ns1__GetStatus_(struct soap *soap, struct __ns1__GetStatus_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStatus_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetVersion_(struct soap *soap, struct __ns1__GetVersion_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetVersion_(struct soap *soap, const struct __ns1__GetVersion_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetVersion(soap, &a->ns1__GetVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetVersion_(struct soap *soap, const char *tag, int id, const struct __ns1__GetVersion_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetVersion(soap, "ns1:GetVersion", -1, &a->ns1__GetVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVersion_ * SOAP_FMAC4 soap_in___ns1__GetVersion_(struct soap *soap, const char *tag, struct __ns1__GetVersion_ *a, const char *type)
{
	size_t soap_flag_ns1__GetVersion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetVersion_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetVersion_, sizeof(struct __ns1__GetVersion_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetVersion_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetVersion(soap, "ns1:GetVersion", &a->ns1__GetVersion, ""))
				{	soap_flag_ns1__GetVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetVersion_ * SOAP_FMAC2 soap_instantiate___ns1__GetVersion_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetVersion_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetVersion_ *p;
	size_t k = sizeof(struct __ns1__GetVersion_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetVersion_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetVersion_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetVersion_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetVersion_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetVersion_(struct soap *soap, const struct __ns1__GetVersion_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetVersion_(soap, tag ? tag : "-ns1:GetVersion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVersion_ * SOAP_FMAC4 soap_get___ns1__GetVersion_(struct soap *soap, struct __ns1__GetVersion_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetVersion_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__HelloWorld_(struct soap *soap, struct __ns1__HelloWorld_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__HelloWorld = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__HelloWorld_(struct soap *soap, const struct __ns1__HelloWorld_ *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__HelloWorld(soap, &a->ns1__HelloWorld);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__HelloWorld_(struct soap *soap, const char *tag, int id, const struct __ns1__HelloWorld_ *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", -1, &a->ns1__HelloWorld, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HelloWorld_ * SOAP_FMAC4 soap_in___ns1__HelloWorld_(struct soap *soap, const char *tag, struct __ns1__HelloWorld_ *a, const char *type)
{
	size_t soap_flag_ns1__HelloWorld = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__HelloWorld_ *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__HelloWorld_, sizeof(struct __ns1__HelloWorld_), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__HelloWorld_(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__HelloWorld && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", &a->ns1__HelloWorld, ""))
				{	soap_flag_ns1__HelloWorld--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__HelloWorld_ * SOAP_FMAC2 soap_instantiate___ns1__HelloWorld_(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__HelloWorld_(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__HelloWorld_ *p;
	size_t k = sizeof(struct __ns1__HelloWorld_);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__HelloWorld_);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__HelloWorld_, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__HelloWorld_ location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__HelloWorld_, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__HelloWorld_(struct soap *soap, const struct __ns1__HelloWorld_ *a, const char *tag, const char *type)
{
	if (soap_out___ns1__HelloWorld_(soap, tag ? tag : "-ns1:HelloWorld", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HelloWorld_ * SOAP_FMAC4 soap_get___ns1__HelloWorld_(struct soap *soap, struct __ns1__HelloWorld_ *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__HelloWorld_(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__DiagEx(struct soap *soap, struct __ns1__DiagEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__DiagEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__DiagEx(struct soap *soap, const struct __ns1__DiagEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__DiagEx(soap, &a->ns1__DiagEx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__DiagEx(struct soap *soap, const char *tag, int id, const struct __ns1__DiagEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__DiagEx(soap, "ns1:DiagEx", -1, &a->ns1__DiagEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DiagEx * SOAP_FMAC4 soap_in___ns1__DiagEx(struct soap *soap, const char *tag, struct __ns1__DiagEx *a, const char *type)
{
	size_t soap_flag_ns1__DiagEx = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__DiagEx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__DiagEx, sizeof(struct __ns1__DiagEx), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__DiagEx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__DiagEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__DiagEx(soap, "ns1:DiagEx", &a->ns1__DiagEx, ""))
				{	soap_flag_ns1__DiagEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__DiagEx * SOAP_FMAC2 soap_instantiate___ns1__DiagEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__DiagEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__DiagEx *p;
	size_t k = sizeof(struct __ns1__DiagEx);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__DiagEx);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__DiagEx, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__DiagEx location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__DiagEx, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__DiagEx(struct soap *soap, const struct __ns1__DiagEx *a, const char *tag, const char *type)
{
	if (soap_out___ns1__DiagEx(soap, tag ? tag : "-ns1:DiagEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__DiagEx * SOAP_FMAC4 soap_get___ns1__DiagEx(struct soap *soap, struct __ns1__DiagEx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__DiagEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Diag(struct soap *soap, struct __ns1__Diag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Diag = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Diag(struct soap *soap, const struct __ns1__Diag *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Diag(soap, &a->ns1__Diag);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Diag(struct soap *soap, const char *tag, int id, const struct __ns1__Diag *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Diag(soap, "ns1:Diag", -1, &a->ns1__Diag, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Diag * SOAP_FMAC4 soap_in___ns1__Diag(struct soap *soap, const char *tag, struct __ns1__Diag *a, const char *type)
{
	size_t soap_flag_ns1__Diag = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Diag *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Diag, sizeof(struct __ns1__Diag), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Diag(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Diag && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Diag(soap, "ns1:Diag", &a->ns1__Diag, ""))
				{	soap_flag_ns1__Diag--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Diag * SOAP_FMAC2 soap_instantiate___ns1__Diag(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Diag(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Diag *p;
	size_t k = sizeof(struct __ns1__Diag);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Diag);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Diag, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Diag location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__Diag, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Diag(struct soap *soap, const struct __ns1__Diag *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Diag(soap, tag ? tag : "-ns1:Diag", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Diag * SOAP_FMAC4 soap_get___ns1__Diag(struct soap *soap, struct __ns1__Diag *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Diag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CloseAllJobs(struct soap *soap, struct __ns1__CloseAllJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CloseAllJobs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CloseAllJobs(struct soap *soap, const struct __ns1__CloseAllJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CloseAllJobs(soap, &a->ns1__CloseAllJobs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CloseAllJobs(struct soap *soap, const char *tag, int id, const struct __ns1__CloseAllJobs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CloseAllJobs(soap, "ns1:CloseAllJobs", -1, &a->ns1__CloseAllJobs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseAllJobs * SOAP_FMAC4 soap_in___ns1__CloseAllJobs(struct soap *soap, const char *tag, struct __ns1__CloseAllJobs *a, const char *type)
{
	size_t soap_flag_ns1__CloseAllJobs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CloseAllJobs *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CloseAllJobs, sizeof(struct __ns1__CloseAllJobs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CloseAllJobs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CloseAllJobs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CloseAllJobs(soap, "ns1:CloseAllJobs", &a->ns1__CloseAllJobs, ""))
				{	soap_flag_ns1__CloseAllJobs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CloseAllJobs * SOAP_FMAC2 soap_instantiate___ns1__CloseAllJobs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CloseAllJobs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CloseAllJobs *p;
	size_t k = sizeof(struct __ns1__CloseAllJobs);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CloseAllJobs);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CloseAllJobs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CloseAllJobs location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CloseAllJobs, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CloseAllJobs(struct soap *soap, const struct __ns1__CloseAllJobs *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CloseAllJobs(soap, tag ? tag : "-ns1:CloseAllJobs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseAllJobs * SOAP_FMAC4 soap_get___ns1__CloseAllJobs(struct soap *soap, struct __ns1__CloseAllJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CloseAllJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CloseExpiredJobs(struct soap *soap, struct __ns1__CloseExpiredJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CloseExpiredJobs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CloseExpiredJobs(struct soap *soap, const struct __ns1__CloseExpiredJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CloseExpiredJobs(soap, &a->ns1__CloseExpiredJobs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CloseExpiredJobs(struct soap *soap, const char *tag, int id, const struct __ns1__CloseExpiredJobs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CloseExpiredJobs(soap, "ns1:CloseExpiredJobs", -1, &a->ns1__CloseExpiredJobs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseExpiredJobs * SOAP_FMAC4 soap_in___ns1__CloseExpiredJobs(struct soap *soap, const char *tag, struct __ns1__CloseExpiredJobs *a, const char *type)
{
	size_t soap_flag_ns1__CloseExpiredJobs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CloseExpiredJobs *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CloseExpiredJobs, sizeof(struct __ns1__CloseExpiredJobs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CloseExpiredJobs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CloseExpiredJobs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CloseExpiredJobs(soap, "ns1:CloseExpiredJobs", &a->ns1__CloseExpiredJobs, ""))
				{	soap_flag_ns1__CloseExpiredJobs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CloseExpiredJobs * SOAP_FMAC2 soap_instantiate___ns1__CloseExpiredJobs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CloseExpiredJobs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CloseExpiredJobs *p;
	size_t k = sizeof(struct __ns1__CloseExpiredJobs);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CloseExpiredJobs);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CloseExpiredJobs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CloseExpiredJobs location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CloseExpiredJobs, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CloseExpiredJobs(struct soap *soap, const struct __ns1__CloseExpiredJobs *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CloseExpiredJobs(soap, tag ? tag : "-ns1:CloseExpiredJobs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseExpiredJobs * SOAP_FMAC4 soap_get___ns1__CloseExpiredJobs(struct soap *soap, struct __ns1__CloseExpiredJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CloseExpiredJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAllJobsEx(struct soap *soap, struct __ns1__GetAllJobsEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAllJobsEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAllJobsEx(struct soap *soap, const struct __ns1__GetAllJobsEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAllJobsEx(soap, &a->ns1__GetAllJobsEx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAllJobsEx(struct soap *soap, const char *tag, int id, const struct __ns1__GetAllJobsEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAllJobsEx(soap, "ns1:GetAllJobsEx", -1, &a->ns1__GetAllJobsEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllJobsEx * SOAP_FMAC4 soap_in___ns1__GetAllJobsEx(struct soap *soap, const char *tag, struct __ns1__GetAllJobsEx *a, const char *type)
{
	size_t soap_flag_ns1__GetAllJobsEx = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAllJobsEx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAllJobsEx, sizeof(struct __ns1__GetAllJobsEx), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAllJobsEx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAllJobsEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAllJobsEx(soap, "ns1:GetAllJobsEx", &a->ns1__GetAllJobsEx, ""))
				{	soap_flag_ns1__GetAllJobsEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetAllJobsEx * SOAP_FMAC2 soap_instantiate___ns1__GetAllJobsEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAllJobsEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetAllJobsEx *p;
	size_t k = sizeof(struct __ns1__GetAllJobsEx);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetAllJobsEx);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetAllJobsEx, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetAllJobsEx location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetAllJobsEx, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAllJobsEx(struct soap *soap, const struct __ns1__GetAllJobsEx *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAllJobsEx(soap, tag ? tag : "-ns1:GetAllJobsEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllJobsEx * SOAP_FMAC4 soap_get___ns1__GetAllJobsEx(struct soap *soap, struct __ns1__GetAllJobsEx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAllJobsEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetAllJobs(struct soap *soap, struct __ns1__GetAllJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetAllJobs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetAllJobs(struct soap *soap, const struct __ns1__GetAllJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetAllJobs(soap, &a->ns1__GetAllJobs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetAllJobs(struct soap *soap, const char *tag, int id, const struct __ns1__GetAllJobs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetAllJobs(soap, "ns1:GetAllJobs", -1, &a->ns1__GetAllJobs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllJobs * SOAP_FMAC4 soap_in___ns1__GetAllJobs(struct soap *soap, const char *tag, struct __ns1__GetAllJobs *a, const char *type)
{
	size_t soap_flag_ns1__GetAllJobs = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetAllJobs *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetAllJobs, sizeof(struct __ns1__GetAllJobs), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetAllJobs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetAllJobs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetAllJobs(soap, "ns1:GetAllJobs", &a->ns1__GetAllJobs, ""))
				{	soap_flag_ns1__GetAllJobs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetAllJobs * SOAP_FMAC2 soap_instantiate___ns1__GetAllJobs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetAllJobs(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetAllJobs *p;
	size_t k = sizeof(struct __ns1__GetAllJobs);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetAllJobs);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetAllJobs, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetAllJobs location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetAllJobs, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetAllJobs(struct soap *soap, const struct __ns1__GetAllJobs *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetAllJobs(soap, tag ? tag : "-ns1:GetAllJobs", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetAllJobs * SOAP_FMAC4 soap_get___ns1__GetAllJobs(struct soap *soap, struct __ns1__GetAllJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetAllJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetExpiration(struct soap *soap, struct __ns1__GetExpiration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetExpiration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetExpiration(struct soap *soap, const struct __ns1__GetExpiration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetExpiration(soap, &a->ns1__GetExpiration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetExpiration(struct soap *soap, const char *tag, int id, const struct __ns1__GetExpiration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetExpiration(soap, "ns1:GetExpiration", -1, &a->ns1__GetExpiration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetExpiration * SOAP_FMAC4 soap_in___ns1__GetExpiration(struct soap *soap, const char *tag, struct __ns1__GetExpiration *a, const char *type)
{
	size_t soap_flag_ns1__GetExpiration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetExpiration *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetExpiration, sizeof(struct __ns1__GetExpiration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetExpiration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetExpiration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetExpiration(soap, "ns1:GetExpiration", &a->ns1__GetExpiration, ""))
				{	soap_flag_ns1__GetExpiration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetExpiration * SOAP_FMAC2 soap_instantiate___ns1__GetExpiration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetExpiration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetExpiration *p;
	size_t k = sizeof(struct __ns1__GetExpiration);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetExpiration);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetExpiration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetExpiration location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetExpiration, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetExpiration(struct soap *soap, const struct __ns1__GetExpiration *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetExpiration(soap, tag ? tag : "-ns1:GetExpiration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetExpiration * SOAP_FMAC4 soap_get___ns1__GetExpiration(struct soap *soap, struct __ns1__GetExpiration *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetExpiration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BatchJobEx(struct soap *soap, struct __ns1__BatchJobEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BatchJobEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BatchJobEx(struct soap *soap, const struct __ns1__BatchJobEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BatchJobEx(soap, &a->ns1__BatchJobEx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BatchJobEx(struct soap *soap, const char *tag, int id, const struct __ns1__BatchJobEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BatchJobEx(soap, "ns1:BatchJobEx", -1, &a->ns1__BatchJobEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BatchJobEx * SOAP_FMAC4 soap_in___ns1__BatchJobEx(struct soap *soap, const char *tag, struct __ns1__BatchJobEx *a, const char *type)
{
	size_t soap_flag_ns1__BatchJobEx = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BatchJobEx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BatchJobEx, sizeof(struct __ns1__BatchJobEx), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BatchJobEx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BatchJobEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BatchJobEx(soap, "ns1:BatchJobEx", &a->ns1__BatchJobEx, ""))
				{	soap_flag_ns1__BatchJobEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BatchJobEx * SOAP_FMAC2 soap_instantiate___ns1__BatchJobEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BatchJobEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BatchJobEx *p;
	size_t k = sizeof(struct __ns1__BatchJobEx);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__BatchJobEx);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__BatchJobEx, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BatchJobEx location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__BatchJobEx, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BatchJobEx(struct soap *soap, const struct __ns1__BatchJobEx *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BatchJobEx(soap, tag ? tag : "-ns1:BatchJobEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BatchJobEx * SOAP_FMAC4 soap_get___ns1__BatchJobEx(struct soap *soap, struct __ns1__BatchJobEx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BatchJobEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__BatchJob(struct soap *soap, struct __ns1__BatchJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__BatchJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__BatchJob(struct soap *soap, const struct __ns1__BatchJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__BatchJob(soap, &a->ns1__BatchJob);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__BatchJob(struct soap *soap, const char *tag, int id, const struct __ns1__BatchJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__BatchJob(soap, "ns1:BatchJob", -1, &a->ns1__BatchJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BatchJob * SOAP_FMAC4 soap_in___ns1__BatchJob(struct soap *soap, const char *tag, struct __ns1__BatchJob *a, const char *type)
{
	size_t soap_flag_ns1__BatchJob = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__BatchJob *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__BatchJob, sizeof(struct __ns1__BatchJob), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__BatchJob(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__BatchJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__BatchJob(soap, "ns1:BatchJob", &a->ns1__BatchJob, ""))
				{	soap_flag_ns1__BatchJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__BatchJob * SOAP_FMAC2 soap_instantiate___ns1__BatchJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__BatchJob(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__BatchJob *p;
	size_t k = sizeof(struct __ns1__BatchJob);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__BatchJob);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__BatchJob, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__BatchJob location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__BatchJob, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__BatchJob(struct soap *soap, const struct __ns1__BatchJob *a, const char *tag, const char *type)
{
	if (soap_out___ns1__BatchJob(soap, tag ? tag : "-ns1:BatchJob", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__BatchJob * SOAP_FMAC4 soap_get___ns1__BatchJob(struct soap *soap, struct __ns1__BatchJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__BatchJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__CloseJob(struct soap *soap, struct __ns1__CloseJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__CloseJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__CloseJob(struct soap *soap, const struct __ns1__CloseJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__CloseJob(soap, &a->ns1__CloseJob);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__CloseJob(struct soap *soap, const char *tag, int id, const struct __ns1__CloseJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__CloseJob(soap, "ns1:CloseJob", -1, &a->ns1__CloseJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseJob * SOAP_FMAC4 soap_in___ns1__CloseJob(struct soap *soap, const char *tag, struct __ns1__CloseJob *a, const char *type)
{
	size_t soap_flag_ns1__CloseJob = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__CloseJob *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__CloseJob, sizeof(struct __ns1__CloseJob), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__CloseJob(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__CloseJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__CloseJob(soap, "ns1:CloseJob", &a->ns1__CloseJob, ""))
				{	soap_flag_ns1__CloseJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__CloseJob * SOAP_FMAC2 soap_instantiate___ns1__CloseJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__CloseJob(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__CloseJob *p;
	size_t k = sizeof(struct __ns1__CloseJob);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__CloseJob);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__CloseJob, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__CloseJob location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__CloseJob, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__CloseJob(struct soap *soap, const struct __ns1__CloseJob *a, const char *tag, const char *type)
{
	if (soap_out___ns1__CloseJob(soap, tag ? tag : "-ns1:CloseJob", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__CloseJob * SOAP_FMAC4 soap_get___ns1__CloseJob(struct soap *soap, struct __ns1__CloseJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__CloseJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__ExecuteEx(struct soap *soap, struct __ns1__ExecuteEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__ExecuteEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__ExecuteEx(struct soap *soap, const struct __ns1__ExecuteEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__ExecuteEx(soap, &a->ns1__ExecuteEx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__ExecuteEx(struct soap *soap, const char *tag, int id, const struct __ns1__ExecuteEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__ExecuteEx(soap, "ns1:ExecuteEx", -1, &a->ns1__ExecuteEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteEx * SOAP_FMAC4 soap_in___ns1__ExecuteEx(struct soap *soap, const char *tag, struct __ns1__ExecuteEx *a, const char *type)
{
	size_t soap_flag_ns1__ExecuteEx = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__ExecuteEx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__ExecuteEx, sizeof(struct __ns1__ExecuteEx), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__ExecuteEx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__ExecuteEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__ExecuteEx(soap, "ns1:ExecuteEx", &a->ns1__ExecuteEx, ""))
				{	soap_flag_ns1__ExecuteEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__ExecuteEx * SOAP_FMAC2 soap_instantiate___ns1__ExecuteEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__ExecuteEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__ExecuteEx *p;
	size_t k = sizeof(struct __ns1__ExecuteEx);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__ExecuteEx);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__ExecuteEx, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__ExecuteEx location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__ExecuteEx, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__ExecuteEx(struct soap *soap, const struct __ns1__ExecuteEx *a, const char *tag, const char *type)
{
	if (soap_out___ns1__ExecuteEx(soap, tag ? tag : "-ns1:ExecuteEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__ExecuteEx * SOAP_FMAC4 soap_get___ns1__ExecuteEx(struct soap *soap, struct __ns1__ExecuteEx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__ExecuteEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__Execute(struct soap *soap, struct __ns1__Execute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__Execute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__Execute(struct soap *soap, const struct __ns1__Execute *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__Execute(soap, &a->ns1__Execute);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__Execute(struct soap *soap, const char *tag, int id, const struct __ns1__Execute *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__Execute(soap, "ns1:Execute", -1, &a->ns1__Execute, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Execute * SOAP_FMAC4 soap_in___ns1__Execute(struct soap *soap, const char *tag, struct __ns1__Execute *a, const char *type)
{
	size_t soap_flag_ns1__Execute = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__Execute *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__Execute, sizeof(struct __ns1__Execute), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__Execute(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__Execute && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__Execute(soap, "ns1:Execute", &a->ns1__Execute, ""))
				{	soap_flag_ns1__Execute--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__Execute * SOAP_FMAC2 soap_instantiate___ns1__Execute(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__Execute(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__Execute *p;
	size_t k = sizeof(struct __ns1__Execute);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__Execute);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__Execute, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__Execute location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__Execute, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__Execute(struct soap *soap, const struct __ns1__Execute *a, const char *tag, const char *type)
{
	if (soap_out___ns1__Execute(soap, tag ? tag : "-ns1:Execute", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__Execute * SOAP_FMAC4 soap_get___ns1__Execute(struct soap *soap, struct __ns1__Execute *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__Execute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__RenewLease(struct soap *soap, struct __ns1__RenewLease *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__RenewLease = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__RenewLease(struct soap *soap, const struct __ns1__RenewLease *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__RenewLease(soap, &a->ns1__RenewLease);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__RenewLease(struct soap *soap, const char *tag, int id, const struct __ns1__RenewLease *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__RenewLease(soap, "ns1:RenewLease", -1, &a->ns1__RenewLease, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RenewLease * SOAP_FMAC4 soap_in___ns1__RenewLease(struct soap *soap, const char *tag, struct __ns1__RenewLease *a, const char *type)
{
	size_t soap_flag_ns1__RenewLease = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__RenewLease *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__RenewLease, sizeof(struct __ns1__RenewLease), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__RenewLease(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__RenewLease && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__RenewLease(soap, "ns1:RenewLease", &a->ns1__RenewLease, ""))
				{	soap_flag_ns1__RenewLease--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__RenewLease * SOAP_FMAC2 soap_instantiate___ns1__RenewLease(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__RenewLease(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__RenewLease *p;
	size_t k = sizeof(struct __ns1__RenewLease);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__RenewLease);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__RenewLease, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__RenewLease location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__RenewLease, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__RenewLease(struct soap *soap, const struct __ns1__RenewLease *a, const char *tag, const char *type)
{
	if (soap_out___ns1__RenewLease(soap, tag ? tag : "-ns1:RenewLease", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__RenewLease * SOAP_FMAC4 soap_get___ns1__RenewLease(struct soap *soap, struct __ns1__RenewLease *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__RenewLease(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OpenJobEx(struct soap *soap, struct __ns1__OpenJobEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OpenJobEx = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OpenJobEx(struct soap *soap, const struct __ns1__OpenJobEx *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OpenJobEx(soap, &a->ns1__OpenJobEx);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OpenJobEx(struct soap *soap, const char *tag, int id, const struct __ns1__OpenJobEx *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OpenJobEx(soap, "ns1:OpenJobEx", -1, &a->ns1__OpenJobEx, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenJobEx * SOAP_FMAC4 soap_in___ns1__OpenJobEx(struct soap *soap, const char *tag, struct __ns1__OpenJobEx *a, const char *type)
{
	size_t soap_flag_ns1__OpenJobEx = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OpenJobEx *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OpenJobEx, sizeof(struct __ns1__OpenJobEx), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OpenJobEx(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OpenJobEx && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OpenJobEx(soap, "ns1:OpenJobEx", &a->ns1__OpenJobEx, ""))
				{	soap_flag_ns1__OpenJobEx--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OpenJobEx * SOAP_FMAC2 soap_instantiate___ns1__OpenJobEx(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OpenJobEx(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OpenJobEx *p;
	size_t k = sizeof(struct __ns1__OpenJobEx);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__OpenJobEx);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__OpenJobEx, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OpenJobEx location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__OpenJobEx, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OpenJobEx(struct soap *soap, const struct __ns1__OpenJobEx *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OpenJobEx(soap, tag ? tag : "-ns1:OpenJobEx", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenJobEx * SOAP_FMAC4 soap_get___ns1__OpenJobEx(struct soap *soap, struct __ns1__OpenJobEx *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OpenJobEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__OpenJob(struct soap *soap, struct __ns1__OpenJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__OpenJob = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__OpenJob(struct soap *soap, const struct __ns1__OpenJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__OpenJob(soap, &a->ns1__OpenJob);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__OpenJob(struct soap *soap, const char *tag, int id, const struct __ns1__OpenJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__OpenJob(soap, "ns1:OpenJob", -1, &a->ns1__OpenJob, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenJob * SOAP_FMAC4 soap_in___ns1__OpenJob(struct soap *soap, const char *tag, struct __ns1__OpenJob *a, const char *type)
{
	size_t soap_flag_ns1__OpenJob = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__OpenJob *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__OpenJob, sizeof(struct __ns1__OpenJob), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__OpenJob(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__OpenJob && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__OpenJob(soap, "ns1:OpenJob", &a->ns1__OpenJob, ""))
				{	soap_flag_ns1__OpenJob--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__OpenJob * SOAP_FMAC2 soap_instantiate___ns1__OpenJob(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__OpenJob(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__OpenJob *p;
	size_t k = sizeof(struct __ns1__OpenJob);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__OpenJob);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__OpenJob, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__OpenJob location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__OpenJob, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__OpenJob(struct soap *soap, const struct __ns1__OpenJob *a, const char *tag, const char *type)
{
	if (soap_out___ns1__OpenJob(soap, tag ? tag : "-ns1:OpenJob", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__OpenJob * SOAP_FMAC4 soap_get___ns1__OpenJob(struct soap *soap, struct __ns1__OpenJob *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__OpenJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetStatus(struct soap *soap, struct __ns1__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetStatus(struct soap *soap, const struct __ns1__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetStatus(soap, &a->ns1__GetStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetStatus(struct soap *soap, const char *tag, int id, const struct __ns1__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetStatus(soap, "ns1:GetStatus", -1, &a->ns1__GetStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStatus * SOAP_FMAC4 soap_in___ns1__GetStatus(struct soap *soap, const char *tag, struct __ns1__GetStatus *a, const char *type)
{
	size_t soap_flag_ns1__GetStatus = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetStatus, sizeof(struct __ns1__GetStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetStatus(soap, "ns1:GetStatus", &a->ns1__GetStatus, ""))
				{	soap_flag_ns1__GetStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetStatus * SOAP_FMAC2 soap_instantiate___ns1__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetStatus *p;
	size_t k = sizeof(struct __ns1__GetStatus);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetStatus location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetStatus, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetStatus(struct soap *soap, const struct __ns1__GetStatus *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetStatus(soap, tag ? tag : "-ns1:GetStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetStatus * SOAP_FMAC4 soap_get___ns1__GetStatus(struct soap *soap, struct __ns1__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__GetVersion(struct soap *soap, struct __ns1__GetVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__GetVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__GetVersion(struct soap *soap, const struct __ns1__GetVersion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__GetVersion(soap, &a->ns1__GetVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__GetVersion(struct soap *soap, const char *tag, int id, const struct __ns1__GetVersion *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__GetVersion(soap, "ns1:GetVersion", -1, &a->ns1__GetVersion, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVersion * SOAP_FMAC4 soap_in___ns1__GetVersion(struct soap *soap, const char *tag, struct __ns1__GetVersion *a, const char *type)
{
	size_t soap_flag_ns1__GetVersion = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__GetVersion *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__GetVersion, sizeof(struct __ns1__GetVersion), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__GetVersion(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__GetVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__GetVersion(soap, "ns1:GetVersion", &a->ns1__GetVersion, ""))
				{	soap_flag_ns1__GetVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__GetVersion * SOAP_FMAC2 soap_instantiate___ns1__GetVersion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__GetVersion(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__GetVersion *p;
	size_t k = sizeof(struct __ns1__GetVersion);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__GetVersion);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__GetVersion, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__GetVersion location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__GetVersion, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__GetVersion(struct soap *soap, const struct __ns1__GetVersion *a, const char *tag, const char *type)
{
	if (soap_out___ns1__GetVersion(soap, tag ? tag : "-ns1:GetVersion", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__GetVersion * SOAP_FMAC4 soap_get___ns1__GetVersion(struct soap *soap, struct __ns1__GetVersion *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__GetVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__HelloWorld(struct soap *soap, struct __ns1__HelloWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__HelloWorld = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__HelloWorld(struct soap *soap, const struct __ns1__HelloWorld *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_ns1__HelloWorld(soap, &a->ns1__HelloWorld);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__HelloWorld(struct soap *soap, const char *tag, int id, const struct __ns1__HelloWorld *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", -1, &a->ns1__HelloWorld, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HelloWorld * SOAP_FMAC4 soap_in___ns1__HelloWorld(struct soap *soap, const char *tag, struct __ns1__HelloWorld *a, const char *type)
{
	size_t soap_flag_ns1__HelloWorld = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __ns1__HelloWorld *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__HelloWorld, sizeof(struct __ns1__HelloWorld), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__HelloWorld(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__HelloWorld && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ns1__HelloWorld(soap, "ns1:HelloWorld", &a->ns1__HelloWorld, ""))
				{	soap_flag_ns1__HelloWorld--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __ns1__HelloWorld * SOAP_FMAC2 soap_instantiate___ns1__HelloWorld(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__HelloWorld(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __ns1__HelloWorld *p;
	size_t k = sizeof(struct __ns1__HelloWorld);
	if (n < 0)
	{	p = SOAP_NEW(struct __ns1__HelloWorld);
	}
	else
	{	p = SOAP_NEW_ARRAY(struct __ns1__HelloWorld, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __ns1__HelloWorld location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE___ns1__HelloWorld, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__HelloWorld(struct soap *soap, const struct __ns1__HelloWorld *a, const char *tag, const char *type)
{
	if (soap_out___ns1__HelloWorld(soap, tag ? tag : "-ns1:HelloWorld", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__HelloWorld * SOAP_FMAC4 soap_get___ns1__HelloWorld(struct soap *soap, struct __ns1__HelloWorld *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__HelloWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DiagEx(struct soap *soap, _ns1__DiagEx *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DiagEx))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DiagEx(struct soap *soap, const char *tag, int id, _ns1__DiagEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DiagEx, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__DiagEx ? type : NULL);
}

SOAP_FMAC3 _ns1__DiagEx ** SOAP_FMAC4 soap_in_PointerTo_ns1__DiagEx(struct soap *soap, const char *tag, _ns1__DiagEx **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__DiagEx **)soap_malloc(soap, sizeof(_ns1__DiagEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__DiagEx *)soap_instantiate__ns1__DiagEx(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__DiagEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DiagEx, sizeof(_ns1__DiagEx), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DiagEx(struct soap *soap, _ns1__DiagEx *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__DiagEx(soap, tag ? tag : "ns1:DiagEx", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__DiagEx ** SOAP_FMAC4 soap_get_PointerTo_ns1__DiagEx(struct soap *soap, _ns1__DiagEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DiagEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Diag(struct soap *soap, _ns1__Diag *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Diag))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Diag(struct soap *soap, const char *tag, int id, _ns1__Diag *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Diag, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Diag ? type : NULL);
}

SOAP_FMAC3 _ns1__Diag ** SOAP_FMAC4 soap_in_PointerTo_ns1__Diag(struct soap *soap, const char *tag, _ns1__Diag **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Diag **)soap_malloc(soap, sizeof(_ns1__Diag *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Diag *)soap_instantiate__ns1__Diag(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Diag **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Diag, sizeof(_ns1__Diag), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Diag(struct soap *soap, _ns1__Diag *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Diag(soap, tag ? tag : "ns1:Diag", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Diag ** SOAP_FMAC4 soap_get_PointerTo_ns1__Diag(struct soap *soap, _ns1__Diag **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Diag(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CloseAllJobs(struct soap *soap, _ns1__CloseAllJobs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CloseAllJobs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CloseAllJobs(struct soap *soap, const char *tag, int id, _ns1__CloseAllJobs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CloseAllJobs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CloseAllJobs ? type : NULL);
}

SOAP_FMAC3 _ns1__CloseAllJobs ** SOAP_FMAC4 soap_in_PointerTo_ns1__CloseAllJobs(struct soap *soap, const char *tag, _ns1__CloseAllJobs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CloseAllJobs **)soap_malloc(soap, sizeof(_ns1__CloseAllJobs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CloseAllJobs *)soap_instantiate__ns1__CloseAllJobs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CloseAllJobs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CloseAllJobs, sizeof(_ns1__CloseAllJobs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CloseAllJobs(struct soap *soap, _ns1__CloseAllJobs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CloseAllJobs(soap, tag ? tag : "ns1:CloseAllJobs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CloseAllJobs ** SOAP_FMAC4 soap_get_PointerTo_ns1__CloseAllJobs(struct soap *soap, _ns1__CloseAllJobs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CloseAllJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CloseExpiredJobs(struct soap *soap, _ns1__CloseExpiredJobs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CloseExpiredJobs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CloseExpiredJobs(struct soap *soap, const char *tag, int id, _ns1__CloseExpiredJobs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CloseExpiredJobs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CloseExpiredJobs ? type : NULL);
}

SOAP_FMAC3 _ns1__CloseExpiredJobs ** SOAP_FMAC4 soap_in_PointerTo_ns1__CloseExpiredJobs(struct soap *soap, const char *tag, _ns1__CloseExpiredJobs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CloseExpiredJobs **)soap_malloc(soap, sizeof(_ns1__CloseExpiredJobs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CloseExpiredJobs *)soap_instantiate__ns1__CloseExpiredJobs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CloseExpiredJobs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CloseExpiredJobs, sizeof(_ns1__CloseExpiredJobs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CloseExpiredJobs(struct soap *soap, _ns1__CloseExpiredJobs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CloseExpiredJobs(soap, tag ? tag : "ns1:CloseExpiredJobs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CloseExpiredJobs ** SOAP_FMAC4 soap_get_PointerTo_ns1__CloseExpiredJobs(struct soap *soap, _ns1__CloseExpiredJobs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CloseExpiredJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAllJobsEx(struct soap *soap, _ns1__GetAllJobsEx *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAllJobsEx))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAllJobsEx(struct soap *soap, const char *tag, int id, _ns1__GetAllJobsEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAllJobsEx, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetAllJobsEx ? type : NULL);
}

SOAP_FMAC3 _ns1__GetAllJobsEx ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAllJobsEx(struct soap *soap, const char *tag, _ns1__GetAllJobsEx **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAllJobsEx **)soap_malloc(soap, sizeof(_ns1__GetAllJobsEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAllJobsEx *)soap_instantiate__ns1__GetAllJobsEx(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetAllJobsEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAllJobsEx, sizeof(_ns1__GetAllJobsEx), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAllJobsEx(struct soap *soap, _ns1__GetAllJobsEx *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAllJobsEx(soap, tag ? tag : "ns1:GetAllJobsEx", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAllJobsEx ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAllJobsEx(struct soap *soap, _ns1__GetAllJobsEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAllJobsEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetAllJobs(struct soap *soap, _ns1__GetAllJobs *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetAllJobs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetAllJobs(struct soap *soap, const char *tag, int id, _ns1__GetAllJobs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetAllJobs, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetAllJobs ? type : NULL);
}

SOAP_FMAC3 _ns1__GetAllJobs ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetAllJobs(struct soap *soap, const char *tag, _ns1__GetAllJobs **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetAllJobs **)soap_malloc(soap, sizeof(_ns1__GetAllJobs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetAllJobs *)soap_instantiate__ns1__GetAllJobs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetAllJobs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetAllJobs, sizeof(_ns1__GetAllJobs), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetAllJobs(struct soap *soap, _ns1__GetAllJobs *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetAllJobs(soap, tag ? tag : "ns1:GetAllJobs", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetAllJobs ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetAllJobs(struct soap *soap, _ns1__GetAllJobs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetAllJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetExpiration(struct soap *soap, _ns1__GetExpiration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetExpiration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetExpiration(struct soap *soap, const char *tag, int id, _ns1__GetExpiration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetExpiration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetExpiration ? type : NULL);
}

SOAP_FMAC3 _ns1__GetExpiration ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetExpiration(struct soap *soap, const char *tag, _ns1__GetExpiration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetExpiration **)soap_malloc(soap, sizeof(_ns1__GetExpiration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetExpiration *)soap_instantiate__ns1__GetExpiration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetExpiration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetExpiration, sizeof(_ns1__GetExpiration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetExpiration(struct soap *soap, _ns1__GetExpiration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetExpiration(soap, tag ? tag : "ns1:GetExpiration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetExpiration ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetExpiration(struct soap *soap, _ns1__GetExpiration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetExpiration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BatchJobEx(struct soap *soap, _ns1__BatchJobEx *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BatchJobEx))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BatchJobEx(struct soap *soap, const char *tag, int id, _ns1__BatchJobEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BatchJobEx, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__BatchJobEx ? type : NULL);
}

SOAP_FMAC3 _ns1__BatchJobEx ** SOAP_FMAC4 soap_in_PointerTo_ns1__BatchJobEx(struct soap *soap, const char *tag, _ns1__BatchJobEx **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BatchJobEx **)soap_malloc(soap, sizeof(_ns1__BatchJobEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BatchJobEx *)soap_instantiate__ns1__BatchJobEx(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__BatchJobEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BatchJobEx, sizeof(_ns1__BatchJobEx), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BatchJobEx(struct soap *soap, _ns1__BatchJobEx *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__BatchJobEx(soap, tag ? tag : "ns1:BatchJobEx", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BatchJobEx ** SOAP_FMAC4 soap_get_PointerTo_ns1__BatchJobEx(struct soap *soap, _ns1__BatchJobEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BatchJobEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__BatchJob(struct soap *soap, _ns1__BatchJob *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__BatchJob))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__BatchJob(struct soap *soap, const char *tag, int id, _ns1__BatchJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__BatchJob, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__BatchJob ? type : NULL);
}

SOAP_FMAC3 _ns1__BatchJob ** SOAP_FMAC4 soap_in_PointerTo_ns1__BatchJob(struct soap *soap, const char *tag, _ns1__BatchJob **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__BatchJob **)soap_malloc(soap, sizeof(_ns1__BatchJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__BatchJob *)soap_instantiate__ns1__BatchJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__BatchJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__BatchJob, sizeof(_ns1__BatchJob), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__BatchJob(struct soap *soap, _ns1__BatchJob *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__BatchJob(soap, tag ? tag : "ns1:BatchJob", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__BatchJob ** SOAP_FMAC4 soap_get_PointerTo_ns1__BatchJob(struct soap *soap, _ns1__BatchJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__BatchJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CloseJob(struct soap *soap, _ns1__CloseJob *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CloseJob))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CloseJob(struct soap *soap, const char *tag, int id, _ns1__CloseJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CloseJob, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__CloseJob ? type : NULL);
}

SOAP_FMAC3 _ns1__CloseJob ** SOAP_FMAC4 soap_in_PointerTo_ns1__CloseJob(struct soap *soap, const char *tag, _ns1__CloseJob **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__CloseJob **)soap_malloc(soap, sizeof(_ns1__CloseJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__CloseJob *)soap_instantiate__ns1__CloseJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__CloseJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CloseJob, sizeof(_ns1__CloseJob), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CloseJob(struct soap *soap, _ns1__CloseJob *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__CloseJob(soap, tag ? tag : "ns1:CloseJob", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__CloseJob ** SOAP_FMAC4 soap_get_PointerTo_ns1__CloseJob(struct soap *soap, _ns1__CloseJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CloseJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ExecuteEx(struct soap *soap, _ns1__ExecuteEx *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ExecuteEx))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ExecuteEx(struct soap *soap, const char *tag, int id, _ns1__ExecuteEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ExecuteEx, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__ExecuteEx ? type : NULL);
}

SOAP_FMAC3 _ns1__ExecuteEx ** SOAP_FMAC4 soap_in_PointerTo_ns1__ExecuteEx(struct soap *soap, const char *tag, _ns1__ExecuteEx **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__ExecuteEx **)soap_malloc(soap, sizeof(_ns1__ExecuteEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__ExecuteEx *)soap_instantiate__ns1__ExecuteEx(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__ExecuteEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ExecuteEx, sizeof(_ns1__ExecuteEx), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ExecuteEx(struct soap *soap, _ns1__ExecuteEx *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__ExecuteEx(soap, tag ? tag : "ns1:ExecuteEx", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__ExecuteEx ** SOAP_FMAC4 soap_get_PointerTo_ns1__ExecuteEx(struct soap *soap, _ns1__ExecuteEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ExecuteEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__Execute(struct soap *soap, _ns1__Execute *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__Execute))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__Execute(struct soap *soap, const char *tag, int id, _ns1__Execute *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__Execute, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__Execute ? type : NULL);
}

SOAP_FMAC3 _ns1__Execute ** SOAP_FMAC4 soap_in_PointerTo_ns1__Execute(struct soap *soap, const char *tag, _ns1__Execute **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__Execute **)soap_malloc(soap, sizeof(_ns1__Execute *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__Execute *)soap_instantiate__ns1__Execute(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__Execute **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__Execute, sizeof(_ns1__Execute), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__Execute(struct soap *soap, _ns1__Execute *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__Execute(soap, tag ? tag : "ns1:Execute", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__Execute ** SOAP_FMAC4 soap_get_PointerTo_ns1__Execute(struct soap *soap, _ns1__Execute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__Execute(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__RenewLease(struct soap *soap, _ns1__RenewLease *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__RenewLease))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__RenewLease(struct soap *soap, const char *tag, int id, _ns1__RenewLease *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__RenewLease, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__RenewLease ? type : NULL);
}

SOAP_FMAC3 _ns1__RenewLease ** SOAP_FMAC4 soap_in_PointerTo_ns1__RenewLease(struct soap *soap, const char *tag, _ns1__RenewLease **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__RenewLease **)soap_malloc(soap, sizeof(_ns1__RenewLease *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__RenewLease *)soap_instantiate__ns1__RenewLease(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__RenewLease **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__RenewLease, sizeof(_ns1__RenewLease), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__RenewLease(struct soap *soap, _ns1__RenewLease *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__RenewLease(soap, tag ? tag : "ns1:RenewLease", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__RenewLease ** SOAP_FMAC4 soap_get_PointerTo_ns1__RenewLease(struct soap *soap, _ns1__RenewLease **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__RenewLease(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OpenJobEx(struct soap *soap, _ns1__OpenJobEx *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OpenJobEx))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OpenJobEx(struct soap *soap, const char *tag, int id, _ns1__OpenJobEx *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OpenJobEx, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__OpenJobEx ? type : NULL);
}

SOAP_FMAC3 _ns1__OpenJobEx ** SOAP_FMAC4 soap_in_PointerTo_ns1__OpenJobEx(struct soap *soap, const char *tag, _ns1__OpenJobEx **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OpenJobEx **)soap_malloc(soap, sizeof(_ns1__OpenJobEx *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OpenJobEx *)soap_instantiate__ns1__OpenJobEx(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__OpenJobEx **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OpenJobEx, sizeof(_ns1__OpenJobEx), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OpenJobEx(struct soap *soap, _ns1__OpenJobEx *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__OpenJobEx(soap, tag ? tag : "ns1:OpenJobEx", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OpenJobEx ** SOAP_FMAC4 soap_get_PointerTo_ns1__OpenJobEx(struct soap *soap, _ns1__OpenJobEx **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OpenJobEx(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__OpenJob(struct soap *soap, _ns1__OpenJob *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__OpenJob))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__OpenJob(struct soap *soap, const char *tag, int id, _ns1__OpenJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__OpenJob, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__OpenJob ? type : NULL);
}

SOAP_FMAC3 _ns1__OpenJob ** SOAP_FMAC4 soap_in_PointerTo_ns1__OpenJob(struct soap *soap, const char *tag, _ns1__OpenJob **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__OpenJob **)soap_malloc(soap, sizeof(_ns1__OpenJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__OpenJob *)soap_instantiate__ns1__OpenJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__OpenJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__OpenJob, sizeof(_ns1__OpenJob), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__OpenJob(struct soap *soap, _ns1__OpenJob *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__OpenJob(soap, tag ? tag : "ns1:OpenJob", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__OpenJob ** SOAP_FMAC4 soap_get_PointerTo_ns1__OpenJob(struct soap *soap, _ns1__OpenJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__OpenJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetStatus(struct soap *soap, _ns1__GetStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetStatus(struct soap *soap, const char *tag, int id, _ns1__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetStatus ? type : NULL);
}

SOAP_FMAC3 _ns1__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetStatus(struct soap *soap, const char *tag, _ns1__GetStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetStatus **)soap_malloc(soap, sizeof(_ns1__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetStatus *)soap_instantiate__ns1__GetStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetStatus, sizeof(_ns1__GetStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetStatus(struct soap *soap, _ns1__GetStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetStatus(soap, tag ? tag : "ns1:GetStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetStatus(struct soap *soap, _ns1__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetVersion(struct soap *soap, _ns1__GetVersion *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetVersion))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetVersion(struct soap *soap, const char *tag, int id, _ns1__GetVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetVersion, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__GetVersion ? type : NULL);
}

SOAP_FMAC3 _ns1__GetVersion ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetVersion(struct soap *soap, const char *tag, _ns1__GetVersion **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__GetVersion **)soap_malloc(soap, sizeof(_ns1__GetVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__GetVersion *)soap_instantiate__ns1__GetVersion(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__GetVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetVersion, sizeof(_ns1__GetVersion), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetVersion(struct soap *soap, _ns1__GetVersion *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__GetVersion(soap, tag ? tag : "ns1:GetVersion", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__GetVersion ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetVersion(struct soap *soap, _ns1__GetVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__HelloWorld))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__HelloWorld(struct soap *soap, const char *tag, int id, _ns1__HelloWorld *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__HelloWorld, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__ns1__HelloWorld ? type : NULL);
}

SOAP_FMAC3 _ns1__HelloWorld ** SOAP_FMAC4 soap_in_PointerTo_ns1__HelloWorld(struct soap *soap, const char *tag, _ns1__HelloWorld **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_ns1__HelloWorld **)soap_malloc(soap, sizeof(_ns1__HelloWorld *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_ns1__HelloWorld *)soap_instantiate__ns1__HelloWorld(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_ns1__HelloWorld **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__HelloWorld, sizeof(_ns1__HelloWorld), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_ns1__HelloWorld(soap, tag ? tag : "ns1:HelloWorld", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _ns1__HelloWorld ** SOAP_FMAC4 soap_get_PointerTo_ns1__HelloWorld(struct soap *soap, _ns1__HelloWorld **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__HelloWorld(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfJob(struct soap *soap, ns1__ArrayOfJob *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfJob))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfJob(struct soap *soap, const char *tag, int id, ns1__ArrayOfJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfJob, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfJob ? type : NULL);
}

SOAP_FMAC3 ns1__ArrayOfJob ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfJob(struct soap *soap, const char *tag, ns1__ArrayOfJob **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfJob **)soap_malloc(soap, sizeof(ns1__ArrayOfJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfJob *)soap_instantiate_ns1__ArrayOfJob(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfJob, sizeof(ns1__ArrayOfJob), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfJob(struct soap *soap, ns1__ArrayOfJob *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfJob(soap, tag ? tag : "ns1:ArrayOfJob", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfJob ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfJob(struct soap *soap, ns1__ArrayOfJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ScriptExecution(struct soap *soap, ns1__ScriptExecution *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ScriptExecution))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ScriptExecution(struct soap *soap, const char *tag, int id, ns1__ScriptExecution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ScriptExecution, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ScriptExecution ? type : NULL);
}

SOAP_FMAC3 ns1__ScriptExecution ** SOAP_FMAC4 soap_in_PointerTons1__ScriptExecution(struct soap *soap, const char *tag, ns1__ScriptExecution **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScriptExecution **)soap_malloc(soap, sizeof(ns1__ScriptExecution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ScriptExecution *)soap_instantiate_ns1__ScriptExecution(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ScriptExecution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ScriptExecution, sizeof(ns1__ScriptExecution), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ScriptExecution(struct soap *soap, ns1__ScriptExecution *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ScriptExecution(soap, tag ? tag : "ns1:ScriptExecution", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ScriptExecution ** SOAP_FMAC4 soap_get_PointerTons1__ScriptExecution(struct soap *soap, ns1__ScriptExecution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ScriptExecution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Status(struct soap *soap, ns1__Status *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Status))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Status(struct soap *soap, const char *tag, int id, ns1__Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Status, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Status ? type : NULL);
}

SOAP_FMAC3 ns1__Status ** SOAP_FMAC4 soap_in_PointerTons1__Status(struct soap *soap, const char *tag, ns1__Status **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Status **)soap_malloc(soap, sizeof(ns1__Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Status *)soap_instantiate_ns1__Status(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Status, sizeof(ns1__Status), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Status(struct soap *soap, ns1__Status *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Status(soap, tag ? tag : "ns1:Status", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Status ** SOAP_FMAC4 soap_get_PointerTons1__Status(struct soap *soap, ns1__Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Job(struct soap *soap, ns1__Job *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Job))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Job(struct soap *soap, const char *tag, int id, ns1__Job *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Job, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__Job ? type : NULL);
}

SOAP_FMAC3 ns1__Job ** SOAP_FMAC4 soap_in_PointerTons1__Job(struct soap *soap, const char *tag, ns1__Job **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__Job **)soap_malloc(soap, sizeof(ns1__Job *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__Job *)soap_instantiate_ns1__Job(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__Job **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Job, sizeof(ns1__Job), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Job(struct soap *soap, ns1__Job *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__Job(soap, tag ? tag : "ns1:Job", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__Job ** SOAP_FMAC4 soap_get_PointerTons1__Job(struct soap *soap, ns1__Job **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Job(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LuaValue(struct soap *soap, ns1__LuaValue *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LuaValue))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LuaValue(struct soap *soap, const char *tag, int id, ns1__LuaValue *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LuaValue, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__LuaValue ? type : NULL);
}

SOAP_FMAC3 ns1__LuaValue ** SOAP_FMAC4 soap_in_PointerTons1__LuaValue(struct soap *soap, const char *tag, ns1__LuaValue **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LuaValue **)soap_malloc(soap, sizeof(ns1__LuaValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LuaValue *)soap_instantiate_ns1__LuaValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__LuaValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LuaValue, sizeof(ns1__LuaValue), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LuaValue(struct soap *soap, ns1__LuaValue *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__LuaValue(soap, tag ? tag : "ns1:LuaValue", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__LuaValue ** SOAP_FMAC4 soap_get_PointerTons1__LuaValue(struct soap *soap, ns1__LuaValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LuaValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ArrayOfLuaValue(struct soap *soap, ns1__ArrayOfLuaValue *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ArrayOfLuaValue))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ArrayOfLuaValue(struct soap *soap, const char *tag, int id, ns1__ArrayOfLuaValue *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ArrayOfLuaValue, &mark);
	if (id < 0)
		return soap->error;
	(*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_ns1__ArrayOfLuaValue ? type : NULL);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 ns1__ArrayOfLuaValue ** SOAP_FMAC4 soap_in_PointerTons1__ArrayOfLuaValue(struct soap *soap, const char *tag, ns1__ArrayOfLuaValue **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ArrayOfLuaValue **)soap_malloc(soap, sizeof(ns1__ArrayOfLuaValue *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ArrayOfLuaValue *)soap_instantiate_ns1__ArrayOfLuaValue(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (ns1__ArrayOfLuaValue **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ArrayOfLuaValue, sizeof(ns1__ArrayOfLuaValue), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ArrayOfLuaValue(struct soap *soap, ns1__ArrayOfLuaValue *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTons1__ArrayOfLuaValue(soap, tag ? tag : "ns1:ArrayOfLuaValue", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__ArrayOfLuaValue ** SOAP_FMAC4 soap_get_PointerTons1__ArrayOfLuaValue(struct soap *soap, ns1__ArrayOfLuaValue **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ArrayOfLuaValue(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new__QName(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default__QName(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__Job(struct soap *soap, std::vector<ns1__Job *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__Job(struct soap *soap, const std::vector<ns1__Job *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__Job *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__Job(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__Job(struct soap *soap, const char *tag, int id, const std::vector<ns1__Job *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__Job *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__Job(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__Job *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__Job(struct soap *soap, const char *tag, std::vector<ns1__Job *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__Job(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__Job *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__Job, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Job, sizeof(ns1__Job), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__Job(soap, tag, NULL, "ns1:Job"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__Job(soap, tag, &n, "ns1:Job"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__Job *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__Job(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__Job(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__Job *> *p;
	size_t k = sizeof(std::vector<ns1__Job *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__Job *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__Job *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__Job *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__Job, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__LuaValue(struct soap *soap, std::vector<ns1__LuaValue *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__LuaValue(struct soap *soap, const std::vector<ns1__LuaValue *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<ns1__LuaValue *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__LuaValue(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__LuaValue(struct soap *soap, const char *tag, int id, const std::vector<ns1__LuaValue *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<ns1__LuaValue *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__LuaValue(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__LuaValue *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__LuaValue(struct soap *soap, const char *tag, std::vector<ns1__LuaValue *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__LuaValue(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		ns1__LuaValue *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_ns1__LuaValue, SOAP_TYPE_std__vectorTemplateOfPointerTons1__LuaValue, sizeof(ns1__LuaValue), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTons1__LuaValue(soap, tag, NULL, "ns1:LuaValue"))
				break;
		}
		else
		{	if (!soap_in_PointerTons1__LuaValue(soap, tag, &n, "ns1:LuaValue"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__LuaValue *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__LuaValue(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__LuaValue(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<ns1__LuaValue *> *p;
	size_t k = sizeof(std::vector<ns1__LuaValue *> );
	if (n < 0)
	{	p = SOAP_NEW(std::vector<ns1__LuaValue *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(std::vector<ns1__LuaValue *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<ns1__LuaValue *>  location=%p n=%d\n", (void*)p, n));
	soap_link(soap, p, SOAP_TYPE_std__vectorTemplateOfPointerTons1__LuaValue, n, soap_fdelete);
	if (size)
		*size = k;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
