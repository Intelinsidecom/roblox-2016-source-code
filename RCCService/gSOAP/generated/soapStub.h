/* soapStub.h
   Generated by gSOAP 2.8.45 for generated/prototypes.h

gSOAP XML Web services tools
Copyright (C) 2000-2017, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns1	"http://roblox.com/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20845
# error "GSOAP VERSION 20845 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* generated/prototypes.h:285 */
#ifndef SOAP_TYPE_ns1__LuaType
#define SOAP_TYPE_ns1__LuaType (53)
/* ns1:LuaType */
enum ns1__LuaType {
	ns1__LuaType__LUA_USCORETNIL = 0,
	ns1__LuaType__LUA_USCORETBOOLEAN = 1,
	ns1__LuaType__LUA_USCORETNUMBER = 2,
	ns1__LuaType__LUA_USCORETSTRING = 3,
	ns1__LuaType__LUA_USCORETTABLE = 4
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class ns1__Status;	/* generated/prototypes.h:148 */
class ns1__Job;	/* generated/prototypes.h:151 */
class ns1__ScriptExecution;	/* generated/prototypes.h:154 */
class ns1__ArrayOfLuaValue;	/* generated/prototypes.h:157 */
class ns1__ArrayOfJob;	/* generated/prototypes.h:160 */
class ns1__LuaValue;	/* generated/prototypes.h:163 */
class _ns1__HelloWorld;	/* generated/prototypes.h:166 */
class _ns1__HelloWorldResponse;	/* generated/prototypes.h:169 */
class _ns1__GetVersion;	/* generated/prototypes.h:172 */
class _ns1__GetVersionResponse;	/* generated/prototypes.h:175 */
class _ns1__GetStatus;	/* generated/prototypes.h:178 */
class _ns1__GetStatusResponse;	/* generated/prototypes.h:181 */
class _ns1__OpenJob;	/* generated/prototypes.h:184 */
class _ns1__OpenJobEx;	/* generated/prototypes.h:187 */
class _ns1__OpenJobResponse;	/* generated/prototypes.h:190 */
class _ns1__OpenJobExResponse;	/* generated/prototypes.h:193 */
class _ns1__RenewLease;	/* generated/prototypes.h:196 */
class _ns1__RenewLeaseResponse;	/* generated/prototypes.h:199 */
class _ns1__Execute;	/* generated/prototypes.h:202 */
class _ns1__ExecuteResponse;	/* generated/prototypes.h:205 */
class _ns1__ExecuteEx;	/* generated/prototypes.h:208 */
class _ns1__ExecuteExResponse;	/* generated/prototypes.h:211 */
class _ns1__CloseJob;	/* generated/prototypes.h:214 */
class _ns1__CloseJobResponse;	/* generated/prototypes.h:217 */
class _ns1__BatchJob;	/* generated/prototypes.h:220 */
class _ns1__BatchJobResponse;	/* generated/prototypes.h:223 */
class _ns1__BatchJobEx;	/* generated/prototypes.h:226 */
class _ns1__BatchJobExResponse;	/* generated/prototypes.h:229 */
class _ns1__GetExpiration;	/* generated/prototypes.h:232 */
class _ns1__GetExpirationResponse;	/* generated/prototypes.h:235 */
class _ns1__GetAllJobs;	/* generated/prototypes.h:238 */
class _ns1__GetAllJobsResponse;	/* generated/prototypes.h:241 */
class _ns1__GetAllJobsEx;	/* generated/prototypes.h:244 */
class _ns1__GetAllJobsExResponse;	/* generated/prototypes.h:247 */
class _ns1__CloseExpiredJobs;	/* generated/prototypes.h:250 */
class _ns1__CloseExpiredJobsResponse;	/* generated/prototypes.h:253 */
class _ns1__CloseAllJobs;	/* generated/prototypes.h:256 */
class _ns1__CloseAllJobsResponse;	/* generated/prototypes.h:259 */
class _ns1__Diag;	/* generated/prototypes.h:262 */
class _ns1__DiagResponse;	/* generated/prototypes.h:265 */
class _ns1__DiagEx;	/* generated/prototypes.h:268 */
class _ns1__DiagExResponse;	/* generated/prototypes.h:271 */
struct __ns1__HelloWorld;	/* generated/prototypes.h:1403 */
struct __ns1__GetVersion;	/* generated/prototypes.h:1470 */
struct __ns1__GetStatus;	/* generated/prototypes.h:1537 */
struct __ns1__OpenJob;	/* generated/prototypes.h:1604 */
struct __ns1__OpenJobEx;	/* generated/prototypes.h:1671 */
struct __ns1__RenewLease;	/* generated/prototypes.h:1738 */
struct __ns1__Execute;	/* generated/prototypes.h:1805 */
struct __ns1__ExecuteEx;	/* generated/prototypes.h:1872 */
struct __ns1__CloseJob;	/* generated/prototypes.h:1939 */
struct __ns1__BatchJob;	/* generated/prototypes.h:2006 */
struct __ns1__BatchJobEx;	/* generated/prototypes.h:2073 */
struct __ns1__GetExpiration;	/* generated/prototypes.h:2140 */
struct __ns1__GetAllJobs;	/* generated/prototypes.h:2207 */
struct __ns1__GetAllJobsEx;	/* generated/prototypes.h:2274 */
struct __ns1__CloseExpiredJobs;	/* generated/prototypes.h:2341 */
struct __ns1__CloseAllJobs;	/* generated/prototypes.h:2408 */
struct __ns1__Diag;	/* generated/prototypes.h:2475 */
struct __ns1__DiagEx;	/* generated/prototypes.h:2542 */
struct __ns1__HelloWorld_;	/* generated/prototypes.h:2609 */
struct __ns1__GetVersion_;	/* generated/prototypes.h:2676 */
struct __ns1__GetStatus_;	/* generated/prototypes.h:2743 */
struct __ns1__OpenJob_;	/* generated/prototypes.h:2810 */
struct __ns1__OpenJobEx_;	/* generated/prototypes.h:2877 */
struct __ns1__RenewLease_;	/* generated/prototypes.h:2944 */
struct __ns1__Execute_;	/* generated/prototypes.h:3011 */
struct __ns1__ExecuteEx_;	/* generated/prototypes.h:3078 */
struct __ns1__CloseJob_;	/* generated/prototypes.h:3145 */
struct __ns1__BatchJob_;	/* generated/prototypes.h:3212 */
struct __ns1__BatchJobEx_;	/* generated/prototypes.h:3279 */
struct __ns1__GetExpiration_;	/* generated/prototypes.h:3346 */
struct __ns1__GetAllJobs_;	/* generated/prototypes.h:3413 */
struct __ns1__GetAllJobsEx_;	/* generated/prototypes.h:3480 */
struct __ns1__CloseExpiredJobs_;	/* generated/prototypes.h:3547 */
struct __ns1__CloseAllJobs_;	/* generated/prototypes.h:3614 */
struct __ns1__Diag_;	/* generated/prototypes.h:3681 */
struct __ns1__DiagEx_;	/* generated/prototypes.h:3748 */

/* generated/prototypes.h:148 */
#ifndef SOAP_TYPE_ns1__Status
#define SOAP_TYPE_ns1__Status (11)
/* complex XSD type 'ns1:Status': */
class SOAP_CMAC ns1__Status {
      public:
        /// Optional element 'ns1:version' of XSD type 'xsd:string'
        std::string *version;
        /// Required element 'ns1:environmentCount' of XSD type 'xsd:int'
        int environmentCount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Status
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Status; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Status, default initialized and not managed by a soap context
        virtual ns1__Status *soap_alloc(void) const { return SOAP_NEW(ns1__Status); }
      public:
        /// Constructor with initializations
        ns1__Status()
        {
          version = (std::string *)0;
          environmentCount = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__Status() { }
        /// Friend allocator used by soap_new_ns1__Status(struct soap*, int)
        friend SOAP_FMAC1 ns1__Status * SOAP_FMAC2 soap_instantiate_ns1__Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:151 */
#ifndef SOAP_TYPE_ns1__Job
#define SOAP_TYPE_ns1__Job (12)
/* complex XSD type 'ns1:Job': */
class SOAP_CMAC ns1__Job {
      public:
        /// Required element 'ns1:id' of XSD type 'xsd:string'
        std::string id;
        /// Required element 'ns1:expirationInSeconds' of XSD type 'xsd:double'
        double expirationInSeconds;
        /// Required element 'ns1:category' of XSD type 'xsd:int'
        int category;
        /// Required element 'ns1:cores' of XSD type 'xsd:double'
        double cores;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__Job
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__Job; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__Job, default initialized and not managed by a soap context
        virtual ns1__Job *soap_alloc(void) const { return SOAP_NEW(ns1__Job); }
      public:
        /// Constructor with initializations
        ns1__Job()
        {
          expirationInSeconds = (double)0;
          category = (int)0;
          cores = (double)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__Job() { }
        /// Friend allocator used by soap_new_ns1__Job(struct soap*, int)
        friend SOAP_FMAC1 ns1__Job * SOAP_FMAC2 soap_instantiate_ns1__Job(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:154 */
#ifndef SOAP_TYPE_ns1__ScriptExecution
#define SOAP_TYPE_ns1__ScriptExecution (13)
/* complex XSD type 'ns1:ScriptExecution': */
class SOAP_CMAC ns1__ScriptExecution {
      public:
        /// Optional element 'ns1:name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'ns1:script' of XSD type 'xsd:string'
        std::string *script;
        /// Optional element 'ns1:arguments' of XSD type 'ns1:ArrayOfLuaValue'
        ns1__ArrayOfLuaValue *arguments;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ScriptExecution
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ScriptExecution; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ScriptExecution, default initialized and not managed by a soap context
        virtual ns1__ScriptExecution *soap_alloc(void) const { return SOAP_NEW(ns1__ScriptExecution); }
      public:
        /// Constructor with initializations
        ns1__ScriptExecution()
        {
          name = (std::string *)0;
          script = (std::string *)0;
          arguments = (ns1__ArrayOfLuaValue *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__ScriptExecution() { }
        /// Friend allocator used by soap_new_ns1__ScriptExecution(struct soap*, int)
        friend SOAP_FMAC1 ns1__ScriptExecution * SOAP_FMAC2 soap_instantiate_ns1__ScriptExecution(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:157 */
#ifndef SOAP_TYPE_ns1__ArrayOfLuaValue
#define SOAP_TYPE_ns1__ArrayOfLuaValue (14)
/* Type ns1__ArrayOfLuaValue is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* complex XSD type 'ns1:ArrayOfLuaValue': */
class SOAP_CMAC ns1__ArrayOfLuaValue {
      public:
        /// Optional element 'ns1:LuaValue' of XSD type 'ns1:LuaValue'
        std::vector<ns1__LuaValue *> LuaValue;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfLuaValue
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfLuaValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfLuaValue, default initialized and not managed by a soap context
        virtual ns1__ArrayOfLuaValue *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfLuaValue); }
      public:
        /// Constructor with initializations
        ns1__ArrayOfLuaValue()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns1__ArrayOfLuaValue() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfLuaValue(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfLuaValue * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfLuaValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:160 */
#ifndef SOAP_TYPE_ns1__ArrayOfJob
#define SOAP_TYPE_ns1__ArrayOfJob (15)
/* complex XSD type 'ns1:ArrayOfJob': */
class SOAP_CMAC ns1__ArrayOfJob {
      public:
        /// Optional element 'ns1:Job' of XSD type 'ns1:Job'
        std::vector<ns1__Job *> Job;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__ArrayOfJob
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__ArrayOfJob; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__ArrayOfJob, default initialized and not managed by a soap context
        virtual ns1__ArrayOfJob *soap_alloc(void) const { return SOAP_NEW(ns1__ArrayOfJob); }
      public:
        /// Constructor with initializations
        ns1__ArrayOfJob()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns1__ArrayOfJob() { }
        /// Friend allocator used by soap_new_ns1__ArrayOfJob(struct soap*, int)
        friend SOAP_FMAC1 ns1__ArrayOfJob * SOAP_FMAC2 soap_instantiate_ns1__ArrayOfJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:163 */
#ifndef SOAP_TYPE_ns1__LuaValue
#define SOAP_TYPE_ns1__LuaValue (16)
/* complex XSD type 'ns1:LuaValue': */
class SOAP_CMAC ns1__LuaValue {
      public:
        /// Required element 'ns1:type' of XSD type 'ns1:LuaType'
        enum ns1__LuaType type;
        /// Optional element 'ns1:value' of XSD type 'xsd:string'
        std::string *value;
        /// Optional element 'ns1:table' of XSD type 'ns1:ArrayOfLuaValue'
        ns1__ArrayOfLuaValue *table;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns1__LuaValue
        virtual int soap_type(void) const { return SOAP_TYPE_ns1__LuaValue; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns1__LuaValue, default initialized and not managed by a soap context
        virtual ns1__LuaValue *soap_alloc(void) const { return SOAP_NEW(ns1__LuaValue); }
      public:
        /// Constructor with initializations
        ns1__LuaValue()
        {
          type = (enum ns1__LuaType)0;
          value = (std::string *)0;
          table = (ns1__ArrayOfLuaValue *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns1__LuaValue() { }
        /// Friend allocator used by soap_new_ns1__LuaValue(struct soap*, int)
        friend SOAP_FMAC1 ns1__LuaValue * SOAP_FMAC2 soap_instantiate_ns1__LuaValue(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:166 */
#ifndef SOAP_TYPE__ns1__HelloWorld
#define SOAP_TYPE__ns1__HelloWorld (17)
/* complex XSD type 'ns1:HelloWorld': */
class SOAP_CMAC _ns1__HelloWorld {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__HelloWorld
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__HelloWorld; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__HelloWorld, default initialized and not managed by a soap context
        virtual _ns1__HelloWorld *soap_alloc(void) const { return SOAP_NEW(_ns1__HelloWorld); }
      public:
        /// Constructor with initializations
        _ns1__HelloWorld()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__HelloWorld() { }
        /// Friend allocator used by soap_new__ns1__HelloWorld(struct soap*, int)
        friend SOAP_FMAC1 _ns1__HelloWorld * SOAP_FMAC2 soap_instantiate__ns1__HelloWorld(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:169 */
#ifndef SOAP_TYPE__ns1__HelloWorldResponse
#define SOAP_TYPE__ns1__HelloWorldResponse (18)
/* complex XSD type 'ns1:HelloWorldResponse': */
class SOAP_CMAC _ns1__HelloWorldResponse {
      public:
        /// Optional element 'ns1:HelloWorldResult' of XSD type 'xsd:string'
        std::string *HelloWorldResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__HelloWorldResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__HelloWorldResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__HelloWorldResponse, default initialized and not managed by a soap context
        virtual _ns1__HelloWorldResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__HelloWorldResponse); }
      public:
        /// Constructor with initializations
        _ns1__HelloWorldResponse()
        {
          HelloWorldResult = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__HelloWorldResponse() { }
        /// Friend allocator used by soap_new__ns1__HelloWorldResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__HelloWorldResponse * SOAP_FMAC2 soap_instantiate__ns1__HelloWorldResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:172 */
#ifndef SOAP_TYPE__ns1__GetVersion
#define SOAP_TYPE__ns1__GetVersion (19)
/* complex XSD type 'ns1:GetVersion': */
class SOAP_CMAC _ns1__GetVersion {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetVersion
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetVersion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetVersion, default initialized and not managed by a soap context
        virtual _ns1__GetVersion *soap_alloc(void) const { return SOAP_NEW(_ns1__GetVersion); }
      public:
        /// Constructor with initializations
        _ns1__GetVersion()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetVersion() { }
        /// Friend allocator used by soap_new__ns1__GetVersion(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetVersion * SOAP_FMAC2 soap_instantiate__ns1__GetVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:175 */
#ifndef SOAP_TYPE__ns1__GetVersionResponse
#define SOAP_TYPE__ns1__GetVersionResponse (20)
/* complex XSD type 'ns1:GetVersionResponse': */
class SOAP_CMAC _ns1__GetVersionResponse {
      public:
        /// Required element 'ns1:GetVersionResult' of XSD type 'xsd:string'
        std::string GetVersionResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetVersionResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetVersionResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetVersionResponse, default initialized and not managed by a soap context
        virtual _ns1__GetVersionResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetVersionResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetVersionResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetVersionResponse() { }
        /// Friend allocator used by soap_new__ns1__GetVersionResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetVersionResponse * SOAP_FMAC2 soap_instantiate__ns1__GetVersionResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:178 */
#ifndef SOAP_TYPE__ns1__GetStatus
#define SOAP_TYPE__ns1__GetStatus (21)
/* complex XSD type 'ns1:GetStatus': */
class SOAP_CMAC _ns1__GetStatus {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetStatus
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetStatus; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetStatus, default initialized and not managed by a soap context
        virtual _ns1__GetStatus *soap_alloc(void) const { return SOAP_NEW(_ns1__GetStatus); }
      public:
        /// Constructor with initializations
        _ns1__GetStatus()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetStatus() { }
        /// Friend allocator used by soap_new__ns1__GetStatus(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetStatus * SOAP_FMAC2 soap_instantiate__ns1__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:181 */
#ifndef SOAP_TYPE__ns1__GetStatusResponse
#define SOAP_TYPE__ns1__GetStatusResponse (22)
/* complex XSD type 'ns1:GetStatusResponse': */
class SOAP_CMAC _ns1__GetStatusResponse {
      public:
        /// Required element 'ns1:GetStatusResult' of XSD type 'ns1:Status'
        ns1__Status *GetStatusResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetStatusResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetStatusResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetStatusResponse, default initialized and not managed by a soap context
        virtual _ns1__GetStatusResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetStatusResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetStatusResponse()
        {
          GetStatusResult = (ns1__Status *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetStatusResponse() { }
        /// Friend allocator used by soap_new__ns1__GetStatusResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetStatusResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStatusResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:184 */
#ifndef SOAP_TYPE__ns1__OpenJob
#define SOAP_TYPE__ns1__OpenJob (23)
/* complex XSD type 'ns1:OpenJob': */
class SOAP_CMAC _ns1__OpenJob {
      public:
        /// Required element 'ns1:job' of XSD type 'ns1:Job'
        ns1__Job *job;
        /// Optional element 'ns1:script' of XSD type 'ns1:ScriptExecution'
        ns1__ScriptExecution *script;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OpenJob
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__OpenJob; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OpenJob, default initialized and not managed by a soap context
        virtual _ns1__OpenJob *soap_alloc(void) const { return SOAP_NEW(_ns1__OpenJob); }
      public:
        /// Constructor with initializations
        _ns1__OpenJob()
        {
          job = (ns1__Job *)0;
          script = (ns1__ScriptExecution *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__OpenJob() { }
        /// Friend allocator used by soap_new__ns1__OpenJob(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OpenJob * SOAP_FMAC2 soap_instantiate__ns1__OpenJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:187 */
#ifndef SOAP_TYPE__ns1__OpenJobEx
#define SOAP_TYPE__ns1__OpenJobEx (24)
/* complex XSD type 'ns1:OpenJobEx': */
class SOAP_CMAC _ns1__OpenJobEx {
      public:
        /// Required element 'ns1:job' of XSD type 'ns1:Job'
        ns1__Job *job;
        /// Optional element 'ns1:script' of XSD type 'ns1:ScriptExecution'
        ns1__ScriptExecution *script;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OpenJobEx
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__OpenJobEx; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OpenJobEx, default initialized and not managed by a soap context
        virtual _ns1__OpenJobEx *soap_alloc(void) const { return SOAP_NEW(_ns1__OpenJobEx); }
      public:
        /// Constructor with initializations
        _ns1__OpenJobEx()
        {
          job = (ns1__Job *)0;
          script = (ns1__ScriptExecution *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__OpenJobEx() { }
        /// Friend allocator used by soap_new__ns1__OpenJobEx(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OpenJobEx * SOAP_FMAC2 soap_instantiate__ns1__OpenJobEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:190 */
#ifndef SOAP_TYPE__ns1__OpenJobResponse
#define SOAP_TYPE__ns1__OpenJobResponse (25)
/* complex XSD type 'ns1:OpenJobResponse': */
class SOAP_CMAC _ns1__OpenJobResponse {
      public:
        /// Optional element 'ns1:OpenJobResult' of XSD type 'ns1:LuaValue'
        std::vector<ns1__LuaValue *> OpenJobResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OpenJobResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__OpenJobResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OpenJobResponse, default initialized and not managed by a soap context
        virtual _ns1__OpenJobResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__OpenJobResponse); }
      public:
        /// Constructor with initializations
        _ns1__OpenJobResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__OpenJobResponse() { }
        /// Friend allocator used by soap_new__ns1__OpenJobResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OpenJobResponse * SOAP_FMAC2 soap_instantiate__ns1__OpenJobResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:193 */
#ifndef SOAP_TYPE__ns1__OpenJobExResponse
#define SOAP_TYPE__ns1__OpenJobExResponse (26)
/* complex XSD type 'ns1:OpenJobExResponse': */
class SOAP_CMAC _ns1__OpenJobExResponse {
      public:
        /// Required element 'ns1:OpenJobExResult' of XSD type 'ns1:ArrayOfLuaValue'
        ns1__ArrayOfLuaValue *OpenJobExResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__OpenJobExResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__OpenJobExResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__OpenJobExResponse, default initialized and not managed by a soap context
        virtual _ns1__OpenJobExResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__OpenJobExResponse); }
      public:
        /// Constructor with initializations
        _ns1__OpenJobExResponse()
        {
          OpenJobExResult = (ns1__ArrayOfLuaValue *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__OpenJobExResponse() { }
        /// Friend allocator used by soap_new__ns1__OpenJobExResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__OpenJobExResponse * SOAP_FMAC2 soap_instantiate__ns1__OpenJobExResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:196 */
#ifndef SOAP_TYPE__ns1__RenewLease
#define SOAP_TYPE__ns1__RenewLease (27)
/* complex XSD type 'ns1:RenewLease': */
class SOAP_CMAC _ns1__RenewLease {
      public:
        /// Required element 'ns1:jobID' of XSD type 'xsd:string'
        std::string jobID;
        /// Required element 'ns1:expirationInSeconds' of XSD type 'xsd:double'
        double expirationInSeconds;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RenewLease
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RenewLease; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RenewLease, default initialized and not managed by a soap context
        virtual _ns1__RenewLease *soap_alloc(void) const { return SOAP_NEW(_ns1__RenewLease); }
      public:
        /// Constructor with initializations
        _ns1__RenewLease()
        {
          expirationInSeconds = (double)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RenewLease() { }
        /// Friend allocator used by soap_new__ns1__RenewLease(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RenewLease * SOAP_FMAC2 soap_instantiate__ns1__RenewLease(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:199 */
#ifndef SOAP_TYPE__ns1__RenewLeaseResponse
#define SOAP_TYPE__ns1__RenewLeaseResponse (28)
/* complex XSD type 'ns1:RenewLeaseResponse': */
class SOAP_CMAC _ns1__RenewLeaseResponse {
      public:
        /// Required element 'ns1:RenewLeaseResult' of XSD type 'xsd:double'
        double RenewLeaseResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__RenewLeaseResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__RenewLeaseResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__RenewLeaseResponse, default initialized and not managed by a soap context
        virtual _ns1__RenewLeaseResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__RenewLeaseResponse); }
      public:
        /// Constructor with initializations
        _ns1__RenewLeaseResponse()
        {
          RenewLeaseResult = (double)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__RenewLeaseResponse() { }
        /// Friend allocator used by soap_new__ns1__RenewLeaseResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__RenewLeaseResponse * SOAP_FMAC2 soap_instantiate__ns1__RenewLeaseResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:202 */
#ifndef SOAP_TYPE__ns1__Execute
#define SOAP_TYPE__ns1__Execute (29)
/* complex XSD type 'ns1:Execute': */
class SOAP_CMAC _ns1__Execute {
      public:
        /// Required element 'ns1:jobID' of XSD type 'xsd:string'
        std::string jobID;
        /// Required element 'ns1:script' of XSD type 'ns1:ScriptExecution'
        ns1__ScriptExecution *script;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Execute
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__Execute; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Execute, default initialized and not managed by a soap context
        virtual _ns1__Execute *soap_alloc(void) const { return SOAP_NEW(_ns1__Execute); }
      public:
        /// Constructor with initializations
        _ns1__Execute()
        {
          script = (ns1__ScriptExecution *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__Execute() { }
        /// Friend allocator used by soap_new__ns1__Execute(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Execute * SOAP_FMAC2 soap_instantiate__ns1__Execute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:205 */
#ifndef SOAP_TYPE__ns1__ExecuteResponse
#define SOAP_TYPE__ns1__ExecuteResponse (30)
/* complex XSD type 'ns1:ExecuteResponse': */
class SOAP_CMAC _ns1__ExecuteResponse {
      public:
        /// Required element 'ns1:ExecuteResult' of XSD type 'ns1:LuaValue'
        std::vector<ns1__LuaValue *> ExecuteResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ExecuteResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ExecuteResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ExecuteResponse, default initialized and not managed by a soap context
        virtual _ns1__ExecuteResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ExecuteResponse); }
      public:
        /// Constructor with initializations
        _ns1__ExecuteResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ExecuteResponse() { }
        /// Friend allocator used by soap_new__ns1__ExecuteResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ExecuteResponse * SOAP_FMAC2 soap_instantiate__ns1__ExecuteResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:208 */
#ifndef SOAP_TYPE__ns1__ExecuteEx
#define SOAP_TYPE__ns1__ExecuteEx (31)
/* complex XSD type 'ns1:ExecuteEx': */
class SOAP_CMAC _ns1__ExecuteEx {
      public:
        /// Required element 'ns1:jobID' of XSD type 'xsd:string'
        std::string jobID;
        /// Required element 'ns1:script' of XSD type 'ns1:ScriptExecution'
        ns1__ScriptExecution *script;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ExecuteEx
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ExecuteEx; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ExecuteEx, default initialized and not managed by a soap context
        virtual _ns1__ExecuteEx *soap_alloc(void) const { return SOAP_NEW(_ns1__ExecuteEx); }
      public:
        /// Constructor with initializations
        _ns1__ExecuteEx()
        {
          script = (ns1__ScriptExecution *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ExecuteEx() { }
        /// Friend allocator used by soap_new__ns1__ExecuteEx(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ExecuteEx * SOAP_FMAC2 soap_instantiate__ns1__ExecuteEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:211 */
#ifndef SOAP_TYPE__ns1__ExecuteExResponse
#define SOAP_TYPE__ns1__ExecuteExResponse (32)
/* complex XSD type 'ns1:ExecuteExResponse': */
class SOAP_CMAC _ns1__ExecuteExResponse {
      public:
        /// Required element 'ns1:ExecuteExResult' of XSD type 'ns1:ArrayOfLuaValue'
        ns1__ArrayOfLuaValue *ExecuteExResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__ExecuteExResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__ExecuteExResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__ExecuteExResponse, default initialized and not managed by a soap context
        virtual _ns1__ExecuteExResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__ExecuteExResponse); }
      public:
        /// Constructor with initializations
        _ns1__ExecuteExResponse()
        {
          ExecuteExResult = (ns1__ArrayOfLuaValue *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__ExecuteExResponse() { }
        /// Friend allocator used by soap_new__ns1__ExecuteExResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__ExecuteExResponse * SOAP_FMAC2 soap_instantiate__ns1__ExecuteExResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:214 */
#ifndef SOAP_TYPE__ns1__CloseJob
#define SOAP_TYPE__ns1__CloseJob (33)
/* complex XSD type 'ns1:CloseJob': */
class SOAP_CMAC _ns1__CloseJob {
      public:
        /// Required element 'ns1:jobID' of XSD type 'xsd:string'
        std::string jobID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CloseJob
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CloseJob; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CloseJob, default initialized and not managed by a soap context
        virtual _ns1__CloseJob *soap_alloc(void) const { return SOAP_NEW(_ns1__CloseJob); }
      public:
        /// Constructor with initializations
        _ns1__CloseJob()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CloseJob() { }
        /// Friend allocator used by soap_new__ns1__CloseJob(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CloseJob * SOAP_FMAC2 soap_instantiate__ns1__CloseJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:217 */
#ifndef SOAP_TYPE__ns1__CloseJobResponse
#define SOAP_TYPE__ns1__CloseJobResponse (34)
/* complex XSD type 'ns1:CloseJobResponse': */
class SOAP_CMAC _ns1__CloseJobResponse {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CloseJobResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CloseJobResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CloseJobResponse, default initialized and not managed by a soap context
        virtual _ns1__CloseJobResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CloseJobResponse); }
      public:
        /// Constructor with initializations
        _ns1__CloseJobResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CloseJobResponse() { }
        /// Friend allocator used by soap_new__ns1__CloseJobResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CloseJobResponse * SOAP_FMAC2 soap_instantiate__ns1__CloseJobResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:220 */
#ifndef SOAP_TYPE__ns1__BatchJob
#define SOAP_TYPE__ns1__BatchJob (35)
/* complex XSD type 'ns1:BatchJob': */
class SOAP_CMAC _ns1__BatchJob {
      public:
        /// Required element 'ns1:job' of XSD type 'ns1:Job'
        ns1__Job *job;
        /// Required element 'ns1:script' of XSD type 'ns1:ScriptExecution'
        ns1__ScriptExecution *script;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BatchJob
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BatchJob; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BatchJob, default initialized and not managed by a soap context
        virtual _ns1__BatchJob *soap_alloc(void) const { return SOAP_NEW(_ns1__BatchJob); }
      public:
        /// Constructor with initializations
        _ns1__BatchJob()
        {
          job = (ns1__Job *)0;
          script = (ns1__ScriptExecution *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__BatchJob() { }
        /// Friend allocator used by soap_new__ns1__BatchJob(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BatchJob * SOAP_FMAC2 soap_instantiate__ns1__BatchJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:223 */
#ifndef SOAP_TYPE__ns1__BatchJobResponse
#define SOAP_TYPE__ns1__BatchJobResponse (36)
/* complex XSD type 'ns1:BatchJobResponse': */
class SOAP_CMAC _ns1__BatchJobResponse {
      public:
        /// Required element 'ns1:BatchJobResult' of XSD type 'ns1:LuaValue'
        std::vector<ns1__LuaValue *> BatchJobResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BatchJobResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BatchJobResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BatchJobResponse, default initialized and not managed by a soap context
        virtual _ns1__BatchJobResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__BatchJobResponse); }
      public:
        /// Constructor with initializations
        _ns1__BatchJobResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__BatchJobResponse() { }
        /// Friend allocator used by soap_new__ns1__BatchJobResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BatchJobResponse * SOAP_FMAC2 soap_instantiate__ns1__BatchJobResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:226 */
#ifndef SOAP_TYPE__ns1__BatchJobEx
#define SOAP_TYPE__ns1__BatchJobEx (37)
/* complex XSD type 'ns1:BatchJobEx': */
class SOAP_CMAC _ns1__BatchJobEx {
      public:
        /// Required element 'ns1:job' of XSD type 'ns1:Job'
        ns1__Job *job;
        /// Required element 'ns1:script' of XSD type 'ns1:ScriptExecution'
        ns1__ScriptExecution *script;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BatchJobEx
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BatchJobEx; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BatchJobEx, default initialized and not managed by a soap context
        virtual _ns1__BatchJobEx *soap_alloc(void) const { return SOAP_NEW(_ns1__BatchJobEx); }
      public:
        /// Constructor with initializations
        _ns1__BatchJobEx()
        {
          job = (ns1__Job *)0;
          script = (ns1__ScriptExecution *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__BatchJobEx() { }
        /// Friend allocator used by soap_new__ns1__BatchJobEx(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BatchJobEx * SOAP_FMAC2 soap_instantiate__ns1__BatchJobEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:229 */
#ifndef SOAP_TYPE__ns1__BatchJobExResponse
#define SOAP_TYPE__ns1__BatchJobExResponse (38)
/* complex XSD type 'ns1:BatchJobExResponse': */
class SOAP_CMAC _ns1__BatchJobExResponse {
      public:
        /// Required element 'ns1:BatchJobExResult' of XSD type 'ns1:ArrayOfLuaValue'
        ns1__ArrayOfLuaValue *BatchJobExResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__BatchJobExResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__BatchJobExResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__BatchJobExResponse, default initialized and not managed by a soap context
        virtual _ns1__BatchJobExResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__BatchJobExResponse); }
      public:
        /// Constructor with initializations
        _ns1__BatchJobExResponse()
        {
          BatchJobExResult = (ns1__ArrayOfLuaValue *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__BatchJobExResponse() { }
        /// Friend allocator used by soap_new__ns1__BatchJobExResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__BatchJobExResponse * SOAP_FMAC2 soap_instantiate__ns1__BatchJobExResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:232 */
#ifndef SOAP_TYPE__ns1__GetExpiration
#define SOAP_TYPE__ns1__GetExpiration (39)
/* complex XSD type 'ns1:GetExpiration': */
class SOAP_CMAC _ns1__GetExpiration {
      public:
        /// Required element 'ns1:jobID' of XSD type 'xsd:string'
        std::string jobID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetExpiration
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetExpiration; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetExpiration, default initialized and not managed by a soap context
        virtual _ns1__GetExpiration *soap_alloc(void) const { return SOAP_NEW(_ns1__GetExpiration); }
      public:
        /// Constructor with initializations
        _ns1__GetExpiration()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetExpiration() { }
        /// Friend allocator used by soap_new__ns1__GetExpiration(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetExpiration * SOAP_FMAC2 soap_instantiate__ns1__GetExpiration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:235 */
#ifndef SOAP_TYPE__ns1__GetExpirationResponse
#define SOAP_TYPE__ns1__GetExpirationResponse (40)
/* complex XSD type 'ns1:GetExpirationResponse': */
class SOAP_CMAC _ns1__GetExpirationResponse {
      public:
        /// Required element 'ns1:GetExpirationResult' of XSD type 'xsd:double'
        double GetExpirationResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetExpirationResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetExpirationResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetExpirationResponse, default initialized and not managed by a soap context
        virtual _ns1__GetExpirationResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetExpirationResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetExpirationResponse()
        {
          GetExpirationResult = (double)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetExpirationResponse() { }
        /// Friend allocator used by soap_new__ns1__GetExpirationResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetExpirationResponse * SOAP_FMAC2 soap_instantiate__ns1__GetExpirationResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:238 */
#ifndef SOAP_TYPE__ns1__GetAllJobs
#define SOAP_TYPE__ns1__GetAllJobs (41)
/* complex XSD type 'ns1:GetAllJobs': */
class SOAP_CMAC _ns1__GetAllJobs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAllJobs
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAllJobs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAllJobs, default initialized and not managed by a soap context
        virtual _ns1__GetAllJobs *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAllJobs); }
      public:
        /// Constructor with initializations
        _ns1__GetAllJobs()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetAllJobs() { }
        /// Friend allocator used by soap_new__ns1__GetAllJobs(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAllJobs * SOAP_FMAC2 soap_instantiate__ns1__GetAllJobs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:241 */
#ifndef SOAP_TYPE__ns1__GetAllJobsResponse
#define SOAP_TYPE__ns1__GetAllJobsResponse (42)
/* complex XSD type 'ns1:GetAllJobsResponse': */
class SOAP_CMAC _ns1__GetAllJobsResponse {
      public:
        /// Required element 'ns1:GetAllJobsResult' of XSD type 'ns1:Job'
        std::vector<ns1__Job *> GetAllJobsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAllJobsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAllJobsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAllJobsResponse, default initialized and not managed by a soap context
        virtual _ns1__GetAllJobsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAllJobsResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetAllJobsResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetAllJobsResponse() { }
        /// Friend allocator used by soap_new__ns1__GetAllJobsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAllJobsResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAllJobsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:244 */
#ifndef SOAP_TYPE__ns1__GetAllJobsEx
#define SOAP_TYPE__ns1__GetAllJobsEx (43)
/* complex XSD type 'ns1:GetAllJobsEx': */
class SOAP_CMAC _ns1__GetAllJobsEx {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAllJobsEx
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAllJobsEx; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAllJobsEx, default initialized and not managed by a soap context
        virtual _ns1__GetAllJobsEx *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAllJobsEx); }
      public:
        /// Constructor with initializations
        _ns1__GetAllJobsEx()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetAllJobsEx() { }
        /// Friend allocator used by soap_new__ns1__GetAllJobsEx(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAllJobsEx * SOAP_FMAC2 soap_instantiate__ns1__GetAllJobsEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:247 */
#ifndef SOAP_TYPE__ns1__GetAllJobsExResponse
#define SOAP_TYPE__ns1__GetAllJobsExResponse (44)
/* complex XSD type 'ns1:GetAllJobsExResponse': */
class SOAP_CMAC _ns1__GetAllJobsExResponse {
      public:
        /// Required element 'ns1:GetAllJobsExResult' of XSD type 'ns1:ArrayOfJob'
        ns1__ArrayOfJob *GetAllJobsExResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetAllJobsExResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__GetAllJobsExResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetAllJobsExResponse, default initialized and not managed by a soap context
        virtual _ns1__GetAllJobsExResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__GetAllJobsExResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetAllJobsExResponse()
        {
          GetAllJobsExResult = (ns1__ArrayOfJob *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__GetAllJobsExResponse() { }
        /// Friend allocator used by soap_new__ns1__GetAllJobsExResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetAllJobsExResponse * SOAP_FMAC2 soap_instantiate__ns1__GetAllJobsExResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:250 */
#ifndef SOAP_TYPE__ns1__CloseExpiredJobs
#define SOAP_TYPE__ns1__CloseExpiredJobs (45)
/* complex XSD type 'ns1:CloseExpiredJobs': */
class SOAP_CMAC _ns1__CloseExpiredJobs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CloseExpiredJobs
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CloseExpiredJobs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CloseExpiredJobs, default initialized and not managed by a soap context
        virtual _ns1__CloseExpiredJobs *soap_alloc(void) const { return SOAP_NEW(_ns1__CloseExpiredJobs); }
      public:
        /// Constructor with initializations
        _ns1__CloseExpiredJobs()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CloseExpiredJobs() { }
        /// Friend allocator used by soap_new__ns1__CloseExpiredJobs(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CloseExpiredJobs * SOAP_FMAC2 soap_instantiate__ns1__CloseExpiredJobs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:253 */
#ifndef SOAP_TYPE__ns1__CloseExpiredJobsResponse
#define SOAP_TYPE__ns1__CloseExpiredJobsResponse (46)
/* complex XSD type 'ns1:CloseExpiredJobsResponse': */
class SOAP_CMAC _ns1__CloseExpiredJobsResponse {
      public:
        /// Required element 'ns1:CloseExpiredJobsResult' of XSD type 'xsd:int'
        int CloseExpiredJobsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CloseExpiredJobsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CloseExpiredJobsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CloseExpiredJobsResponse, default initialized and not managed by a soap context
        virtual _ns1__CloseExpiredJobsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CloseExpiredJobsResponse); }
      public:
        /// Constructor with initializations
        _ns1__CloseExpiredJobsResponse()
        {
          CloseExpiredJobsResult = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CloseExpiredJobsResponse() { }
        /// Friend allocator used by soap_new__ns1__CloseExpiredJobsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CloseExpiredJobsResponse * SOAP_FMAC2 soap_instantiate__ns1__CloseExpiredJobsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:256 */
#ifndef SOAP_TYPE__ns1__CloseAllJobs
#define SOAP_TYPE__ns1__CloseAllJobs (47)
/* complex XSD type 'ns1:CloseAllJobs': */
class SOAP_CMAC _ns1__CloseAllJobs {
      public:
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CloseAllJobs
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CloseAllJobs; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CloseAllJobs, default initialized and not managed by a soap context
        virtual _ns1__CloseAllJobs *soap_alloc(void) const { return SOAP_NEW(_ns1__CloseAllJobs); }
      public:
        /// Constructor with initializations
        _ns1__CloseAllJobs()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CloseAllJobs() { }
        /// Friend allocator used by soap_new__ns1__CloseAllJobs(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CloseAllJobs * SOAP_FMAC2 soap_instantiate__ns1__CloseAllJobs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:259 */
#ifndef SOAP_TYPE__ns1__CloseAllJobsResponse
#define SOAP_TYPE__ns1__CloseAllJobsResponse (48)
/* complex XSD type 'ns1:CloseAllJobsResponse': */
class SOAP_CMAC _ns1__CloseAllJobsResponse {
      public:
        /// Required element 'ns1:CloseAllJobsResult' of XSD type 'xsd:int'
        int CloseAllJobsResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__CloseAllJobsResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__CloseAllJobsResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__CloseAllJobsResponse, default initialized and not managed by a soap context
        virtual _ns1__CloseAllJobsResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__CloseAllJobsResponse); }
      public:
        /// Constructor with initializations
        _ns1__CloseAllJobsResponse()
        {
          CloseAllJobsResult = (int)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__CloseAllJobsResponse() { }
        /// Friend allocator used by soap_new__ns1__CloseAllJobsResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__CloseAllJobsResponse * SOAP_FMAC2 soap_instantiate__ns1__CloseAllJobsResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:262 */
#ifndef SOAP_TYPE__ns1__Diag
#define SOAP_TYPE__ns1__Diag (49)
/* complex XSD type 'ns1:Diag': */
class SOAP_CMAC _ns1__Diag {
      public:
        /// Required element 'ns1:type' of XSD type 'xsd:int'
        int type;
        /// Optional element 'ns1:jobID' of XSD type 'xsd:string'
        std::string *jobID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Diag
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__Diag; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Diag, default initialized and not managed by a soap context
        virtual _ns1__Diag *soap_alloc(void) const { return SOAP_NEW(_ns1__Diag); }
      public:
        /// Constructor with initializations
        _ns1__Diag()
        {
          type = (int)0;
          jobID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__Diag() { }
        /// Friend allocator used by soap_new__ns1__Diag(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Diag * SOAP_FMAC2 soap_instantiate__ns1__Diag(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:265 */
#ifndef SOAP_TYPE__ns1__DiagResponse
#define SOAP_TYPE__ns1__DiagResponse (50)
/* complex XSD type 'ns1:DiagResponse': */
class SOAP_CMAC _ns1__DiagResponse {
      public:
        /// Required element 'ns1:DiagResult' of XSD type 'ns1:LuaValue'
        std::vector<ns1__LuaValue *> DiagResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DiagResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DiagResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DiagResponse, default initialized and not managed by a soap context
        virtual _ns1__DiagResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DiagResponse); }
      public:
        /// Constructor with initializations
        _ns1__DiagResponse()
        {
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DiagResponse() { }
        /// Friend allocator used by soap_new__ns1__DiagResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DiagResponse * SOAP_FMAC2 soap_instantiate__ns1__DiagResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:268 */
#ifndef SOAP_TYPE__ns1__DiagEx
#define SOAP_TYPE__ns1__DiagEx (51)
/* complex XSD type 'ns1:DiagEx': */
class SOAP_CMAC _ns1__DiagEx {
      public:
        /// Required element 'ns1:type' of XSD type 'xsd:int'
        int type;
        /// Optional element 'ns1:jobID' of XSD type 'xsd:string'
        std::string *jobID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DiagEx
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DiagEx; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DiagEx, default initialized and not managed by a soap context
        virtual _ns1__DiagEx *soap_alloc(void) const { return SOAP_NEW(_ns1__DiagEx); }
      public:
        /// Constructor with initializations
        _ns1__DiagEx()
        {
          type = (int)0;
          jobID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DiagEx() { }
        /// Friend allocator used by soap_new__ns1__DiagEx(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DiagEx * SOAP_FMAC2 soap_instantiate__ns1__DiagEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:271 */
#ifndef SOAP_TYPE__ns1__DiagExResponse
#define SOAP_TYPE__ns1__DiagExResponse (52)
/* complex XSD type 'ns1:DiagExResponse': */
class SOAP_CMAC _ns1__DiagExResponse {
      public:
        /// Required element 'ns1:DiagExResult' of XSD type 'ns1:ArrayOfLuaValue'
        ns1__ArrayOfLuaValue *DiagExResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DiagExResponse
        virtual int soap_type(void) const { return SOAP_TYPE__ns1__DiagExResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DiagExResponse, default initialized and not managed by a soap context
        virtual _ns1__DiagExResponse *soap_alloc(void) const { return SOAP_NEW(_ns1__DiagExResponse); }
      public:
        /// Constructor with initializations
        _ns1__DiagExResponse()
        {
          DiagExResult = (ns1__ArrayOfLuaValue *)0;
          soap = (struct soap *)0;
        }
        virtual ~_ns1__DiagExResponse() { }
        /// Friend allocator used by soap_new__ns1__DiagExResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DiagExResponse * SOAP_FMAC2 soap_instantiate__ns1__DiagExResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:1403 */
#ifndef SOAP_TYPE___ns1__HelloWorld
#define SOAP_TYPE___ns1__HelloWorld (69)
/* Wrapper: */
struct SOAP_CMAC __ns1__HelloWorld {
      public:
        /** Optional element 'ns1:HelloWorld' of XSD type 'ns1:HelloWorld' */
        _ns1__HelloWorld *ns1__HelloWorld;
      public:
        /** Return unique type id SOAP_TYPE___ns1__HelloWorld */
        int soap_type() const { return SOAP_TYPE___ns1__HelloWorld; }
        /** Constructor with member initializations */
        __ns1__HelloWorld()
        {
          ns1__HelloWorld = (_ns1__HelloWorld *)0;
        }
        /** Friend allocator used by soap_new___ns1__HelloWorld(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__HelloWorld * SOAP_FMAC2 soap_instantiate___ns1__HelloWorld(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:1470 */
#ifndef SOAP_TYPE___ns1__GetVersion
#define SOAP_TYPE___ns1__GetVersion (73)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetVersion {
      public:
        /** Optional element 'ns1:GetVersion' of XSD type 'ns1:GetVersion' */
        _ns1__GetVersion *ns1__GetVersion;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetVersion */
        int soap_type() const { return SOAP_TYPE___ns1__GetVersion; }
        /** Constructor with member initializations */
        __ns1__GetVersion()
        {
          ns1__GetVersion = (_ns1__GetVersion *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetVersion(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetVersion * SOAP_FMAC2 soap_instantiate___ns1__GetVersion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:1537 */
#ifndef SOAP_TYPE___ns1__GetStatus
#define SOAP_TYPE___ns1__GetStatus (77)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetStatus {
      public:
        /** Optional element 'ns1:GetStatus' of XSD type 'ns1:GetStatus' */
        _ns1__GetStatus *ns1__GetStatus;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetStatus */
        int soap_type() const { return SOAP_TYPE___ns1__GetStatus; }
        /** Constructor with member initializations */
        __ns1__GetStatus()
        {
          ns1__GetStatus = (_ns1__GetStatus *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetStatus(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetStatus * SOAP_FMAC2 soap_instantiate___ns1__GetStatus(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:1604 */
#ifndef SOAP_TYPE___ns1__OpenJob
#define SOAP_TYPE___ns1__OpenJob (81)
/* Wrapper: */
struct SOAP_CMAC __ns1__OpenJob {
      public:
        /** Optional element 'ns1:OpenJob' of XSD type 'ns1:OpenJob' */
        _ns1__OpenJob *ns1__OpenJob;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OpenJob */
        int soap_type() const { return SOAP_TYPE___ns1__OpenJob; }
        /** Constructor with member initializations */
        __ns1__OpenJob()
        {
          ns1__OpenJob = (_ns1__OpenJob *)0;
        }
        /** Friend allocator used by soap_new___ns1__OpenJob(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__OpenJob * SOAP_FMAC2 soap_instantiate___ns1__OpenJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:1671 */
#ifndef SOAP_TYPE___ns1__OpenJobEx
#define SOAP_TYPE___ns1__OpenJobEx (85)
/* Wrapper: */
struct SOAP_CMAC __ns1__OpenJobEx {
      public:
        /** Optional element 'ns1:OpenJobEx' of XSD type 'ns1:OpenJobEx' */
        _ns1__OpenJobEx *ns1__OpenJobEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OpenJobEx */
        int soap_type() const { return SOAP_TYPE___ns1__OpenJobEx; }
        /** Constructor with member initializations */
        __ns1__OpenJobEx()
        {
          ns1__OpenJobEx = (_ns1__OpenJobEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__OpenJobEx(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__OpenJobEx * SOAP_FMAC2 soap_instantiate___ns1__OpenJobEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:1738 */
#ifndef SOAP_TYPE___ns1__RenewLease
#define SOAP_TYPE___ns1__RenewLease (89)
/* Wrapper: */
struct SOAP_CMAC __ns1__RenewLease {
      public:
        /** Optional element 'ns1:RenewLease' of XSD type 'ns1:RenewLease' */
        _ns1__RenewLease *ns1__RenewLease;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RenewLease */
        int soap_type() const { return SOAP_TYPE___ns1__RenewLease; }
        /** Constructor with member initializations */
        __ns1__RenewLease()
        {
          ns1__RenewLease = (_ns1__RenewLease *)0;
        }
        /** Friend allocator used by soap_new___ns1__RenewLease(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__RenewLease * SOAP_FMAC2 soap_instantiate___ns1__RenewLease(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:1805 */
#ifndef SOAP_TYPE___ns1__Execute
#define SOAP_TYPE___ns1__Execute (93)
/* Wrapper: */
struct SOAP_CMAC __ns1__Execute {
      public:
        /** Optional element 'ns1:Execute' of XSD type 'ns1:Execute' */
        _ns1__Execute *ns1__Execute;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Execute */
        int soap_type() const { return SOAP_TYPE___ns1__Execute; }
        /** Constructor with member initializations */
        __ns1__Execute()
        {
          ns1__Execute = (_ns1__Execute *)0;
        }
        /** Friend allocator used by soap_new___ns1__Execute(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__Execute * SOAP_FMAC2 soap_instantiate___ns1__Execute(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:1872 */
#ifndef SOAP_TYPE___ns1__ExecuteEx
#define SOAP_TYPE___ns1__ExecuteEx (97)
/* Wrapper: */
struct SOAP_CMAC __ns1__ExecuteEx {
      public:
        /** Optional element 'ns1:ExecuteEx' of XSD type 'ns1:ExecuteEx' */
        _ns1__ExecuteEx *ns1__ExecuteEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ExecuteEx */
        int soap_type() const { return SOAP_TYPE___ns1__ExecuteEx; }
        /** Constructor with member initializations */
        __ns1__ExecuteEx()
        {
          ns1__ExecuteEx = (_ns1__ExecuteEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__ExecuteEx(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ExecuteEx * SOAP_FMAC2 soap_instantiate___ns1__ExecuteEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:1939 */
#ifndef SOAP_TYPE___ns1__CloseJob
#define SOAP_TYPE___ns1__CloseJob (101)
/* Wrapper: */
struct SOAP_CMAC __ns1__CloseJob {
      public:
        /** Optional element 'ns1:CloseJob' of XSD type 'ns1:CloseJob' */
        _ns1__CloseJob *ns1__CloseJob;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CloseJob */
        int soap_type() const { return SOAP_TYPE___ns1__CloseJob; }
        /** Constructor with member initializations */
        __ns1__CloseJob()
        {
          ns1__CloseJob = (_ns1__CloseJob *)0;
        }
        /** Friend allocator used by soap_new___ns1__CloseJob(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CloseJob * SOAP_FMAC2 soap_instantiate___ns1__CloseJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2006 */
#ifndef SOAP_TYPE___ns1__BatchJob
#define SOAP_TYPE___ns1__BatchJob (105)
/* Wrapper: */
struct SOAP_CMAC __ns1__BatchJob {
      public:
        /** Optional element 'ns1:BatchJob' of XSD type 'ns1:BatchJob' */
        _ns1__BatchJob *ns1__BatchJob;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BatchJob */
        int soap_type() const { return SOAP_TYPE___ns1__BatchJob; }
        /** Constructor with member initializations */
        __ns1__BatchJob()
        {
          ns1__BatchJob = (_ns1__BatchJob *)0;
        }
        /** Friend allocator used by soap_new___ns1__BatchJob(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__BatchJob * SOAP_FMAC2 soap_instantiate___ns1__BatchJob(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2073 */
#ifndef SOAP_TYPE___ns1__BatchJobEx
#define SOAP_TYPE___ns1__BatchJobEx (109)
/* Wrapper: */
struct SOAP_CMAC __ns1__BatchJobEx {
      public:
        /** Optional element 'ns1:BatchJobEx' of XSD type 'ns1:BatchJobEx' */
        _ns1__BatchJobEx *ns1__BatchJobEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BatchJobEx */
        int soap_type() const { return SOAP_TYPE___ns1__BatchJobEx; }
        /** Constructor with member initializations */
        __ns1__BatchJobEx()
        {
          ns1__BatchJobEx = (_ns1__BatchJobEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__BatchJobEx(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__BatchJobEx * SOAP_FMAC2 soap_instantiate___ns1__BatchJobEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2140 */
#ifndef SOAP_TYPE___ns1__GetExpiration
#define SOAP_TYPE___ns1__GetExpiration (113)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetExpiration {
      public:
        /** Optional element 'ns1:GetExpiration' of XSD type 'ns1:GetExpiration' */
        _ns1__GetExpiration *ns1__GetExpiration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetExpiration */
        int soap_type() const { return SOAP_TYPE___ns1__GetExpiration; }
        /** Constructor with member initializations */
        __ns1__GetExpiration()
        {
          ns1__GetExpiration = (_ns1__GetExpiration *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetExpiration(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetExpiration * SOAP_FMAC2 soap_instantiate___ns1__GetExpiration(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2207 */
#ifndef SOAP_TYPE___ns1__GetAllJobs
#define SOAP_TYPE___ns1__GetAllJobs (117)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAllJobs {
      public:
        /** Optional element 'ns1:GetAllJobs' of XSD type 'ns1:GetAllJobs' */
        _ns1__GetAllJobs *ns1__GetAllJobs;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAllJobs */
        int soap_type() const { return SOAP_TYPE___ns1__GetAllJobs; }
        /** Constructor with member initializations */
        __ns1__GetAllJobs()
        {
          ns1__GetAllJobs = (_ns1__GetAllJobs *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetAllJobs(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetAllJobs * SOAP_FMAC2 soap_instantiate___ns1__GetAllJobs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2274 */
#ifndef SOAP_TYPE___ns1__GetAllJobsEx
#define SOAP_TYPE___ns1__GetAllJobsEx (121)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAllJobsEx {
      public:
        /** Optional element 'ns1:GetAllJobsEx' of XSD type 'ns1:GetAllJobsEx' */
        _ns1__GetAllJobsEx *ns1__GetAllJobsEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAllJobsEx */
        int soap_type() const { return SOAP_TYPE___ns1__GetAllJobsEx; }
        /** Constructor with member initializations */
        __ns1__GetAllJobsEx()
        {
          ns1__GetAllJobsEx = (_ns1__GetAllJobsEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetAllJobsEx(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetAllJobsEx * SOAP_FMAC2 soap_instantiate___ns1__GetAllJobsEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2341 */
#ifndef SOAP_TYPE___ns1__CloseExpiredJobs
#define SOAP_TYPE___ns1__CloseExpiredJobs (125)
/* Wrapper: */
struct SOAP_CMAC __ns1__CloseExpiredJobs {
      public:
        /** Optional element 'ns1:CloseExpiredJobs' of XSD type 'ns1:CloseExpiredJobs' */
        _ns1__CloseExpiredJobs *ns1__CloseExpiredJobs;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CloseExpiredJobs */
        int soap_type() const { return SOAP_TYPE___ns1__CloseExpiredJobs; }
        /** Constructor with member initializations */
        __ns1__CloseExpiredJobs()
        {
          ns1__CloseExpiredJobs = (_ns1__CloseExpiredJobs *)0;
        }
        /** Friend allocator used by soap_new___ns1__CloseExpiredJobs(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CloseExpiredJobs * SOAP_FMAC2 soap_instantiate___ns1__CloseExpiredJobs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2408 */
#ifndef SOAP_TYPE___ns1__CloseAllJobs
#define SOAP_TYPE___ns1__CloseAllJobs (129)
/* Wrapper: */
struct SOAP_CMAC __ns1__CloseAllJobs {
      public:
        /** Optional element 'ns1:CloseAllJobs' of XSD type 'ns1:CloseAllJobs' */
        _ns1__CloseAllJobs *ns1__CloseAllJobs;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CloseAllJobs */
        int soap_type() const { return SOAP_TYPE___ns1__CloseAllJobs; }
        /** Constructor with member initializations */
        __ns1__CloseAllJobs()
        {
          ns1__CloseAllJobs = (_ns1__CloseAllJobs *)0;
        }
        /** Friend allocator used by soap_new___ns1__CloseAllJobs(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CloseAllJobs * SOAP_FMAC2 soap_instantiate___ns1__CloseAllJobs(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2475 */
#ifndef SOAP_TYPE___ns1__Diag
#define SOAP_TYPE___ns1__Diag (133)
/* Wrapper: */
struct SOAP_CMAC __ns1__Diag {
      public:
        /** Optional element 'ns1:Diag' of XSD type 'ns1:Diag' */
        _ns1__Diag *ns1__Diag;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Diag */
        int soap_type() const { return SOAP_TYPE___ns1__Diag; }
        /** Constructor with member initializations */
        __ns1__Diag()
        {
          ns1__Diag = (_ns1__Diag *)0;
        }
        /** Friend allocator used by soap_new___ns1__Diag(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__Diag * SOAP_FMAC2 soap_instantiate___ns1__Diag(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2542 */
#ifndef SOAP_TYPE___ns1__DiagEx
#define SOAP_TYPE___ns1__DiagEx (137)
/* Wrapper: */
struct SOAP_CMAC __ns1__DiagEx {
      public:
        /** Optional element 'ns1:DiagEx' of XSD type 'ns1:DiagEx' */
        _ns1__DiagEx *ns1__DiagEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DiagEx */
        int soap_type() const { return SOAP_TYPE___ns1__DiagEx; }
        /** Constructor with member initializations */
        __ns1__DiagEx()
        {
          ns1__DiagEx = (_ns1__DiagEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__DiagEx(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__DiagEx * SOAP_FMAC2 soap_instantiate___ns1__DiagEx(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2609 */
#ifndef SOAP_TYPE___ns1__HelloWorld_
#define SOAP_TYPE___ns1__HelloWorld_ (139)
/* Wrapper: */
struct SOAP_CMAC __ns1__HelloWorld_ {
      public:
        /** Optional element 'ns1:HelloWorld' of XSD type 'ns1:HelloWorld' */
        _ns1__HelloWorld *ns1__HelloWorld;
      public:
        /** Return unique type id SOAP_TYPE___ns1__HelloWorld_ */
        int soap_type() const { return SOAP_TYPE___ns1__HelloWorld_; }
        /** Constructor with member initializations */
        __ns1__HelloWorld_()
        {
          ns1__HelloWorld = (_ns1__HelloWorld *)0;
        }
        /** Friend allocator used by soap_new___ns1__HelloWorld_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__HelloWorld_ * SOAP_FMAC2 soap_instantiate___ns1__HelloWorld_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2676 */
#ifndef SOAP_TYPE___ns1__GetVersion_
#define SOAP_TYPE___ns1__GetVersion_ (141)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetVersion_ {
      public:
        /** Optional element 'ns1:GetVersion' of XSD type 'ns1:GetVersion' */
        _ns1__GetVersion *ns1__GetVersion;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetVersion_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetVersion_; }
        /** Constructor with member initializations */
        __ns1__GetVersion_()
        {
          ns1__GetVersion = (_ns1__GetVersion *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetVersion_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetVersion_ * SOAP_FMAC2 soap_instantiate___ns1__GetVersion_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2743 */
#ifndef SOAP_TYPE___ns1__GetStatus_
#define SOAP_TYPE___ns1__GetStatus_ (143)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetStatus_ {
      public:
        /** Optional element 'ns1:GetStatus' of XSD type 'ns1:GetStatus' */
        _ns1__GetStatus *ns1__GetStatus;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetStatus_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetStatus_; }
        /** Constructor with member initializations */
        __ns1__GetStatus_()
        {
          ns1__GetStatus = (_ns1__GetStatus *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetStatus_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetStatus_ * SOAP_FMAC2 soap_instantiate___ns1__GetStatus_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2810 */
#ifndef SOAP_TYPE___ns1__OpenJob_
#define SOAP_TYPE___ns1__OpenJob_ (145)
/* Wrapper: */
struct SOAP_CMAC __ns1__OpenJob_ {
      public:
        /** Optional element 'ns1:OpenJob' of XSD type 'ns1:OpenJob' */
        _ns1__OpenJob *ns1__OpenJob;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OpenJob_ */
        int soap_type() const { return SOAP_TYPE___ns1__OpenJob_; }
        /** Constructor with member initializations */
        __ns1__OpenJob_()
        {
          ns1__OpenJob = (_ns1__OpenJob *)0;
        }
        /** Friend allocator used by soap_new___ns1__OpenJob_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__OpenJob_ * SOAP_FMAC2 soap_instantiate___ns1__OpenJob_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2877 */
#ifndef SOAP_TYPE___ns1__OpenJobEx_
#define SOAP_TYPE___ns1__OpenJobEx_ (147)
/* Wrapper: */
struct SOAP_CMAC __ns1__OpenJobEx_ {
      public:
        /** Optional element 'ns1:OpenJobEx' of XSD type 'ns1:OpenJobEx' */
        _ns1__OpenJobEx *ns1__OpenJobEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__OpenJobEx_ */
        int soap_type() const { return SOAP_TYPE___ns1__OpenJobEx_; }
        /** Constructor with member initializations */
        __ns1__OpenJobEx_()
        {
          ns1__OpenJobEx = (_ns1__OpenJobEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__OpenJobEx_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__OpenJobEx_ * SOAP_FMAC2 soap_instantiate___ns1__OpenJobEx_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:2944 */
#ifndef SOAP_TYPE___ns1__RenewLease_
#define SOAP_TYPE___ns1__RenewLease_ (149)
/* Wrapper: */
struct SOAP_CMAC __ns1__RenewLease_ {
      public:
        /** Optional element 'ns1:RenewLease' of XSD type 'ns1:RenewLease' */
        _ns1__RenewLease *ns1__RenewLease;
      public:
        /** Return unique type id SOAP_TYPE___ns1__RenewLease_ */
        int soap_type() const { return SOAP_TYPE___ns1__RenewLease_; }
        /** Constructor with member initializations */
        __ns1__RenewLease_()
        {
          ns1__RenewLease = (_ns1__RenewLease *)0;
        }
        /** Friend allocator used by soap_new___ns1__RenewLease_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__RenewLease_ * SOAP_FMAC2 soap_instantiate___ns1__RenewLease_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3011 */
#ifndef SOAP_TYPE___ns1__Execute_
#define SOAP_TYPE___ns1__Execute_ (151)
/* Wrapper: */
struct SOAP_CMAC __ns1__Execute_ {
      public:
        /** Optional element 'ns1:Execute' of XSD type 'ns1:Execute' */
        _ns1__Execute *ns1__Execute;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Execute_ */
        int soap_type() const { return SOAP_TYPE___ns1__Execute_; }
        /** Constructor with member initializations */
        __ns1__Execute_()
        {
          ns1__Execute = (_ns1__Execute *)0;
        }
        /** Friend allocator used by soap_new___ns1__Execute_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__Execute_ * SOAP_FMAC2 soap_instantiate___ns1__Execute_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3078 */
#ifndef SOAP_TYPE___ns1__ExecuteEx_
#define SOAP_TYPE___ns1__ExecuteEx_ (153)
/* Wrapper: */
struct SOAP_CMAC __ns1__ExecuteEx_ {
      public:
        /** Optional element 'ns1:ExecuteEx' of XSD type 'ns1:ExecuteEx' */
        _ns1__ExecuteEx *ns1__ExecuteEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__ExecuteEx_ */
        int soap_type() const { return SOAP_TYPE___ns1__ExecuteEx_; }
        /** Constructor with member initializations */
        __ns1__ExecuteEx_()
        {
          ns1__ExecuteEx = (_ns1__ExecuteEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__ExecuteEx_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__ExecuteEx_ * SOAP_FMAC2 soap_instantiate___ns1__ExecuteEx_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3145 */
#ifndef SOAP_TYPE___ns1__CloseJob_
#define SOAP_TYPE___ns1__CloseJob_ (155)
/* Wrapper: */
struct SOAP_CMAC __ns1__CloseJob_ {
      public:
        /** Optional element 'ns1:CloseJob' of XSD type 'ns1:CloseJob' */
        _ns1__CloseJob *ns1__CloseJob;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CloseJob_ */
        int soap_type() const { return SOAP_TYPE___ns1__CloseJob_; }
        /** Constructor with member initializations */
        __ns1__CloseJob_()
        {
          ns1__CloseJob = (_ns1__CloseJob *)0;
        }
        /** Friend allocator used by soap_new___ns1__CloseJob_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CloseJob_ * SOAP_FMAC2 soap_instantiate___ns1__CloseJob_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3212 */
#ifndef SOAP_TYPE___ns1__BatchJob_
#define SOAP_TYPE___ns1__BatchJob_ (157)
/* Wrapper: */
struct SOAP_CMAC __ns1__BatchJob_ {
      public:
        /** Optional element 'ns1:BatchJob' of XSD type 'ns1:BatchJob' */
        _ns1__BatchJob *ns1__BatchJob;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BatchJob_ */
        int soap_type() const { return SOAP_TYPE___ns1__BatchJob_; }
        /** Constructor with member initializations */
        __ns1__BatchJob_()
        {
          ns1__BatchJob = (_ns1__BatchJob *)0;
        }
        /** Friend allocator used by soap_new___ns1__BatchJob_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__BatchJob_ * SOAP_FMAC2 soap_instantiate___ns1__BatchJob_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3279 */
#ifndef SOAP_TYPE___ns1__BatchJobEx_
#define SOAP_TYPE___ns1__BatchJobEx_ (159)
/* Wrapper: */
struct SOAP_CMAC __ns1__BatchJobEx_ {
      public:
        /** Optional element 'ns1:BatchJobEx' of XSD type 'ns1:BatchJobEx' */
        _ns1__BatchJobEx *ns1__BatchJobEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__BatchJobEx_ */
        int soap_type() const { return SOAP_TYPE___ns1__BatchJobEx_; }
        /** Constructor with member initializations */
        __ns1__BatchJobEx_()
        {
          ns1__BatchJobEx = (_ns1__BatchJobEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__BatchJobEx_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__BatchJobEx_ * SOAP_FMAC2 soap_instantiate___ns1__BatchJobEx_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3346 */
#ifndef SOAP_TYPE___ns1__GetExpiration_
#define SOAP_TYPE___ns1__GetExpiration_ (161)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetExpiration_ {
      public:
        /** Optional element 'ns1:GetExpiration' of XSD type 'ns1:GetExpiration' */
        _ns1__GetExpiration *ns1__GetExpiration;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetExpiration_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetExpiration_; }
        /** Constructor with member initializations */
        __ns1__GetExpiration_()
        {
          ns1__GetExpiration = (_ns1__GetExpiration *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetExpiration_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetExpiration_ * SOAP_FMAC2 soap_instantiate___ns1__GetExpiration_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3413 */
#ifndef SOAP_TYPE___ns1__GetAllJobs_
#define SOAP_TYPE___ns1__GetAllJobs_ (163)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAllJobs_ {
      public:
        /** Optional element 'ns1:GetAllJobs' of XSD type 'ns1:GetAllJobs' */
        _ns1__GetAllJobs *ns1__GetAllJobs;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAllJobs_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetAllJobs_; }
        /** Constructor with member initializations */
        __ns1__GetAllJobs_()
        {
          ns1__GetAllJobs = (_ns1__GetAllJobs *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetAllJobs_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetAllJobs_ * SOAP_FMAC2 soap_instantiate___ns1__GetAllJobs_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3480 */
#ifndef SOAP_TYPE___ns1__GetAllJobsEx_
#define SOAP_TYPE___ns1__GetAllJobsEx_ (165)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetAllJobsEx_ {
      public:
        /** Optional element 'ns1:GetAllJobsEx' of XSD type 'ns1:GetAllJobsEx' */
        _ns1__GetAllJobsEx *ns1__GetAllJobsEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetAllJobsEx_ */
        int soap_type() const { return SOAP_TYPE___ns1__GetAllJobsEx_; }
        /** Constructor with member initializations */
        __ns1__GetAllJobsEx_()
        {
          ns1__GetAllJobsEx = (_ns1__GetAllJobsEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__GetAllJobsEx_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__GetAllJobsEx_ * SOAP_FMAC2 soap_instantiate___ns1__GetAllJobsEx_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3547 */
#ifndef SOAP_TYPE___ns1__CloseExpiredJobs_
#define SOAP_TYPE___ns1__CloseExpiredJobs_ (167)
/* Wrapper: */
struct SOAP_CMAC __ns1__CloseExpiredJobs_ {
      public:
        /** Optional element 'ns1:CloseExpiredJobs' of XSD type 'ns1:CloseExpiredJobs' */
        _ns1__CloseExpiredJobs *ns1__CloseExpiredJobs;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CloseExpiredJobs_ */
        int soap_type() const { return SOAP_TYPE___ns1__CloseExpiredJobs_; }
        /** Constructor with member initializations */
        __ns1__CloseExpiredJobs_()
        {
          ns1__CloseExpiredJobs = (_ns1__CloseExpiredJobs *)0;
        }
        /** Friend allocator used by soap_new___ns1__CloseExpiredJobs_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CloseExpiredJobs_ * SOAP_FMAC2 soap_instantiate___ns1__CloseExpiredJobs_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3614 */
#ifndef SOAP_TYPE___ns1__CloseAllJobs_
#define SOAP_TYPE___ns1__CloseAllJobs_ (169)
/* Wrapper: */
struct SOAP_CMAC __ns1__CloseAllJobs_ {
      public:
        /** Optional element 'ns1:CloseAllJobs' of XSD type 'ns1:CloseAllJobs' */
        _ns1__CloseAllJobs *ns1__CloseAllJobs;
      public:
        /** Return unique type id SOAP_TYPE___ns1__CloseAllJobs_ */
        int soap_type() const { return SOAP_TYPE___ns1__CloseAllJobs_; }
        /** Constructor with member initializations */
        __ns1__CloseAllJobs_()
        {
          ns1__CloseAllJobs = (_ns1__CloseAllJobs *)0;
        }
        /** Friend allocator used by soap_new___ns1__CloseAllJobs_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__CloseAllJobs_ * SOAP_FMAC2 soap_instantiate___ns1__CloseAllJobs_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3681 */
#ifndef SOAP_TYPE___ns1__Diag_
#define SOAP_TYPE___ns1__Diag_ (171)
/* Wrapper: */
struct SOAP_CMAC __ns1__Diag_ {
      public:
        /** Optional element 'ns1:Diag' of XSD type 'ns1:Diag' */
        _ns1__Diag *ns1__Diag;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Diag_ */
        int soap_type() const { return SOAP_TYPE___ns1__Diag_; }
        /** Constructor with member initializations */
        __ns1__Diag_()
        {
          ns1__Diag = (_ns1__Diag *)0;
        }
        /** Friend allocator used by soap_new___ns1__Diag_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__Diag_ * SOAP_FMAC2 soap_instantiate___ns1__Diag_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:3748 */
#ifndef SOAP_TYPE___ns1__DiagEx_
#define SOAP_TYPE___ns1__DiagEx_ (173)
/* Wrapper: */
struct SOAP_CMAC __ns1__DiagEx_ {
      public:
        /** Optional element 'ns1:DiagEx' of XSD type 'ns1:DiagEx' */
        _ns1__DiagEx *ns1__DiagEx;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DiagEx_ */
        int soap_type() const { return SOAP_TYPE___ns1__DiagEx_; }
        /** Constructor with member initializations */
        __ns1__DiagEx_()
        {
          ns1__DiagEx = (_ns1__DiagEx *)0;
        }
        /** Friend allocator used by soap_new___ns1__DiagEx_(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__DiagEx_ * SOAP_FMAC2 soap_instantiate___ns1__DiagEx_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* generated/prototypes.h:4349 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (174)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* generated/prototypes.h:4349 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (175)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* generated/prototypes.h:4349 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (177)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* generated/prototypes.h:4349 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (180)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* generated/prototypes.h:4349 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (181)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* generated/prototypes.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* generated/prototypes.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* double has binding name 'double' for type 'xsd:double' */
#ifndef SOAP_TYPE_double
#define SOAP_TYPE_double (57)
#endif

/* enum ns1__LuaType has binding name 'ns1__LuaType' for type 'ns1:LuaType' */
#ifndef SOAP_TYPE_ns1__LuaType
#define SOAP_TYPE_ns1__LuaType (53)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (54)
#endif

/* _ns1__DiagExResponse has binding name '_ns1__DiagExResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DiagExResponse
#define SOAP_TYPE__ns1__DiagExResponse (52)
#endif

/* _ns1__DiagEx has binding name '_ns1__DiagEx' for type '' */
#ifndef SOAP_TYPE__ns1__DiagEx
#define SOAP_TYPE__ns1__DiagEx (51)
#endif

/* _ns1__DiagResponse has binding name '_ns1__DiagResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DiagResponse
#define SOAP_TYPE__ns1__DiagResponse (50)
#endif

/* _ns1__Diag has binding name '_ns1__Diag' for type '' */
#ifndef SOAP_TYPE__ns1__Diag
#define SOAP_TYPE__ns1__Diag (49)
#endif

/* _ns1__CloseAllJobsResponse has binding name '_ns1__CloseAllJobsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CloseAllJobsResponse
#define SOAP_TYPE__ns1__CloseAllJobsResponse (48)
#endif

/* _ns1__CloseAllJobs has binding name '_ns1__CloseAllJobs' for type '' */
#ifndef SOAP_TYPE__ns1__CloseAllJobs
#define SOAP_TYPE__ns1__CloseAllJobs (47)
#endif

/* _ns1__CloseExpiredJobsResponse has binding name '_ns1__CloseExpiredJobsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CloseExpiredJobsResponse
#define SOAP_TYPE__ns1__CloseExpiredJobsResponse (46)
#endif

/* _ns1__CloseExpiredJobs has binding name '_ns1__CloseExpiredJobs' for type '' */
#ifndef SOAP_TYPE__ns1__CloseExpiredJobs
#define SOAP_TYPE__ns1__CloseExpiredJobs (45)
#endif

/* _ns1__GetAllJobsExResponse has binding name '_ns1__GetAllJobsExResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetAllJobsExResponse
#define SOAP_TYPE__ns1__GetAllJobsExResponse (44)
#endif

/* _ns1__GetAllJobsEx has binding name '_ns1__GetAllJobsEx' for type '' */
#ifndef SOAP_TYPE__ns1__GetAllJobsEx
#define SOAP_TYPE__ns1__GetAllJobsEx (43)
#endif

/* _ns1__GetAllJobsResponse has binding name '_ns1__GetAllJobsResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetAllJobsResponse
#define SOAP_TYPE__ns1__GetAllJobsResponse (42)
#endif

/* _ns1__GetAllJobs has binding name '_ns1__GetAllJobs' for type '' */
#ifndef SOAP_TYPE__ns1__GetAllJobs
#define SOAP_TYPE__ns1__GetAllJobs (41)
#endif

/* _ns1__GetExpirationResponse has binding name '_ns1__GetExpirationResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetExpirationResponse
#define SOAP_TYPE__ns1__GetExpirationResponse (40)
#endif

/* _ns1__GetExpiration has binding name '_ns1__GetExpiration' for type '' */
#ifndef SOAP_TYPE__ns1__GetExpiration
#define SOAP_TYPE__ns1__GetExpiration (39)
#endif

/* _ns1__BatchJobExResponse has binding name '_ns1__BatchJobExResponse' for type '' */
#ifndef SOAP_TYPE__ns1__BatchJobExResponse
#define SOAP_TYPE__ns1__BatchJobExResponse (38)
#endif

/* _ns1__BatchJobEx has binding name '_ns1__BatchJobEx' for type '' */
#ifndef SOAP_TYPE__ns1__BatchJobEx
#define SOAP_TYPE__ns1__BatchJobEx (37)
#endif

/* _ns1__BatchJobResponse has binding name '_ns1__BatchJobResponse' for type '' */
#ifndef SOAP_TYPE__ns1__BatchJobResponse
#define SOAP_TYPE__ns1__BatchJobResponse (36)
#endif

/* _ns1__BatchJob has binding name '_ns1__BatchJob' for type '' */
#ifndef SOAP_TYPE__ns1__BatchJob
#define SOAP_TYPE__ns1__BatchJob (35)
#endif

/* _ns1__CloseJobResponse has binding name '_ns1__CloseJobResponse' for type '' */
#ifndef SOAP_TYPE__ns1__CloseJobResponse
#define SOAP_TYPE__ns1__CloseJobResponse (34)
#endif

/* _ns1__CloseJob has binding name '_ns1__CloseJob' for type '' */
#ifndef SOAP_TYPE__ns1__CloseJob
#define SOAP_TYPE__ns1__CloseJob (33)
#endif

/* _ns1__ExecuteExResponse has binding name '_ns1__ExecuteExResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ExecuteExResponse
#define SOAP_TYPE__ns1__ExecuteExResponse (32)
#endif

/* _ns1__ExecuteEx has binding name '_ns1__ExecuteEx' for type '' */
#ifndef SOAP_TYPE__ns1__ExecuteEx
#define SOAP_TYPE__ns1__ExecuteEx (31)
#endif

/* _ns1__ExecuteResponse has binding name '_ns1__ExecuteResponse' for type '' */
#ifndef SOAP_TYPE__ns1__ExecuteResponse
#define SOAP_TYPE__ns1__ExecuteResponse (30)
#endif

/* _ns1__Execute has binding name '_ns1__Execute' for type '' */
#ifndef SOAP_TYPE__ns1__Execute
#define SOAP_TYPE__ns1__Execute (29)
#endif

/* _ns1__RenewLeaseResponse has binding name '_ns1__RenewLeaseResponse' for type '' */
#ifndef SOAP_TYPE__ns1__RenewLeaseResponse
#define SOAP_TYPE__ns1__RenewLeaseResponse (28)
#endif

/* _ns1__RenewLease has binding name '_ns1__RenewLease' for type '' */
#ifndef SOAP_TYPE__ns1__RenewLease
#define SOAP_TYPE__ns1__RenewLease (27)
#endif

/* _ns1__OpenJobExResponse has binding name '_ns1__OpenJobExResponse' for type '' */
#ifndef SOAP_TYPE__ns1__OpenJobExResponse
#define SOAP_TYPE__ns1__OpenJobExResponse (26)
#endif

/* _ns1__OpenJobResponse has binding name '_ns1__OpenJobResponse' for type '' */
#ifndef SOAP_TYPE__ns1__OpenJobResponse
#define SOAP_TYPE__ns1__OpenJobResponse (25)
#endif

/* _ns1__OpenJobEx has binding name '_ns1__OpenJobEx' for type '' */
#ifndef SOAP_TYPE__ns1__OpenJobEx
#define SOAP_TYPE__ns1__OpenJobEx (24)
#endif

/* _ns1__OpenJob has binding name '_ns1__OpenJob' for type '' */
#ifndef SOAP_TYPE__ns1__OpenJob
#define SOAP_TYPE__ns1__OpenJob (23)
#endif

/* _ns1__GetStatusResponse has binding name '_ns1__GetStatusResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetStatusResponse
#define SOAP_TYPE__ns1__GetStatusResponse (22)
#endif

/* _ns1__GetStatus has binding name '_ns1__GetStatus' for type '' */
#ifndef SOAP_TYPE__ns1__GetStatus
#define SOAP_TYPE__ns1__GetStatus (21)
#endif

/* _ns1__GetVersionResponse has binding name '_ns1__GetVersionResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetVersionResponse
#define SOAP_TYPE__ns1__GetVersionResponse (20)
#endif

/* _ns1__GetVersion has binding name '_ns1__GetVersion' for type '' */
#ifndef SOAP_TYPE__ns1__GetVersion
#define SOAP_TYPE__ns1__GetVersion (19)
#endif

/* _ns1__HelloWorldResponse has binding name '_ns1__HelloWorldResponse' for type '' */
#ifndef SOAP_TYPE__ns1__HelloWorldResponse
#define SOAP_TYPE__ns1__HelloWorldResponse (18)
#endif

/* _ns1__HelloWorld has binding name '_ns1__HelloWorld' for type '' */
#ifndef SOAP_TYPE__ns1__HelloWorld
#define SOAP_TYPE__ns1__HelloWorld (17)
#endif

/* ns1__LuaValue has binding name 'ns1__LuaValue' for type 'ns1:LuaValue' */
#ifndef SOAP_TYPE_ns1__LuaValue
#define SOAP_TYPE_ns1__LuaValue (16)
#endif

/* ns1__ArrayOfJob has binding name 'ns1__ArrayOfJob' for type 'ns1:ArrayOfJob' */
#ifndef SOAP_TYPE_ns1__ArrayOfJob
#define SOAP_TYPE_ns1__ArrayOfJob (15)
#endif

/* ns1__ArrayOfLuaValue has binding name 'ns1__ArrayOfLuaValue' for type 'ns1:ArrayOfLuaValue' */
#ifndef SOAP_TYPE_ns1__ArrayOfLuaValue
#define SOAP_TYPE_ns1__ArrayOfLuaValue (14)
#endif

/* ns1__ScriptExecution has binding name 'ns1__ScriptExecution' for type 'ns1:ScriptExecution' */
#ifndef SOAP_TYPE_ns1__ScriptExecution
#define SOAP_TYPE_ns1__ScriptExecution (13)
#endif

/* ns1__Job has binding name 'ns1__Job' for type 'ns1:Job' */
#ifndef SOAP_TYPE_ns1__Job
#define SOAP_TYPE_ns1__Job (12)
#endif

/* ns1__Status has binding name 'ns1__Status' for type 'ns1:Status' */
#ifndef SOAP_TYPE_ns1__Status
#define SOAP_TYPE_ns1__Status (11)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (181)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (180)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (177)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (175)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (174)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (183)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (182)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (176)
#endif

/* _ns1__DiagEx * has binding name 'PointerTo_ns1__DiagEx' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DiagEx
#define SOAP_TYPE_PointerTo_ns1__DiagEx (134)
#endif

/* _ns1__Diag * has binding name 'PointerTo_ns1__Diag' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Diag
#define SOAP_TYPE_PointerTo_ns1__Diag (130)
#endif

/* _ns1__CloseAllJobs * has binding name 'PointerTo_ns1__CloseAllJobs' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CloseAllJobs
#define SOAP_TYPE_PointerTo_ns1__CloseAllJobs (126)
#endif

/* _ns1__CloseExpiredJobs * has binding name 'PointerTo_ns1__CloseExpiredJobs' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CloseExpiredJobs
#define SOAP_TYPE_PointerTo_ns1__CloseExpiredJobs (122)
#endif

/* _ns1__GetAllJobsEx * has binding name 'PointerTo_ns1__GetAllJobsEx' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetAllJobsEx
#define SOAP_TYPE_PointerTo_ns1__GetAllJobsEx (118)
#endif

/* _ns1__GetAllJobs * has binding name 'PointerTo_ns1__GetAllJobs' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetAllJobs
#define SOAP_TYPE_PointerTo_ns1__GetAllJobs (114)
#endif

/* _ns1__GetExpiration * has binding name 'PointerTo_ns1__GetExpiration' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetExpiration
#define SOAP_TYPE_PointerTo_ns1__GetExpiration (110)
#endif

/* _ns1__BatchJobEx * has binding name 'PointerTo_ns1__BatchJobEx' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BatchJobEx
#define SOAP_TYPE_PointerTo_ns1__BatchJobEx (106)
#endif

/* _ns1__BatchJob * has binding name 'PointerTo_ns1__BatchJob' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__BatchJob
#define SOAP_TYPE_PointerTo_ns1__BatchJob (102)
#endif

/* _ns1__CloseJob * has binding name 'PointerTo_ns1__CloseJob' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__CloseJob
#define SOAP_TYPE_PointerTo_ns1__CloseJob (98)
#endif

/* _ns1__ExecuteEx * has binding name 'PointerTo_ns1__ExecuteEx' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__ExecuteEx
#define SOAP_TYPE_PointerTo_ns1__ExecuteEx (94)
#endif

/* _ns1__Execute * has binding name 'PointerTo_ns1__Execute' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Execute
#define SOAP_TYPE_PointerTo_ns1__Execute (90)
#endif

/* _ns1__RenewLease * has binding name 'PointerTo_ns1__RenewLease' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__RenewLease
#define SOAP_TYPE_PointerTo_ns1__RenewLease (86)
#endif

/* _ns1__OpenJobEx * has binding name 'PointerTo_ns1__OpenJobEx' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__OpenJobEx
#define SOAP_TYPE_PointerTo_ns1__OpenJobEx (82)
#endif

/* _ns1__OpenJob * has binding name 'PointerTo_ns1__OpenJob' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__OpenJob
#define SOAP_TYPE_PointerTo_ns1__OpenJob (78)
#endif

/* _ns1__GetStatus * has binding name 'PointerTo_ns1__GetStatus' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetStatus
#define SOAP_TYPE_PointerTo_ns1__GetStatus (74)
#endif

/* _ns1__GetVersion * has binding name 'PointerTo_ns1__GetVersion' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetVersion
#define SOAP_TYPE_PointerTo_ns1__GetVersion (70)
#endif

/* _ns1__HelloWorld * has binding name 'PointerTo_ns1__HelloWorld' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__HelloWorld
#define SOAP_TYPE_PointerTo_ns1__HelloWorld (66)
#endif

/* ns1__ArrayOfJob * has binding name 'PointerTons1__ArrayOfJob' for type 'ns1:ArrayOfJob' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfJob
#define SOAP_TYPE_PointerTons1__ArrayOfJob (65)
#endif

/* ns1__ScriptExecution * has binding name 'PointerTons1__ScriptExecution' for type 'ns1:ScriptExecution' */
#ifndef SOAP_TYPE_PointerTons1__ScriptExecution
#define SOAP_TYPE_PointerTons1__ScriptExecution (64)
#endif

/* ns1__Status * has binding name 'PointerTons1__Status' for type 'ns1:Status' */
#ifndef SOAP_TYPE_PointerTons1__Status
#define SOAP_TYPE_PointerTons1__Status (63)
#endif

/* ns1__Job * has binding name 'PointerTons1__Job' for type 'ns1:Job' */
#ifndef SOAP_TYPE_PointerTons1__Job
#define SOAP_TYPE_PointerTons1__Job (61)
#endif

/* ns1__LuaValue * has binding name 'PointerTons1__LuaValue' for type 'ns1:LuaValue' */
#ifndef SOAP_TYPE_PointerTons1__LuaValue
#define SOAP_TYPE_PointerTons1__LuaValue (59)
#endif

/* ns1__ArrayOfLuaValue * has binding name 'PointerTons1__ArrayOfLuaValue' for type 'ns1:ArrayOfLuaValue' */
#ifndef SOAP_TYPE_PointerTons1__ArrayOfLuaValue
#define SOAP_TYPE_PointerTons1__ArrayOfLuaValue (58)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (55)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns1__Job *>  has binding name 'std__vectorTemplateOfPointerTons1__Job' for type 'ns1:Job' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__Job
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__Job (62)
#endif

/* std::vector<ns1__LuaValue *>  has binding name 'std__vectorTemplateOfPointerTons1__LuaValue' for type 'ns1:LuaValue' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons1__LuaValue
#define SOAP_TYPE_std__vectorTemplateOfPointerTons1__LuaValue (60)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
